From: Matthias Schiffer <mschiffer@universe-factory.net>
Date: Tue, 20 Mar 2018 00:27:10 +0100
Subject: hostapd: downgrade to CC version

diff --git a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
index 703609b1475449c4c70a50fe305db2fbab4b21ce..0fd57a12dfaa7ab40a1adefb7d9051987995a250 100644
--- a/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
+++ b/package/kernel/mac80211/files/lib/netifd/wireless/mac80211.sh
@@ -792,7 +792,7 @@ drv_mac80211_setup() {
 	for_each_interface "ap" mac80211_prepare_vif
 
 	[ -n "$hostapd_ctrl" ] && {
-		/usr/sbin/hostapd -s -P /var/run/wifi-$phy.pid -B "$hostapd_conf_file"
+		/usr/sbin/hostapd -P /var/run/wifi-$phy.pid -B "$hostapd_conf_file"
 		ret="$?"
 		wireless_add_process "$(cat /var/run/wifi-$phy.pid)" "/usr/sbin/hostapd" 1
 		[ "$ret" != 0 ] && {
diff --git a/package/network/services/hostapd/Config.in b/package/network/services/hostapd/Config.in
index fea5ed3ba38fad4ea498131925b4860396aa6761..aee2a15fd314479ba4d5e29a8bb4ec5855a78342 100644
--- a/package/network/services/hostapd/Config.in
+++ b/package/network/services/hostapd/Config.in
@@ -10,10 +10,11 @@ config WPA_SUPPLICANT_NO_TIMESTAMP_CHECK
 choice
 	prompt "Choose TLS provider"
 	default WPA_SUPPLICANT_INTERNAL
-	depends on PACKAGE_wpa-supplicant || PACKAGE_wpad
+	depends on PACKAGE_wpa-supplicant || PACKAGE_wpa-supplicant-mesh || PACKAGE_wpad || PACKAGE_wpad-mesh
 
 config WPA_SUPPLICANT_INTERNAL
 	bool "internal"
+	depends on PACKAGE_wpa-supplicant || PACKAGE_wpad
 
 config WPA_SUPPLICANT_OPENSSL
 	bool "openssl"
@@ -46,10 +47,6 @@ config DRIVER_11N_SUPPORT
 	bool
 	default n
 
-config DRIVER_11AC_SUPPORT
-	bool
-	default n
-
 config DRIVER_11W_SUPPORT
 	bool
 	default n
diff --git a/package/network/services/hostapd/Makefile b/package/network/services/hostapd/Makefile
index c9de3c05bbebca54fcd2c9fd966c8a678bf9aa9e..9c9b0e9ee817cf614efc896c8f9607e3b5a6ccae 100644
--- a/package/network/services/hostapd/Makefile
+++ b/package/network/services/hostapd/Makefile
@@ -7,15 +7,18 @@
 include $(TOPDIR)/rules.mk
 
 PKG_NAME:=hostapd
-PKG_RELEASE:=7
-
-PKG_SOURCE_URL:=http://w1.fi/hostap.git
+PKG_VERSION:=2016-06-15
+PKG_RELEASE:=1
+PKG_REV:=31d3692fe5d56c05753ed4a70c7943979e1d29e7
+
+PKG_SOURCE:=$(PKG_NAME)-$(PKG_VERSION).tar.bz2
+PKG_SOURCE_URL:=git://w1.fi/srv/git/hostap.git
+PKG_SOURCE_SUBDIR:=$(PKG_NAME)-$(PKG_VERSION)
+PKG_SOURCE_VERSION:=$(PKG_REV)
 PKG_SOURCE_PROTO:=git
-PKG_SOURCE_DATE:=2016-12-19
-PKG_SOURCE_VERSION:=ad02e79d12fd70ed6bd5fbaf64001a2851e5bb7b
-PKG_MIRROR_HASH:=7a0983f004b156d46911765c113754a4c00f56fb889430620bbd061b3b1fcf33
+# PKG_MIRROR_MD5SUM:=4e7c1f97edd7514535056fce54ae053a
 
-PKG_MAINTAINER:=Felix Fietkau <nbd@nbd.name>
+PKG_MAINTAINER:=Felix Fietkau <nbd@openwrt.org>
 PKG_LICENSE:=BSD-3-Clause
 
 PKG_BUILD_PARALLEL:=1
@@ -26,10 +29,10 @@ PKG_CONFIG_DEPENDS:= \
 	CONFIG_PACKAGE_kmod-cfg80211 \
 	CONFIG_PACKAGE_hostapd \
 	CONFIG_PACKAGE_hostapd-mini \
+	CONFIG_PACKAGE_kmod-hostap \
 	CONFIG_WPA_RFKILL_SUPPORT \
 	CONFIG_DRIVER_WEXT_SUPPORT \
-	CONFIG_DRIVER_11N_SUPPORT \
-	CONFIG_DRIVER_11AC_SUPPORT
+	CONFIG_DRIVER_11N_SUPPORT
 
 LOCAL_TYPE=$(strip \
 		$(if $(findstring wpad,$(BUILD_VARIANT)),wpad, \
@@ -42,7 +45,7 @@ ifeq ($(LOCAL_VARIANT),mesh)
   CONFIG_VARIANT:=full
 endif
 
-ifneq ($(LOCAL_TYPE),hostapd)
+ifeq ($(LOCAL_TYPE),supplicant)
   ifeq ($(LOCAL_VARIANT),full)
     PKG_CONFIG_DEPENDS += \
 		CONFIG_WPA_SUPPLICANT_INTERNAL \
@@ -50,7 +53,7 @@ ifneq ($(LOCAL_TYPE),hostapd)
   endif
 endif
 
-PKG_BUILD_DIR=$(BUILD_DIR)/$(PKG_NAME)-$(BUILD_VARIANT)/$(PKG_NAME)-$(PKG_VERSION)
+PKG_BUILD_DIR:=$(BUILD_DIR)/$(PKG_NAME)-$(BUILD_VARIANT)/$(PKG_NAME)-$(PKG_VERSION)
 
 include $(INCLUDE_DIR)/package.mk
 
@@ -60,15 +63,11 @@ ifneq ($(CONFIG_DRIVER_11N_SUPPORT),)
   HOSTAPD_IEEE80211N:=y
 endif
 
-ifneq ($(CONFIG_DRIVER_11AC_SUPPORT),)
-  HOSTAPD_IEEE80211AC:=y
-endif
-
 DRIVER_MAKEOPTS= \
 	CONFIG_ACS=$(CONFIG_PACKAGE_kmod-cfg80211) \
 	CONFIG_DRIVER_NL80211=$(CONFIG_PACKAGE_kmod-cfg80211) \
+	CONFIG_DRIVER_HOSTAP=$(CONFIG_PACKAGE_kmod-hostap) \
 	CONFIG_IEEE80211N=$(HOSTAPD_IEEE80211N) \
-	CONFIG_IEEE80211AC=$(HOSTAPD_IEEE80211AC) \
 	CONFIG_DRIVER_WEXT=$(CONFIG_DRIVER_WEXT_SUPPORT) \
 
 ifeq ($(LOCAL_VARIANT),full)
@@ -178,7 +177,7 @@ endef
 define Package/wpad-mesh
 $(call Package/wpad/Default)
   TITLE+= (with 802.11s mesh and SAE support)
-  DEPENDS:=$(DRV_DEPENDS) +libubus +PACKAGE_wpad-mesh:libopenssl @PACKAGE_kmod-cfg80211 @(!TARGET_uml||BROKEN)
+  DEPENDS:=$(DRV_DEPENDS) +libubus +PACKAGE_wpad-mesh:libopenssl @(!TARGET_uml||BROKEN)
   VARIANT:=wpad-mesh
 endef
 
@@ -196,6 +195,10 @@ define Package/wpa-supplicant
   VARIANT:=supplicant-full
 endef
 
+define Package/wpa-supplicant/Description
+  WPA Supplicant
+endef
+
 define Package/wpa-supplicant/config
 	source "$(SOURCE)/Config.in"
 endef
@@ -203,19 +206,27 @@ endef
 define Package/wpa-supplicant-p2p
   $(Package/wpa-supplicant)
   TITLE:=WPA Supplicant (with Wi-Fi P2P support)
-  DEPENDS:=$(DRV_DEPENDS) @PACKAGE_kmod-cfg80211
+  DEPENDS:=$(DRV_DEPENDS)
   CONFLICTS:=wpad wpad-mini wpad-mesh
   VARIANT:=supplicant-p2p
 endef
 
+define Package/wpa-supplicant-p2p/Description
+  WPA Supplicant (with Wi-Fi P2P support)
+endef
+
 define Package/wpa-supplicant-mesh
   $(Package/wpa-supplicant)
   TITLE:=WPA Supplicant (with 802.11s and SAE)
-  DEPENDS:=$(DRV_DEPENDS) +PACKAGE_wpa-supplicant-mesh:libopenssl @PACKAGE_kmod-cfg80211 @(!TARGET_uml||BROKEN)
+  DEPENDS:=$(DRV_DEPENDS) @(!TARGET_uml||BROKEN)
   CONFLICTS:=wpad wpad-mesh wpad-mesh
   VARIANT:=supplicant-mesh
 endef
 
+define Package/wpa-supplicant-mesh/Description
+  WPA Supplicant (variant with 802.11s and SAE support)
+endef
+
 define Package/wpa-supplicant-mini
   $(Package/wpa-supplicant)
   TITLE:=WPA Supplicant (minimal version)
@@ -224,11 +235,19 @@ define Package/wpa-supplicant-mini
   VARIANT:=supplicant-mini
 endef
 
+define Package/wpa-supplicant-mini/Description
+  WPA Supplicant (minimal version)
+endef
+
 define Package/wpa-cli
   SECTION:=net
   CATEGORY:=Network
   DEPENDS:=@PACKAGE_wpa-supplicant||PACKAGE_wpa-supplicant-p2p||PACKAGE_wpad-mini||PACKAGE_wpad||PACKAGE_wpad-mesh
-  TITLE:=WPA Supplicant command line control utility
+  TITLE:=WPA Supplicant command line interface
+endef
+
+define Package/wpa-cli/Description
+  WPA Supplicant control utility
 endef
 
 define Package/hostapd-common
@@ -237,12 +256,18 @@ define Package/hostapd-common
   CATEGORY:=Network
 endef
 
+define Package/hostapd-common-old
+  TITLE:=hostapd/wpa_supplicant common support files (legacy drivers)
+  SECTION:=net
+  CATEGORY:=Network
+endef
+
 define Package/eapol-test
   TITLE:=802.1x authentication test utility
   SECTION:=net
   CATEGORY:=Network
   VARIANT:=supplicant-full
-  DEPENDS:=$(DRV_DEPENDS) +WPA_SUPPLICANT_OPENSSL:libopenssl
+  DEPENDS:=$(DRV_DEPENDS)
 endef
 
 
@@ -318,19 +343,19 @@ define Build/Compile/wpad
 endef
 
 define Build/Compile/hostapd
-	+$(call Build/RunMake,hostapd, \
+	$(call Build/RunMake,hostapd, \
 		hostapd hostapd_cli \
 	)
 endef
 
 define Build/Compile/supplicant
-	+$(call Build/RunMake,wpa_supplicant, \
+	$(call Build/RunMake,wpa_supplicant, \
 		wpa_cli wpa_supplicant \
 	)
 endef
 
 define Build/Compile/supplicant-full
-	+$(call Build/RunMake,wpa_supplicant, \
+	$(call Build/RunMake,wpa_supplicant, \
 		eapol_test \
 	)
 endef
@@ -350,7 +375,13 @@ endef
 
 define Package/hostapd-common/install
 	$(INSTALL_DIR) $(1)/lib/netifd
-	$(INSTALL_DATA) ./files/hostapd.sh $(1)/lib/netifd/hostapd.sh
+	$(INSTALL_DATA) ./files/netifd.sh $(1)/lib/netifd/hostapd.sh
+endef
+
+define Package/hostapd-common-old/install
+	$(INSTALL_DIR) $(1)/lib/wifi
+	$(INSTALL_DATA) ./files/hostapd.sh $(1)/lib/wifi/hostapd.sh
+	$(INSTALL_DATA) ./files/wpa_supplicant.sh $(1)/lib/wifi/wpa_supplicant.sh
 endef
 
 define Package/hostapd/install
@@ -383,7 +414,6 @@ define Package/wpa-supplicant/install
 endef
 Package/wpa-supplicant-mini/install = $(Package/wpa-supplicant/install)
 Package/wpa-supplicant-p2p/install = $(Package/wpa-supplicant/install)
-Package/wpa-supplicant-mesh/install = $(Package/wpa-supplicant/install)
 
 ifneq ($(LOCAL_TYPE),hostapd)
   define Package/wpa-cli/install
@@ -411,4 +441,5 @@ $(eval $(call BuildPackage,wpa-supplicant-p2p))
 $(eval $(call BuildPackage,wpa-cli))
 $(eval $(call BuildPackage,hostapd-utils))
 $(eval $(call BuildPackage,hostapd-common))
+$(eval $(call BuildPackage,hostapd-common-old))
 $(eval $(call BuildPackage,eapol-test))
diff --git a/package/network/services/hostapd/files/hostapd-full.config b/package/network/services/hostapd/files/hostapd-full.config
index 4a2e87c2ebeecbf8d29aa006ca30fa09aa7f9296..f1b2655cfcb7f8cbc61399eb3ffb886770b55a3f 100644
--- a/package/network/services/hostapd/files/hostapd-full.config
+++ b/package/network/services/hostapd/files/hostapd-full.config
@@ -10,7 +10,7 @@
 # to override previous values of the variables.
 
 # Driver interface for Host AP driver
-#CONFIG_DRIVER_HOSTAP=y
+CONFIG_DRIVER_HOSTAP=y
 
 # Driver interface for wired authenticator
 CONFIG_DRIVER_WIRED=y
@@ -53,9 +53,6 @@ CONFIG_PEERKEY=y
 # Integrated EAP server
 CONFIG_EAP=y
 
-# EAP-FAST for the integrated EAP server
-CONFIG_EAP_FAST=y
-
 # EAP-MD5 for the integrated EAP server
 CONFIG_EAP_MD5=y
 
@@ -146,9 +143,6 @@ CONFIG_IEEE80211AC=y
 # code is not needed.
 #CONFIG_NO_STDOUT_DEBUG=y
 
-# Send debug messages to syslog instead of stdout
-CONFIG_DEBUG_SYSLOG=y
-
 # Remove support for RADIUS accounting
 #CONFIG_NO_ACCOUNTING=y
 
diff --git a/package/network/services/hostapd/files/hostapd-mini.config b/package/network/services/hostapd/files/hostapd-mini.config
index 2bd7d239c506915181dc7674d537bf19a15ec50e..118d97cb3a21c195bc903fde2d4f885699b2425b 100644
--- a/package/network/services/hostapd/files/hostapd-mini.config
+++ b/package/network/services/hostapd/files/hostapd-mini.config
@@ -10,7 +10,7 @@
 # to override previous values of the variables.
 
 # Driver interface for Host AP driver
-#CONFIG_DRIVER_HOSTAP=y
+CONFIG_DRIVER_HOSTAP=y
 
 # Driver interface for wired authenticator
 CONFIG_DRIVER_WIRED=y
@@ -142,9 +142,6 @@ CONFIG_IEEE80211AC=y
 # code is not needed.
 #CONFIG_NO_STDOUT_DEBUG=y
 
-# Send debug messages to syslog instead of stdout
-CONFIG_DEBUG_SYSLOG=y
-
 # Remove support for RADIUS accounting
 CONFIG_NO_ACCOUNTING=y
 
diff --git a/package/network/services/hostapd/files/hostapd.sh b/package/network/services/hostapd/files/hostapd.sh
index 1f286611175fa9fdfd4f7317f328d2ca940371ce..7aec7ad8a40ae843453e2c3e8f812a93c9635320 100644
--- a/package/network/services/hostapd/files/hostapd.sh
+++ b/package/network/services/hostapd/files/hostapd.sh
@@ -1,513 +1,351 @@
-. /lib/functions/network.sh
-
-wpa_supplicant_add_rate() {
-	local var="$1"
-	local val="$(($2 / 1000))"
-	local sub="$((($2 / 100) % 10))"
-	append $var "$val" ","
-	[ $sub -gt 0 ] && append $var "."
-}
-
-hostapd_add_rate() {
-	local var="$1"
-	local val="$(($2 / 100))"
-	append $var "$val" " "
-}
-
-hostapd_append_wep_key() {
-	local var="$1"
-
-	wep_keyidx=0
-	set_default key 1
-	case "$key" in
-		[1234])
-			for idx in 1 2 3 4; do
-				local zidx
-				zidx=$(($idx - 1))
-				json_get_var ckey "key${idx}"
-				[ -n "$ckey" ] && \
-					append $var "wep_key${zidx}=$(prepare_key_wep "$ckey")" "$N$T"
-			done
-			wep_keyidx=$((key - 1))
-		;;
-		*)
-			append $var "wep_key0=$(prepare_key_wep "$key")" "$N$T"
-		;;
-	esac
-}
-
-hostapd_append_wpa_key_mgmt() {
-	local auth_type="$(echo $auth_type | tr 'a-z' 'A-Z')"
-
-	append wpa_key_mgmt "WPA-$auth_type"
-	[ "${ieee80211r:-0}" -gt 0 ] && append wpa_key_mgmt "FT-${auth_type}"
-	[ "${ieee80211w:-0}" -gt 0 ] && append wpa_key_mgmt "WPA-${auth_type}-SHA256"
-}
-
-hostapd_add_log_config() {
-	config_add_boolean \
-		log_80211 \
-		log_8021x \
-		log_radius \
-		log_wpa \
-		log_driver \
-		log_iapp \
-		log_mlme
-
-	config_add_int log_level
-}
-
-hostapd_common_add_device_config() {
-	config_add_array basic_rate
-	config_add_array supported_rates
-
-	config_add_string country
-	config_add_boolean country_ie doth
-	config_add_string require_mode
-	config_add_boolean legacy_rates
-
-	hostapd_add_log_config
-}
-
-hostapd_prepare_device_config() {
-	local config="$1"
-	local driver="$2"
-
-	local base="${config%%.conf}"
-	local base_cfg=
-
-	json_get_vars country country_ie beacon_int:100 doth require_mode legacy_rates
-
-	hostapd_set_log_options base_cfg
-
-	set_default country_ie 1
-	set_default doth 1
-	set_default legacy_rates 1
-
-	[ "$hwmode" = "b" ] && legacy_rates=1
-
-	[ -n "$country" ] && {
-		append base_cfg "country_code=$country" "$N"
-
-		[ "$country_ie" -gt 0 ] && append base_cfg "ieee80211d=1" "$N"
-		[ "$hwmode" = "a" -a "$doth" -gt 0 ] && append base_cfg "ieee80211h=1" "$N"
-	}
-
-	local brlist= br
-	json_get_values basic_rate_list basic_rate
-	local rlist= r
-	json_get_values rate_list supported_rates
-
-	[ -n "$hwmode" ] && append base_cfg "hw_mode=$hwmode" "$N"
-	[ "$legacy_rates" -eq 0 ] && set_default require_mode g
-
-	[ "$hwmode" = "g" ] && {
-		[ "$legacy_rates" -eq 0 ] && set_default rate_list "6000 9000 12000 18000 24000 36000 48000 54000"
-		[ -n "$require_mode" ] && set_default basic_rate_list "6000 12000 24000"
-	}
-
-	case "$require_mode" in
-		n) append base_cfg "require_ht=1" "$N";;
-		ac) append base_cfg "require_vht=1" "$N";;
-	esac
-
-	for r in $rate_list; do
-		hostapd_add_rate rlist "$r"
-	done
-
-	for br in $basic_rate_list; do
-		hostapd_add_rate brlist "$br"
-	done
-
-	[ -n "$rlist" ] && append base_cfg "supported_rates=$rlist" "$N"
-	[ -n "$brlist" ] && append base_cfg "basic_rates=$brlist" "$N"
-	append base_cfg "beacon_int=$beacon_int" "$N"
-
-	cat > "$config" <<EOF
-driver=$driver
-$base_cfg
-EOF
-}
-
-hostapd_common_add_bss_config() {
-	config_add_string 'bssid:macaddr' 'ssid:string'
-	config_add_boolean wds wmm uapsd hidden
-
-	config_add_int maxassoc max_inactivity
-	config_add_boolean disassoc_low_ack isolate short_preamble
-
-	config_add_int \
-		wep_rekey eap_reauth_period \
-		wpa_group_rekey wpa_pair_rekey wpa_master_rekey
-	config_add_boolean wpa_disable_eapol_key_retries
-
-	config_add_boolean tdls_prohibit
-
-	config_add_boolean rsn_preauth auth_cache
-	config_add_int ieee80211w
-	config_add_int eapol_version
-
-	config_add_string 'auth_server:host' 'server:host'
-	config_add_string auth_secret
-	config_add_int 'auth_port:port' 'port:port'
-
-	config_add_string acct_server
-	config_add_string acct_secret
-	config_add_int acct_port
-	config_add_int acct_interval
-
-	config_add_string dae_client
-	config_add_string dae_secret
-	config_add_int dae_port
-
-	config_add_string nasid
-	config_add_string ownip
-	config_add_string iapp_interface
-	config_add_string eap_type ca_cert client_cert identity anonymous_identity auth priv_key priv_key_pwd
-
-	config_add_int dynamic_vlan vlan_naming
-	config_add_string vlan_tagged_interface vlan_bridge
-	config_add_string vlan_file
-
-	config_add_string 'key1:wepkey' 'key2:wepkey' 'key3:wepkey' 'key4:wepkey' 'password:wpakey'
-
-	config_add_string wpa_psk_file
-
-	config_add_boolean wps_pushbutton wps_label ext_registrar wps_pbc_in_m1
-	config_add_int wps_ap_setup_locked wps_independent
-	config_add_string wps_device_type wps_device_name wps_manufacturer wps_pin
-
-	config_add_boolean ieee80211r pmk_r1_push
-	config_add_int r0_key_lifetime reassociation_deadline
-	config_add_string mobility_domain r1_key_holder
-	config_add_array r0kh r1kh
-
-	config_add_int ieee80211w_max_timeout ieee80211w_retry_timeout
-
-	config_add_string macfilter 'macfile:file'
-	config_add_array 'maclist:list(macaddr)'
-
-	config_add_array bssid_blacklist
-	config_add_array bssid_whitelist
-
-	config_add_int mcast_rate
-	config_add_array basic_rate
-	config_add_array supported_rates
-}
-
 hostapd_set_bss_options() {
 	local var="$1"
-	local phy="$2"
-	local vif="$3"
-
-	wireless_vif_parse_encryption
-
-	local bss_conf
-	local wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey wpa_key_mgmt
-
-	json_get_vars \
-		wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey \
-		wpa_disable_eapol_key_retries tdls_prohibit \
-		maxassoc max_inactivity disassoc_low_ack isolate auth_cache \
-		wps_pushbutton wps_label ext_registrar wps_pbc_in_m1 wps_ap_setup_locked \
-		wps_independent wps_device_type wps_device_name wps_manufacturer wps_pin \
-		macfilter ssid wmm uapsd hidden short_preamble rsn_preauth \
-		iapp_interface eapol_version dynamic_vlan ieee80211w nasid \
-		acct_server acct_secret acct_port acct_interval
-
-	set_default isolate 0
-	set_default maxassoc 0
-	set_default max_inactivity 0
-	set_default short_preamble 1
-	set_default disassoc_low_ack 1
-	set_default hidden 0
-	set_default wmm 1
-	set_default uapsd 1
-	set_default wpa_disable_eapol_key_retries 0
-	set_default tdls_prohibit 0
-	set_default eapol_version 0
-	set_default acct_port 1813
-
-	append bss_conf "ctrl_interface=/var/run/hostapd"
-	if [ "$isolate" -gt 0 ]; then
-		append bss_conf "ap_isolate=$isolate" "$N"
+	local vif="$2"
+	local enc wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey wps_possible wpa_key_mgmt
+
+	config_get enc "$vif" encryption "none"
+	config_get wep_rekey        "$vif" wep_rekey        # 300
+	config_get wpa_group_rekey  "$vif" wpa_group_rekey  # 300
+	config_get wpa_pair_rekey   "$vif" wpa_pair_rekey   # 300
+	config_get wpa_master_rekey "$vif" wpa_master_rekey # 640
+	config_get_bool ap_isolate "$vif" isolate 0
+	config_get_bool disassoc_low_ack "$vif" disassoc_low_ack 1
+	config_get max_num_sta "$vif" max_num_sta 0
+	config_get max_inactivity "$vif" max_inactivity 0
+	config_get_bool preamble "$vif" short_preamble 1
+
+	config_get device "$vif" device
+	config_get hwmode "$device" hwmode
+	config_get phy "$device" phy
+
+	append "$var" "ctrl_interface=/var/run/hostapd-$phy" "$N"
+
+	if [ "$ap_isolate" -gt 0 ]; then
+		append "$var" "ap_isolate=$ap_isolate" "$N"
 	fi
-	if [ "$maxassoc" -gt 0 ]; then
-		append bss_conf "max_num_sta=$maxassoc" "$N"
+	if [ "$max_num_sta" -gt 0 ]; then
+		append "$var" "max_num_sta=$max_num_sta" "$N"
 	fi
 	if [ "$max_inactivity" -gt 0 ]; then
-		append bss_conf "ap_max_inactivity=$max_inactivity" "$N"
+		append "$var" "ap_max_inactivity=$max_inactivity" "$N"
+	fi
+	append "$var" "disassoc_low_ack=$disassoc_low_ack" "$N"
+	if [ "$preamble" -gt 0 ]; then
+		append "$var" "preamble=$preamble" "$N"
 	fi
 
-	append bss_conf "disassoc_low_ack=$disassoc_low_ack" "$N"
-	append bss_conf "preamble=$short_preamble" "$N"
-	append bss_conf "wmm_enabled=$wmm" "$N"
-	append bss_conf "ignore_broadcast_ssid=$hidden" "$N"
-	append bss_conf "uapsd_advertisement_enabled=$uapsd" "$N"
+	# Examples:
+	# psk-mixed/tkip 	=> WPA1+2 PSK, TKIP
+	# wpa-psk2/tkip+aes	=> WPA2 PSK, CCMP+TKIP
+	# wpa2/tkip+aes 	=> WPA2 RADIUS, CCMP+TKIP
+	# ...
 
-	[ "$tdls_prohibit" -gt 0 ] && append bss_conf "tdls_prohibit=$tdls_prohibit" "$N"
+	# TODO: move this parsing function somewhere generic, so that
+	# later it can be reused by drivers that don't use hostapd
 
-	[ "$wpa" -gt 0 ] && {
-		[ -n "$wpa_group_rekey"  ] && append bss_conf "wpa_group_rekey=$wpa_group_rekey" "$N"
-		[ -n "$wpa_pair_rekey"   ] && append bss_conf "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
-		[ -n "$wpa_master_rekey" ] && append bss_conf "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
-	}
+	# crypto defaults: WPA2 vs WPA1
+	case "$enc" in
+		wpa2*|*psk2*)
+			wpa=2
+			crypto="CCMP"
+		;;
+		*mixed*)
+			wpa=3
+			crypto="CCMP TKIP"
+		;;
+		*)
+			wpa=1
+			crypto="TKIP"
+		;;
+	esac
 
-	[ -n "$nasid" ] && append bss_conf "nas_identifier=$nasid" "$N"
-	[ -n "$acct_server" ] && {
-		append bss_conf "acct_server_addr=$acct_server" "$N"
-		append bss_conf "acct_server_port=$acct_port" "$N"
-		[ -n "$acct_secret" ] && \
-			append bss_conf "acct_server_shared_secret=$acct_secret" "$N"
-		[ -n "$acct_interval" ] && \
-			append bss_conf "radius_acct_interim_interval=$acct_interval" "$N"
-	}
+	# explicit override for crypto setting
+	case "$enc" in
+		*tkip+aes|*tkip+ccmp|*aes+tkip|*ccmp+tkip) crypto="CCMP TKIP";;
+		*aes|*ccmp) crypto="CCMP";;
+		*tkip) crypto="TKIP";;
+	esac
 
-	local vlan_possible=""
+	# enforce CCMP for 11ng and 11na
+	case "$hwmode:$crypto" in
+		*ng:TKIP|*na:TKIP) crypto="CCMP TKIP";;
+	esac
 
-	case "$auth_type" in
+	# use crypto/auth settings for building the hostapd config
+	case "$enc" in
 		none)
 			wps_possible=1
+			wpa=0
+			crypto=
 			# Here we make the assumption that if we're in open mode
 			# with WPS enabled, we got to be in unconfigured state.
 			wps_not_configured=1
 		;;
-		psk)
-			json_get_vars key wpa_psk_file
-			if [ ${#key} -lt 8 ]; then
-				wireless_setup_vif_failed INVALID_WPA_PSK
-				return 1
-			elif [ ${#key} -eq 64 ]; then
-				append bss_conf "wpa_psk=$key" "$N"
+		*psk*)
+			config_get psk "$vif" key
+			if [ ${#psk} -eq 64 ]; then
+				append "$var" "wpa_psk=$psk" "$N"
 			else
-				append bss_conf "wpa_passphrase=$key" "$N"
+				append "$var" "wpa_passphrase=$psk" "$N"
 			fi
-			[ -n "$wpa_psk_file" ] && {
-				[ -e "$wpa_psk_file" ] || touch "$wpa_psk_file"
-				append bss_conf "wpa_psk_file=$wpa_psk_file" "$N"
-			}
-			[ "$eapol_version" -ge "1" -a "$eapol_version" -le "2" ] && append bss_conf "eapol_version=$eapol_version" "$N"
-
 			wps_possible=1
+			[ -n "$wpa_group_rekey"  ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
+			[ -n "$wpa_pair_rekey"   ] && append "$var" "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
+			[ -n "$wpa_master_rekey" ] && append "$var" "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
+			append wpa_key_mgmt "WPA-PSK"
 		;;
-		eap)
-			json_get_vars \
-				auth_server auth_secret auth_port \
-				dae_client dae_secret dae_port \
-				ownip \
-				eap_reauth_period
-
-			# radius can provide VLAN ID for clients
-			vlan_possible=1
-
-			# legacy compatibility
-			[ -n "$auth_server" ] || json_get_var auth_server server
-			[ -n "$auth_port" ] || json_get_var auth_port port
-			[ -n "$auth_secret" ] || json_get_var auth_secret key
-
-			set_default auth_port 1812
-			set_default dae_port 3799
-
-
-			append bss_conf "auth_server_addr=$auth_server" "$N"
-			append bss_conf "auth_server_port=$auth_port" "$N"
-			append bss_conf "auth_server_shared_secret=$auth_secret" "$N"
-
-			[ -n "$eap_reauth_period" ] && append bss_conf "eap_reauth_period=$eap_reauth_period" "$N"
-
+		*wpa*|*8021x*)
+			# required fields? formats?
+			# hostapd is particular, maybe a default configuration for failures
+			config_get auth_server "$vif" auth_server
+			[ -z "$auth_server" ] && config_get auth_server "$vif" server
+			append "$var" "auth_server_addr=$auth_server" "$N"
+			config_get auth_port "$vif" auth_port
+			[ -z "$auth_port" ] && config_get auth_port "$vif" port
+			auth_port=${auth_port:-1812}
+			append "$var" "auth_server_port=$auth_port" "$N"
+			config_get auth_secret "$vif" auth_secret
+			[ -z "$auth_secret" ] && config_get auth_secret "$vif" key
+			append "$var" "auth_server_shared_secret=$auth_secret" "$N"
+			# You don't really want to enable this unless you are doing
+			# some corner case testing or are using OpenWrt as a work around
+			# for some systematic issues.
+			config_get_bool auth_cache "$vif" auth_cache 0
+			config_get rsn_preauth "$vif" rsn_preauth
+			[ "$auth_cache" -gt 0 ] || [[ "$rsn_preauth" = 1 ]] || append "$var" "disable_pmksa_caching=1" "$N"
+			[ "$auth_cache" -gt 0 ] || [[ "$rsn_preauth" = 1 ]] || append "$var" "okc=0" "$N"
+			config_get acct_server "$vif" acct_server
+			[ -n "$acct_server" ] && append "$var" "acct_server_addr=$acct_server" "$N"
+			config_get acct_port "$vif" acct_port
+			[ -n "$acct_port" ] && acct_port=${acct_port:-1813}
+			[ -n "$acct_port" ] && append "$var" "acct_server_port=$acct_port" "$N"
+			config_get acct_secret "$vif" acct_secret
+			[ -n "$acct_secret" ] && append "$var" "acct_server_shared_secret=$acct_secret" "$N"
+			config_get eap_reauth_period "$vif" eap_reauth_period
+			[ -n "$eap_reauth_period" ] && append "$var" "eap_reauth_period=$eap_reauth_period" "$N"
+			config_get dae_client "$vif" dae_client
+			config_get dae_secret "$vif" dae_secret
 			[ -n "$dae_client" -a -n "$dae_secret" ] && {
-				append bss_conf "radius_das_port=$dae_port" "$N"
-				append bss_conf "radius_das_client=$dae_client $dae_secret" "$N"
+				config_get dae_port  "$vif" dae_port
+				append "$var" "radius_das_port=${dae_port:-3799}" "$N"
+				append "$var" "radius_das_client=$dae_client $dae_secret" "$N"
 			}
-
-			[ -n "$ownip" ] && append bss_conf "own_ip_addr=$ownip" "$N"
-			append bss_conf "eapol_key_index_workaround=1" "$N"
-			append bss_conf "ieee8021x=1" "$N"
-
-			[ "$eapol_version" -ge "1" -a "$eapol_version" -le "2" ] && append bss_conf "eapol_version=$eapol_version" "$N"
+			config_get ownip "$vif" ownip
+			append "$var" "own_ip_addr=$ownip" "$N"
+			append "$var" "eapol_key_index_workaround=1" "$N"
+			append "$var" "ieee8021x=1" "$N"
+			append wpa_key_mgmt "WPA-EAP"
+			[ -n "$wpa_group_rekey"  ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
+			[ -n "$wpa_pair_rekey"   ] && append "$var" "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
+			[ -n "$wpa_master_rekey" ] && append "$var" "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
 		;;
-		wep)
-			local wep_keyidx=0
-			json_get_vars key
-			hostapd_append_wep_key bss_conf
-			append bss_conf "wep_default_key=$wep_keyidx" "$N"
-			[ -n "$wep_rekey" ] && append bss_conf "wep_rekey_period=$wep_rekey" "$N"
+		*wep*)
+			config_get key "$vif" key
+			key="${key:-1}"
+			case "$key" in
+				[1234])
+					for idx in 1 2 3 4; do
+						local zidx
+						zidx=$(($idx - 1))
+						config_get ckey "$vif" "key${idx}"
+						[ -n "$ckey" ] && \
+							append "$var" "wep_key${zidx}=$(prepare_key_wep "$ckey")" "$N"
+					done
+					append "$var" "wep_default_key=$((key - 1))"  "$N"
+				;;
+				*)
+					append "$var" "wep_key0=$(prepare_key_wep "$key")" "$N"
+					append "$var" "wep_default_key=0" "$N"
+					[ -n "$wep_rekey" ] && append "$var" "wep_rekey_period=$wep_rekey" "$N"
+				;;
+			esac
+			case "$enc" in
+				*shared*)
+					auth_algs=2
+				;;
+				*mixed*)
+					auth_algs=3
+				;;
+			esac
+			wpa=0
+			crypto=
+		;;
+		*)
+			wpa=0
+			crypto=
 		;;
 	esac
+	append "$var" "auth_algs=${auth_algs:-1}" "$N"
+	append "$var" "wpa=$wpa" "$N"
+	[ -n "$crypto" ] && append "$var" "wpa_pairwise=$crypto" "$N"
+	[ -n "$wpa_group_rekey" ] && append "$var" "wpa_group_rekey=$wpa_group_rekey" "$N"
 
-	local auth_algs=$((($auth_mode_shared << 1) | $auth_mode_open))
-	append bss_conf "auth_algs=${auth_algs:-1}" "$N"
-	append bss_conf "wpa=$wpa" "$N"
-	[ -n "$wpa_pairwise" ] && append bss_conf "wpa_pairwise=$wpa_pairwise" "$N"
+	config_get ssid "$vif" ssid
+	config_get bridge "$vif" bridge
+	config_get ieee80211d "$vif" ieee80211d
+	config_get iapp_interface "$vif" iapp_interface
 
-	set_default wps_pushbutton 0
-	set_default wps_label 0
-	set_default wps_pbc_in_m1 0
+	config_get_bool wps_pbc "$vif" wps_pushbutton 0
+	config_get_bool wps_label "$vif" wps_label 0
 
-	config_methods=
-	[ "$wps_pushbutton" -gt 0 ] && append config_methods push_button
-	[ "$wps_label" -gt 0 ] && append config_methods label
+	config_get config_methods "$vif" wps_config
+	[ "$wps_pbc" -gt 0 ] && append config_methods push_button
 
 	[ -n "$wps_possible" -a -n "$config_methods" ] && {
-		set_default ext_registrar 0
-		set_default wps_device_type "6-0050F204-1"
-		set_default wps_device_name "Lede AP"
-		set_default wps_manufacturer "www.lede-project.org"
-		set_default wps_independent 1
-
-		wps_state=2
-		[ -n "$wps_configured" ] && wps_state=1
-
-		[ "$ext_registrar" -gt 0 -a -n "$network_bridge" ] && append bss_conf "upnp_iface=$network_bridge" "$N"
-
-		append bss_conf "eap_server=1" "$N"
-		[ -n "$wps_pin" ] && append bss_conf "ap_pin=$wps_pin" "$N"
-		append bss_conf "wps_state=$wps_state" "$N"
-		append bss_conf "device_type=$wps_device_type" "$N"
-		append bss_conf "device_name=$wps_device_name" "$N"
-		append bss_conf "manufacturer=$wps_manufacturer" "$N"
-		append bss_conf "config_methods=$config_methods" "$N"
-		append bss_conf "wps_independent=$wps_independent" "$N"
-		[ -n "$wps_ap_setup_locked" ] && append bss_conf "ap_setup_locked=$wps_ap_setup_locked" "$N"
-		[ "$wps_pbc_in_m1" -gt 0 ] && append bss_conf "pbc_in_m1=$wps_pbc_in_m1" "$N"
+		config_get device_type "$vif" wps_device_type "6-0050F204-1"
+		config_get device_name "$vif" wps_device_name "OpenWrt AP"
+		config_get manufacturer "$vif" wps_manufacturer "openwrt.org"
+		config_get wps_pin "$vif" wps_pin
+
+		config_get_bool ext_registrar "$vif" ext_registrar 0
+		[ "$ext_registrar" -gt 0 -a -n "$bridge" ] && append "$var" "upnp_iface=$bridge" "$N"
+
+		append "$var" "eap_server=1" "$N"
+		[ -n "$wps_pin" ] && append "$var" "ap_pin=$wps_pin" "$N"
+		append "$var" "wps_state=${wps_not_configured:-2}" "$N"
+		append "$var" "ap_setup_locked=0" "$N"
+		append "$var" "device_type=$device_type" "$N"
+		append "$var" "device_name=$device_name" "$N"
+		append "$var" "manufacturer=$manufacturer" "$N"
+		append "$var" "config_methods=$config_methods" "$N"
 	}
 
-	append bss_conf "ssid=$ssid" "$N"
-	[ -n "$network_bridge" ] && append bss_conf "bridge=$network_bridge" "$N"
-	[ -n "$iapp_interface" ] && {
-		local ifname
-		network_get_device ifname "$iapp_interface" || ifname="$iapp_interface"
-		append bss_conf "iapp_interface=$ifname" "$N"
-	}
-
-	if [ "$wpa" -ge "1" ]; then
-		json_get_vars ieee80211r
-		set_default ieee80211r 0
-
-		if [ "$ieee80211r" -gt "0" ]; then
-			json_get_vars mobility_domain r0_key_lifetime r1_key_holder \
-			reassociation_deadline pmk_r1_push
-			json_get_values r0kh r0kh
-			json_get_values r1kh r1kh
-
-			set_default mobility_domain "4f57"
-			set_default r0_key_lifetime 10000
-			set_default r1_key_holder "00004f577274"
-			set_default reassociation_deadline 1000
-			set_default pmk_r1_push 0
-
-			append bss_conf "mobility_domain=$mobility_domain" "$N"
-			append bss_conf "r0_key_lifetime=$r0_key_lifetime" "$N"
-			append bss_conf "r1_key_holder=$r1_key_holder" "$N"
-			append bss_conf "reassociation_deadline=$reassociation_deadline" "$N"
-			append bss_conf "pmk_r1_push=$pmk_r1_push" "$N"
+	append "$var" "ssid=$ssid" "$N"
+	[ -n "$bridge" ] && append "$var" "bridge=$bridge" "$N"
+	[ -n "$ieee80211d" ] && append "$var" "ieee80211d=$ieee80211d" "$N"
+	[ -n "$iapp_interface" ] && append "$var" iapp_interface=$(uci_get_state network "$iapp_interface" ifname "$iapp_interface") "$N"
+
+	if [ "$wpa" -ge "1" ]
+	then
+		config_get nasid "$vif" nasid
+		[ -n "$nasid" ] && append "$var" "nas_identifier=$nasid" "$N"
+
+		config_get_bool ieee80211r "$vif" ieee80211r 0
+		if [ "$ieee80211r" -gt 0 ]
+		then
+			config_get mobility_domain "$vif" mobility_domain "4f57"
+			config_get r0_key_lifetime "$vif" r0_key_lifetime "10000"
+			config_get r1_key_holder "$vif" r1_key_holder "00004f577274"
+			config_get reassociation_deadline "$vif" reassociation_deadline "1000"
+			config_get r0kh "$vif" r0kh
+			config_get r1kh "$vif" r1kh
+			config_get_bool pmk_r1_push "$vif" pmk_r1_push 0
+
+			append "$var" "mobility_domain=$mobility_domain" "$N"
+			append "$var" "r0_key_lifetime=$r0_key_lifetime" "$N"
+			append "$var" "r1_key_holder=$r1_key_holder" "$N"
+			append "$var" "reassociation_deadline=$reassociation_deadline" "$N"
+			append "$var" "pmk_r1_push=$pmk_r1_push" "$N"
 
 			for kh in $r0kh; do
-				append bss_conf "r0kh=${kh//,/ }" "$N"
+				"$var" "r0kh=${kh//,/ }" "$N"
 			done
 			for kh in $r1kh; do
-				append bss_conf "r1kh=${kh//,/ }" "$N"
+				"$var" "r1kh=${kh//,/ }" "$N"
 			done
-		fi
 
-		append bss_conf "wpa_disable_eapol_key_retries=$wpa_disable_eapol_key_retries" "$N"
+			[ "$wpa_key_mgmt" != "${wpa_key_mgmt/EAP/}" ] && append wpa_key_mgmt "FT-EAP"
+			[ "$wpa_key_mgmt" != "${wpa_key_mgmt/PSK/}" ] && append wpa_key_mgmt "FT-PSK"
+		fi
 
-		hostapd_append_wpa_key_mgmt
-		[ -n "$wpa_key_mgmt" ] && append bss_conf "wpa_key_mgmt=$wpa_key_mgmt" "$N"
+		[ -n "wpa_key_mgmt" ] && append "$var" "wpa_key_mgmt=$wpa_key_mgmt"
 	fi
 
-	if [ "$wpa" -ge "2" ]; then
-		if [ -n "$network_bridge" -a "$rsn_preauth" = 1 ]; then
-			set_default auth_cache 1
-			append bss_conf "rsn_preauth=1" "$N"
-			append bss_conf "rsn_preauth_interfaces=$network_bridge" "$N"
+	if [ "$wpa" -ge "2" ]
+	then
+		# RSN -> allow preauthentication. You have two
+		# options, rsn_preauth for production or rsn_preauth_testing
+		# for validation / testing.
+		if [ -n "$bridge" -a "$rsn_preauth" = 1 ]
+		then
+			append "$var" "rsn_preauth=1" "$N"
+			append "$var" "rsn_preauth_interfaces=$bridge" "$N"
+			append "$var" "okc=1" "$N"
 		else
-			set_default auth_cache 0
+			# RSN preauthentication testings hould disable
+			# Opportunistic Key Caching (okc) as otherwise the PMKSA
+			# entry for a test could come from the Opportunistic Key Caching
+			config_get rsn_preauth_testing "$vif" rsn_preauth_testing
+			if [ -n "$bridge" -a "$rsn_preauth_testing" = 1 ]
+			then
+				append "$var" "rsn_preauth=1" "$N"
+				append "$var" "rsn_preauth_interfaces=$bridge" "$N"
+				append "$var" "okc=0" "$N"
+			fi
 		fi
 
-		append bss_conf "okc=$auth_cache" "$N"
-		[ "$auth_cache" = 0 ] && append bss_conf "disable_pmksa_caching=1" "$N"
-
 		# RSN -> allow management frame protection
+		config_get ieee80211w "$vif" ieee80211w
 		case "$ieee80211w" in
 			[012])
-				json_get_vars ieee80211w_max_timeout ieee80211w_retry_timeout
-				append bss_conf "ieee80211w=$ieee80211w" "$N"
+				append "$var" "ieee80211w=$ieee80211w" "$N"
 				[ "$ieee80211w" -gt "0" ] && {
+					config_get ieee80211w_max_timeout "$vif" ieee80211w_max_timeout
+					config_get ieee80211w_retry_timeout "$vif" ieee80211w_retry_timeout
 					[ -n "$ieee80211w_max_timeout" ] && \
-						append bss_conf "assoc_sa_query_max_timeout=$ieee80211w_max_timeout" "$N"
+						append "$var" "assoc_sa_query_max_timeout=$ieee80211w_max_timeout" "$N"
 					[ -n "$ieee80211w_retry_timeout" ] && \
-						append bss_conf "assoc_sa_query_retry_timeout=$ieee80211w_retry_timeout" "$N"
+						append "$var" "assoc_sa_query_retry_timeout=$ieee80211w_retry_timeout" "$N"
 				}
 			;;
 		esac
 	fi
 
-	_macfile="/var/run/hostapd-$ifname.maclist"
+	config_get macfile "$vif" macfile
+	config_get maclist "$vif" maclist
+	if [ -z "$macfile" ]
+	then
+		# if no macfile has been specified, fallback to the default name
+		# and truncate file to avoid aggregating entries over time
+		macfile="/var/run/hostapd-$ifname.maclist"
+		echo "" > "$macfile"
+	else
+		if [ -n "$maclist" ]
+		then
+			# to avoid to overwrite the original file, make a copy
+			# before appending the entries specified by the maclist
+			# option
+			cp $macfile $macfile.maclist
+			macfile=$macfile.maclist
+		fi
+	fi
+
+	if [ -n "$maclist" ]
+	then
+		for mac in $maclist; do
+			echo "$mac" >> $macfile
+		done
+	fi
+
+	config_get macfilter "$vif" macfilter
 	case "$macfilter" in
 		allow)
-			append bss_conf "macaddr_acl=1" "$N"
-			append bss_conf "accept_mac_file=$_macfile" "$N"
-			# accept_mac_file can be used to set MAC to VLAN ID mapping
-			vlan_possible=1
-		;;
+			append "$var" "macaddr_acl=1" "$N"
+			append "$var" "accept_mac_file=$macfile" "$N"
+			;;
 		deny)
-			append bss_conf "macaddr_acl=0" "$N"
-			append bss_conf "deny_mac_file=$_macfile" "$N"
-		;;
-		*)
-			_macfile=""
-		;;
+			append "$var" "macaddr_acl=0" "$N"
+			append "$var" "deny_mac_file=$macfile" "$N"
+			;;
 	esac
-
-	[ -n "$_macfile" ] && {
-		json_get_vars macfile
-		json_get_values maclist maclist
-
-		rm -f "$_macfile"
-		(
-			for mac in $maclist; do
-				echo "$mac"
-			done
-			[ -n "$macfile" -a -f "$macfile" ] && cat "$macfile"
-		) > "$_macfile"
-	}
-
-	[ -n "$vlan_possible" -a -n "$dynamic_vlan" ] && {
-		json_get_vars vlan_naming vlan_tagged_interface vlan_bridge vlan_file
-		set_default vlan_naming 1
-		append bss_conf "dynamic_vlan=$dynamic_vlan" "$N"
-		append bss_conf "vlan_naming=$vlan_naming" "$N"
-		[ -n "$vlan_bridge" ] && \
-			append bss_conf "vlan_bridge=$vlan_bridge" "$N"
-		[ -n "$vlan_tagged_interface" ] && \
-			append bss_conf "vlan_tagged_interface=$vlan_tagged_interface" "$N"
-		[ -n "$vlan_file" ] && {
-			[ -e "$vlan_file" ] || touch "$vlan_file"
-			append bss_conf "vlan_file=$vlan_file" "$N"
-		}
-	}
-
-	append "$var" "$bss_conf" "$N"
-	return 0
 }
 
 hostapd_set_log_options() {
 	local var="$1"
-
+	local cfg="$2"
 	local log_level log_80211 log_8021x log_radius log_wpa log_driver log_iapp log_mlme
-	json_get_vars log_level log_80211 log_8021x log_radius log_wpa log_driver log_iapp log_mlme
-
-	set_default log_level 2
-	set_default log_80211  1
-	set_default log_8021x  1
-	set_default log_radius 1
-	set_default log_wpa    1
-	set_default log_driver 1
-	set_default log_iapp   1
-	set_default log_mlme   1
-
-	local log_mask=$(( \
+
+	config_get log_level "$cfg" log_level 2
+
+	config_get_bool log_80211  "$cfg" log_80211  1
+	config_get_bool log_8021x  "$cfg" log_8021x  1
+	config_get_bool log_radius "$cfg" log_radius 1
+	config_get_bool log_wpa    "$cfg" log_wpa    1
+	config_get_bool log_driver "$cfg" log_driver 1
+	config_get_bool log_iapp   "$cfg" log_iapp   1
+	config_get_bool log_mlme   "$cfg" log_mlme   1
+
+	local log_mask=$((       \
 		($log_80211  << 0) | \
 		($log_8021x  << 1) | \
 		($log_radius << 2) | \
@@ -521,264 +359,36 @@ hostapd_set_log_options() {
 	append "$var" "logger_syslog_level=$log_level" "$N"
 	append "$var" "logger_stdout=$log_mask" "$N"
 	append "$var" "logger_stdout_level=$log_level" "$N"
-
-	return 0
-}
-
-_wpa_supplicant_common() {
-	local ifname="$1"
-
-	_rpath="/var/run/wpa_supplicant"
-	_config="${_rpath}-$ifname.conf"
-}
-
-wpa_supplicant_teardown_interface() {
-	_wpa_supplicant_common "$1"
-	rm -rf "$_rpath/$1" "$_config"
-}
-
-wpa_supplicant_prepare_interface() {
-	local ifname="$1"
-	_w_driver="$2"
-
-	_wpa_supplicant_common "$1"
-
-	json_get_vars mode wds
-
-	[ -n "$network_bridge" ] && {
-		fail=
-		case "$mode" in
-			adhoc)
-				fail=1
-			;;
-			sta)
-				[ "$wds" = 1 ] || fail=1
-			;;
-		esac
-
-		[ -n "$fail" ] && {
-			wireless_setup_vif_failed BRIDGE_NOT_ALLOWED
-			return 1
-		}
-	}
-
-	local ap_scan=
-
-	_w_mode="$mode"
-	_w_modestr=
-
-	[[ "$mode" = adhoc ]] && {
-		ap_scan="ap_scan=2"
-
-		_w_modestr="mode=1"
-	}
-
-	local country_str=
-	[ -n "$country" ] && {
-		country_str="country=$country"
-	}
-
-	wpa_supplicant_teardown_interface "$ifname"
-	cat > "$_config" <<EOF
-$ap_scan
-$country_str
-EOF
-	return 0
 }
 
-wpa_supplicant_add_network() {
-	local ifname="$1"
-
-	_wpa_supplicant_common "$1"
-	wireless_vif_parse_encryption
-
-	json_get_vars \
-		ssid bssid key \
-		basic_rate mcast_rate \
-		ieee80211w ieee80211r
-
-	set_default ieee80211r 0
-
-	local key_mgmt='NONE'
-	local enc_str=
-	local network_data=
-	local T="	"
-
-	local scan_ssid="scan_ssid=1"
-	local freq wpa_key_mgmt
-
-	[[ "$_w_mode" = "adhoc" ]] && {
-		append network_data "mode=1" "$N$T"
-		[ -n "$channel" ] && {
-			freq="$(get_freq "$phy" "$channel")"
-			append network_data "fixed_freq=1" "$N$T"
-			append network_data "frequency=$freq" "$N$T"
-		}
-
-		scan_ssid="scan_ssid=0"
-
-		[ "$_w_driver" = "nl80211" ] ||	append wpa_key_mgmt "WPA-NONE"
-	}
+hostapd_setup_vif() {
+	local vif="$1"
+	local driver="$2"
+	local ifname device channel hwmode
 
-	[[ "$_w_mode" = "mesh" ]] && {
-		json_get_vars mesh_id
-		ssid="${mesh_id}"
-
-		append network_data "mode=5" "$N$T"
-		[ -n "$channel" ] && {
-			freq="$(get_freq "$phy" "$channel")"
-			append network_data "frequency=$freq" "$N$T"
-		}
-		append wpa_key_mgmt "SAE"
-		scan_ssid=""
-	}
+	hostapd_cfg=
 
-	[ "$_w_mode" = "adhoc" -o "$_w_mode" = "mesh" ] && append network_data "$_w_modestr" "$N$T"
+	config_get ifname "$vif" ifname
+	config_get device "$vif" device
+	config_get channel "$device" channel
+	config_get hwmode "$device" hwmode
 
-	case "$auth_type" in
-		none) ;;
-		wep)
-			local wep_keyidx=0
-			hostapd_append_wep_key network_data
-			append network_data "wep_tx_keyidx=$wep_keyidx" "$N$T"
-		;;
-		psk)
-			local passphrase
+	hostapd_set_log_options hostapd_cfg "$device"
+	hostapd_set_bss_options hostapd_cfg "$vif"
 
-			if [ "$_w_mode" != "mesh" ]; then
-				hostapd_append_wpa_key_mgmt
-			fi
-
-			key_mgmt="$wpa_key_mgmt"
-
-			if [ ${#key} -eq 64 ]; then
-				passphrase="psk=${key}"
-			else
-				passphrase="psk=\"${key}\""
-			fi
-			append network_data "$passphrase" "$N$T"
-		;;
-		eap)
-			hostapd_append_wpa_key_mgmt
-			key_mgmt="$wpa_key_mgmt"
-
-			json_get_vars eap_type identity anonymous_identity ca_cert
-			[ -n "$ca_cert" ] && append network_data "ca_cert=\"$ca_cert\"" "$N$T"
-			[ -n "$identity" ] && append network_data "identity=\"$identity\"" "$N$T"
-			[ -n "$anonymous_identity" ] && append network_data "anonymous_identity=\"$anonymous_identity\"" "$N$T"
-			case "$eap_type" in
-				tls)
-					json_get_vars client_cert priv_key priv_key_pwd
-					append network_data "client_cert=\"$client_cert\"" "$N$T"
-					append network_data "private_key=\"$priv_key\"" "$N$T"
-					append network_data "private_key_passwd=\"$priv_key_pwd\"" "$N$T"
-				;;
-				fast|peap|ttls)
-					json_get_vars auth password ca_cert2 client_cert2 priv_key2 priv_key2_pwd
-					set_default auth MSCHAPV2
-
-					if [ "$auth" = "EAP-TLS" ]; then
-						[ -n "$ca_cert2" ] &&
-							append network_data "ca_cert2=\"$ca_cert2\"" "$N$T"
-						append network_data "client_cert2=\"$client_cert2\"" "$N$T"
-						append network_data "private_key2=\"$priv_key2\"" "$N$T"
-						append network_data "private_key2_passwd=\"$priv_key2_pwd\"" "$N$T"
-					else
-						append network_data "password=\"$password\"" "$N$T"
-					fi
-
-					phase2proto="auth="
-					case "$auth" in
-						"auth"*)
-							phase2proto=""
-						;;
-						"EAP-"*)
-							auth="$(echo $auth | cut -b 5- )"
-							[ "$eap_type" = "ttls" ] &&
-								phase2proto="autheap="
-						;;
-					esac
-					append network_data "phase2=\"$phase2proto$auth\"" "$N$T"
-				;;
-			esac
-			append network_data "eap=$(echo $eap_type | tr 'a-z' 'A-Z')" "$N$T"
-		;;
+	case "$hwmode" in
+		*bg|*gdt|*gst|*fh) hwmode=g;;
+		*adt|*ast) hwmode=a;;
 	esac
-
-	[ "$mode" = mesh ] || {
-		case "$wpa" in
-			1)
-				append network_data "proto=WPA" "$N$T"
-			;;
-			2)
-				append network_data "proto=RSN" "$N$T"
-			;;
-		esac
-
-		case "$ieee80211w" in
-			[012])
-				[ "$wpa" -ge 2 ] && append network_data "ieee80211w=$ieee80211w" "$N$T"
-			;;
-		esac
-	}
-	local beacon_int brates mrate
-	[ -n "$bssid" ] && append network_data "bssid=$bssid" "$N$T"
-	[ -n "$beacon_int" ] && append network_data "beacon_int=$beacon_int" "$N$T"
-
-	local bssid_blacklist bssid_whitelist
-	json_get_values bssid_blacklist bssid_blacklist
-	json_get_values bssid_whitelist bssid_whitelist
-
-	[ -n "$bssid_blacklist" ] && append network_data "bssid_blacklist=$bssid_blacklist" "$N$T"
-	[ -n "$bssid_whitelist" ] && append network_data "bssid_whitelist=$bssid_whitelist" "$N$T"
-
-	[ -n "$basic_rate" ] && {
-		local br rate_list=
-		for br in $basic_rate; do
-			wpa_supplicant_add_rate rate_list "$br"
-		done
-		[ -n "$rate_list" ] && append network_data "rates=$rate_list" "$N$T"
-	}
-
-	[ -n "$mcast_rate" ] && {
-		local mc_rate=
-		wpa_supplicant_add_rate mc_rate "$mcast_rate"
-		append network_data "mcast_rate=$mc_rate" "$N$T"
-	}
-
-	cat >> "$_config" <<EOF
-network={
-	$scan_ssid
-	ssid="$ssid"
-	key_mgmt=$key_mgmt
-	$network_data
-}
+	[ "$channel" = auto ] && channel=
+	[ -n "$channel" -a -z "$hwmode" ] && wifi_fixup_hwmode "$device"
+	cat > /var/run/hostapd-$ifname.conf <<EOF
+driver=$driver
+interface=$ifname
+${hwmode:+hw_mode=${hwmode#11}}
+${channel:+channel=$channel}
+$hostapd_cfg
 EOF
-	return 0
-}
-
-wpa_supplicant_run() {
-	local ifname="$1"; shift
-
-	_wpa_supplicant_common "$ifname"
-
-	/usr/sbin/wpa_supplicant -B \
-		${network_bridge:+-b $network_bridge} \
-		-P "/var/run/wpa_supplicant-${ifname}.pid" \
-		-D ${_w_driver:-wext} \
-		-i "$ifname" \
-		-c "$_config" \
-		-C "$_rpath" \
-		"$@"
-
-	ret="$?"
-	wireless_add_process "$(cat "/var/run/wpa_supplicant-${ifname}.pid")" /usr/sbin/wpa_supplicant 1
-
-	[ "$ret" != 0 ] && wireless_setup_vif_failed WPA_SUPPLICANT_FAILED
-
-	return $ret
+	hostapd -P /var/run/wifi-$ifname.pid -B /var/run/hostapd-$ifname.conf
 }
 
-hostapd_common_cleanup() {
-	killall hostapd wpa_supplicant meshd-nl80211
-}
diff --git a/package/network/services/hostapd/files/netifd.sh b/package/network/services/hostapd/files/netifd.sh
new file mode 100644
index 0000000000000000000000000000000000000000..a98f2b31f0cb96bdfdc41902aabfb3cf19541407
--- /dev/null
+++ b/package/network/services/hostapd/files/netifd.sh
@@ -0,0 +1,705 @@
+wpa_supplicant_add_rate() {
+	local var="$1"
+	local val="$(($2 / 1000))"
+	local sub="$((($2 / 100) % 10))"
+	append $var "$val" ","
+	[ $sub -gt 0 ] && append $var "."
+}
+
+hostapd_add_rate() {
+	local var="$1"
+	local val="$(($2 / 100))"
+	append $var "$val" " "
+}
+
+hostapd_append_wep_key() {
+	local var="$1"
+
+	wep_keyidx=0
+	set_default key 1
+	case "$key" in
+		[1234])
+			for idx in 1 2 3 4; do
+				local zidx
+				zidx=$(($idx - 1))
+				json_get_var ckey "key${idx}"
+				[ -n "$ckey" ] && \
+					append $var "wep_key${zidx}=$(prepare_key_wep "$ckey")" "$N$T"
+			done
+			wep_keyidx=$((key - 1))
+		;;
+		*)
+			append $var "wep_key0=$(prepare_key_wep "$key")" "$N$T"
+		;;
+	esac
+}
+
+hostapd_add_log_config() {
+	config_add_boolean \
+		log_80211 \
+		log_8021x \
+		log_radius \
+		log_wpa \
+		log_driver \
+		log_iapp \
+		log_mlme
+
+	config_add_int log_level
+}
+
+hostapd_common_add_device_config() {
+	config_add_array basic_rate
+	config_add_array supported_rates
+
+	config_add_string country
+	config_add_boolean country_ie doth
+	config_add_string require_mode
+
+	hostapd_add_log_config
+}
+
+hostapd_prepare_device_config() {
+	local config="$1"
+	local driver="$2"
+
+	local base="${config%%.conf}"
+	local base_cfg=
+
+	json_get_vars country country_ie beacon_int:100 doth require_mode
+
+	hostapd_set_log_options base_cfg
+
+	set_default country_ie 1
+	set_default doth 1
+
+	[ -n "$country" ] && {
+		append base_cfg "country_code=$country" "$N"
+
+		[ "$country_ie" -gt 0 ] && append base_cfg "ieee80211d=1" "$N"
+		[ "$hwmode" = "a" -a "$doth" -gt 0 ] && append base_cfg "ieee80211h=1" "$N"
+	}
+	[ -n "$hwmode" ] && append base_cfg "hw_mode=$hwmode" "$N"
+
+	local brlist= br
+	json_get_values basic_rate_list basic_rate
+	for br in $basic_rate_list; do
+		hostapd_add_rate brlist "$br"
+	done
+	case "$require_mode" in
+		g) brlist="60 120 240" ;;
+		n) append base_cfg "require_ht=1" "$N";;
+		ac) append base_cfg "require_vht=1" "$N";;
+	esac
+
+	local rlist= r
+	json_get_values rate_list supported_rates
+	for r in $rate_list; do
+		hostapd_add_rate rlist "$r"
+	done
+
+	[ -n "$rlist" ] && append base_cfg "supported_rates=$rlist" "$N"
+	[ -n "$brlist" ] && append base_cfg "basic_rates=$brlist" "$N"
+	append base_cfg "beacon_int=$beacon_int" "$N"
+
+	cat > "$config" <<EOF
+driver=$driver
+$base_cfg
+EOF
+}
+
+hostapd_common_add_bss_config() {
+	config_add_string 'bssid:macaddr' 'ssid:string'
+	config_add_boolean wds wmm uapsd hidden
+
+	config_add_int maxassoc max_inactivity
+	config_add_boolean disassoc_low_ack isolate short_preamble
+
+	config_add_int \
+		wep_rekey eap_reauth_period \
+		wpa_group_rekey wpa_pair_rekey wpa_master_rekey
+
+	config_add_boolean rsn_preauth auth_cache
+	config_add_int ieee80211w
+	config_add_int eapol_version
+
+	config_add_string 'auth_server:host' 'server:host'
+	config_add_string auth_secret
+	config_add_int 'auth_port:port' 'port:port'
+
+	config_add_string acct_server
+	config_add_string acct_secret
+	config_add_int acct_port
+
+	config_add_string dae_client
+	config_add_string dae_secret
+	config_add_int dae_port
+
+	config_add_string nasid
+	config_add_string ownip
+	config_add_string iapp_interface
+	config_add_string eap_type ca_cert client_cert identity auth priv_key priv_key_pwd
+
+	config_add_int dynamic_vlan vlan_naming
+	config_add_string vlan_tagged_interface vlan_bridge
+
+	config_add_string 'key1:wepkey' 'key2:wepkey' 'key3:wepkey' 'key4:wepkey' 'password:wpakey'
+
+	config_add_string wpa_psk_file
+
+	config_add_boolean wps_pushbutton wps_label ext_registrar wps_pbc_in_m1
+	config_add_string wps_device_type wps_device_name wps_manufacturer wps_pin
+
+	config_add_boolean ieee80211r pmk_r1_push
+	config_add_int r0_key_lifetime reassociation_deadline
+	config_add_string mobility_domain r1_key_holder
+	config_add_array r0kh r1kh
+
+	config_add_int ieee80211w_max_timeout ieee80211w_retry_timeout
+
+	config_add_string macfilter 'macfile:file'
+	config_add_array 'maclist:list(macaddr)'
+
+	config_add_array bssid_blacklist
+	config_add_array bssid_whitelist
+
+	config_add_int mcast_rate
+	config_add_array basic_rate
+	config_add_array supported_rates
+}
+
+hostapd_set_bss_options() {
+	local var="$1"
+	local phy="$2"
+	local vif="$3"
+
+	wireless_vif_parse_encryption
+
+	local bss_conf
+	local wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey wpa_key_mgmt
+
+	json_get_vars \
+		wep_rekey wpa_group_rekey wpa_pair_rekey wpa_master_rekey \
+		maxassoc max_inactivity disassoc_low_ack isolate auth_cache \
+		wps_pushbutton wps_label ext_registrar wps_pbc_in_m1 \
+		wps_device_type wps_device_name wps_manufacturer wps_pin \
+		macfilter ssid wmm uapsd hidden short_preamble rsn_preauth \
+		iapp_interface eapol_version
+
+	set_default isolate 0
+	set_default maxassoc 0
+	set_default max_inactivity 0
+	set_default short_preamble 1
+	set_default disassoc_low_ack 1
+	set_default hidden 0
+	set_default wmm 1
+	set_default uapsd 1
+	set_default eapol_version 0
+
+	append bss_conf "ctrl_interface=/var/run/hostapd"
+	if [ "$isolate" -gt 0 ]; then
+		append bss_conf "ap_isolate=$isolate" "$N"
+	fi
+	if [ "$maxassoc" -gt 0 ]; then
+		append bss_conf "max_num_sta=$maxassoc" "$N"
+	fi
+	if [ "$max_inactivity" -gt 0 ]; then
+		append bss_conf "ap_max_inactivity=$max_inactivity" "$N"
+	fi
+
+	append bss_conf "disassoc_low_ack=$disassoc_low_ack" "$N"
+	append bss_conf "preamble=$short_preamble" "$N"
+	append bss_conf "wmm_enabled=$wmm" "$N"
+	append bss_conf "ignore_broadcast_ssid=$hidden" "$N"
+	append bss_conf "uapsd_advertisement_enabled=$uapsd" "$N"
+
+	[ "$wpa" -gt 0 ] && {
+		[ -n "$wpa_group_rekey"  ] && append bss_conf "wpa_group_rekey=$wpa_group_rekey" "$N"
+		[ -n "$wpa_pair_rekey"   ] && append bss_conf "wpa_ptk_rekey=$wpa_pair_rekey"    "$N"
+		[ -n "$wpa_master_rekey" ] && append bss_conf "wpa_gmk_rekey=$wpa_master_rekey"  "$N"
+	}
+
+	case "$auth_type" in
+		none)
+			wps_possible=1
+			# Here we make the assumption that if we're in open mode
+			# with WPS enabled, we got to be in unconfigured state.
+			wps_not_configured=1
+		;;
+		psk)
+			json_get_vars key wpa_psk_file
+			if [ ${#key} -lt 8 ]; then
+				wireless_setup_vif_failed INVALID_WPA_PSK
+				return 1
+			elif [ ${#key} -eq 64 ]; then
+				append bss_conf "wpa_psk=$key" "$N"
+			else
+				append bss_conf "wpa_passphrase=$key" "$N"
+			fi
+			[ -n "$wpa_psk_file" ] && {
+				[ -e "$wpa_psk_file" ] || touch "$wpa_psk_file"
+				append bss_conf "wpa_psk_file=$wpa_psk_file" "$N"
+			}
+			[ "$eapol_version" -ge "1" -a "$eapol_version" -le "2" ] && append bss_conf "eapol_version=$eapol_version" "$N"
+
+			wps_possible=1
+			append wpa_key_mgmt "WPA-PSK"
+		;;
+		eap)
+			json_get_vars \
+				auth_server auth_secret auth_port \
+				acct_server acct_secret acct_port \
+				dae_client dae_secret dae_port \
+				ownip \
+				eap_reauth_period dynamic_vlan \
+				vlan_naming vlan_tagged_interface \
+				vlan_bridge
+
+			# legacy compatibility
+			[ -n "$auth_server" ] || json_get_var auth_server server
+			[ -n "$auth_port" ] || json_get_var auth_port port
+			[ -n "$auth_secret" ] || json_get_var auth_secret key
+
+			set_default auth_port 1812
+			set_default acct_port 1813
+			set_default dae_port 3799
+
+			set_default vlan_naming 1
+
+			append bss_conf "auth_server_addr=$auth_server" "$N"
+			append bss_conf "auth_server_port=$auth_port" "$N"
+			append bss_conf "auth_server_shared_secret=$auth_secret" "$N"
+
+			[ -n "$acct_server" ] && {
+				append bss_conf "acct_server_addr=$acct_server" "$N"
+				append bss_conf "acct_server_port=$acct_port" "$N"
+				[ -n "$acct_secret" ] && \
+					append bss_conf "acct_server_shared_secret=$acct_secret" "$N"
+			}
+
+			[ -n "$eap_reauth_period" ] && append bss_conf "eap_reauth_period=$eap_reauth_period" "$N"
+
+			[ -n "$dae_client" -a -n "$dae_secret" ] && {
+				append bss_conf "radius_das_port=$dae_port" "$N"
+				append bss_conf "radius_das_client=$dae_client $dae_secret" "$N"
+			}
+
+			[ -n "$ownip" ] && append bss_conf "own_ip_addr=$ownip" "$N"
+			append bss_conf "eapol_key_index_workaround=1" "$N"
+			append bss_conf "ieee8021x=1" "$N"
+			append wpa_key_mgmt "WPA-EAP"
+
+			[ -n "$dynamic_vlan" ] && {
+				append bss_conf "dynamic_vlan=$dynamic_vlan" "$N"
+				append bss_conf "vlan_naming=$vlan_naming" "$N"
+				[ -n "$vlan_bridge" ] && \
+					append bss_conf "vlan_bridge=$vlan_bridge" "$N"
+				[ -n "$vlan_tagged_interface" ] && \
+					append bss_conf "vlan_tagged_interface=$vlan_tagged_interface" "$N"
+			}
+
+			[ "$eapol_version" -ge "1" -a "$eapol_version" -le "2" ] && append bss_conf "eapol_version=$eapol_version" "$N"
+		;;
+		wep)
+			local wep_keyidx=0
+			json_get_vars key
+			hostapd_append_wep_key bss_conf
+			append bss_conf "wep_default_key=$wep_keyidx" "$N"
+			[ -n "$wep_rekey" ] && append bss_conf "wep_rekey_period=$wep_rekey" "$N"
+		;;
+	esac
+
+	local auth_algs=$((($auth_mode_shared << 1) | $auth_mode_open))
+	append bss_conf "auth_algs=${auth_algs:-1}" "$N"
+	append bss_conf "wpa=$wpa" "$N"
+	[ -n "$wpa_pairwise" ] && append bss_conf "wpa_pairwise=$wpa_pairwise" "$N"
+
+	set_default wps_pushbutton 0
+	set_default wps_label 0
+	set_default wps_pbc_in_m1 0
+
+	config_methods=
+	[ "$wps_pushbutton" -gt 0 ] && append config_methods push_button
+	[ "$wps_label" -gt 0 ] && append config_methods label
+
+	[ -n "$wps_possible" -a -n "$config_methods" ] && {
+		set_default ext_registrar 0
+		set_default wps_device_type "6-0050F204-1"
+		set_default wps_device_name "OpenWrt AP"
+		set_default wps_manufacturer "openwrt.org"
+
+		wps_state=2
+		[ -n "$wps_configured" ] && wps_state=1
+
+		[ "$ext_registrar" -gt 0 -a -n "$network_bridge" ] && append bss_conf "upnp_iface=$network_bridge" "$N"
+
+		append bss_conf "eap_server=1" "$N"
+		[ -n "$wps_pin" ] && append bss_conf "ap_pin=$wps_pin" "$N"
+		append bss_conf "wps_state=$wps_state" "$N"
+		append bss_conf "ap_setup_locked=0" "$N"
+		append bss_conf "device_type=$wps_device_type" "$N"
+		append bss_conf "device_name=$wps_device_name" "$N"
+		append bss_conf "manufacturer=$wps_manufacturer" "$N"
+		append bss_conf "config_methods=$config_methods" "$N"
+		[ "$wps_pbc_in_m1" -gt 0 ] && append bss_conf "pbc_in_m1=$wps_pbc_in_m1" "$N"
+	}
+
+	append bss_conf "ssid=$ssid" "$N"
+	[ -n "$network_bridge" ] && append bss_conf "bridge=$network_bridge" "$N"
+	[ -n "$iapp_interface" ] && {
+		iapp_interface="$(uci_get_state network "$iapp_interface" ifname "$iapp_interface")"
+		[ -n "$iapp_interface" ] && append bss_conf "iapp_interface=$iapp_interface" "$N"
+	}
+
+	if [ "$wpa" -ge "1" ]; then
+		json_get_vars nasid ieee80211r
+		set_default ieee80211r 0
+		[ -n "$nasid" ] && append bss_conf "nas_identifier=$nasid" "$N"
+
+		if [ "$ieee80211r" -gt "0" ]; then
+			json_get_vars mobility_domain r0_key_lifetime r1_key_holder \
+			reassociation_deadline pmk_r1_push
+			json_get_values r0kh r0kh
+			json_get_values r1kh r1kh
+
+			set_default mobility_domain "4f57"
+			set_default r0_key_lifetime 10000
+			set_default r1_key_holder "00004f577274"
+			set_default reassociation_deadline 1000
+			set_default pmk_r1_push 0
+
+			append bss_conf "mobility_domain=$mobility_domain" "$N"
+			append bss_conf "r0_key_lifetime=$r0_key_lifetime" "$N"
+			append bss_conf "r1_key_holder=$r1_key_holder" "$N"
+			append bss_conf "reassociation_deadline=$reassociation_deadline" "$N"
+			append bss_conf "pmk_r1_push=$pmk_r1_push" "$N"
+
+			for kh in $r0kh; do
+				append bss_conf "r0kh=${kh//,/ }" "$N"
+			done
+			for kh in $r1kh; do
+				append bss_conf "r1kh=${kh//,/ }" "$N"
+			done
+
+			[ "$wpa_key_mgmt" != "${wpa_key_mgmt/EAP/}" ] && append wpa_key_mgmt "FT-EAP"
+			[ "$wpa_key_mgmt" != "${wpa_key_mgmt/PSK/}" ] && append wpa_key_mgmt "FT-PSK"
+		fi
+
+		[ -n "$wpa_key_mgmt" ] && append bss_conf "wpa_key_mgmt=$wpa_key_mgmt" "$N"
+	fi
+
+	if [ "$wpa" -ge "2" ]; then
+		if [ -n "$network_bridge" -a "$rsn_preauth" = 1 ]; then
+			set_default auth_cache 1
+			append bss_conf "rsn_preauth=1" "$N"
+			append bss_conf "rsn_preauth_interfaces=$network_bridge" "$N"
+		else
+			set_default auth_cache 0
+		fi
+
+		append bss_conf "okc=$auth_cache" "$N"
+		[ "$auth_cache" = 0 ] && append bss_conf "disable_pmksa_caching=1" "$N"
+
+		# RSN -> allow management frame protection
+		json_get_var ieee80211w ieee80211w
+		case "$ieee80211w" in
+			[012])
+				json_get_vars ieee80211w_max_timeout ieee80211w_retry_timeout
+				append bss_conf "ieee80211w=$ieee80211w" "$N"
+				[ "$ieee80211w" -gt "0" ] && {
+					[ -n "$ieee80211w_max_timeout" ] && \
+						append bss_conf "assoc_sa_query_max_timeout=$ieee80211w_max_timeout" "$N"
+					[ -n "$ieee80211w_retry_timeout" ] && \
+						append bss_conf "assoc_sa_query_retry_timeout=$ieee80211w_retry_timeout" "$N"
+				}
+			;;
+		esac
+	fi
+
+	_macfile="/var/run/hostapd-$ifname.maclist"
+	case "$macfilter" in
+		allow)
+			append bss_conf "macaddr_acl=1" "$N"
+			append bss_conf "accept_mac_file=$_macfile" "$N"
+		;;
+		deny)
+			append bss_conf "macaddr_acl=0" "$N"
+			append bss_conf "deny_mac_file=$_macfile" "$N"
+		;;
+		*)
+			_macfile=""
+		;;
+	esac
+
+	[ -n "$_macfile" ] && {
+		json_get_vars macfile
+		json_get_values maclist maclist
+
+		rm -f "$_macfile"
+		(
+			for mac in $maclist; do
+				echo "$mac"
+			done
+			[ -n "$macfile" -a -f "$macfile" ] && cat "$macfile"
+		) > "$_macfile"
+	}
+
+	append "$var" "$bss_conf" "$N"
+	return 0
+}
+
+hostapd_set_log_options() {
+	local var="$1"
+
+	local log_level log_80211 log_8021x log_radius log_wpa log_driver log_iapp log_mlme
+	json_get_vars log_level log_80211 log_8021x log_radius log_wpa log_driver log_iapp log_mlme
+
+	set_default log_level 2
+	set_default log_80211  1
+	set_default log_8021x  1
+	set_default log_radius 1
+	set_default log_wpa    1
+	set_default log_driver 1
+	set_default log_iapp   1
+	set_default log_mlme   1
+
+	local log_mask=$(( \
+		($log_80211  << 0) | \
+		($log_8021x  << 1) | \
+		($log_radius << 2) | \
+		($log_wpa    << 3) | \
+		($log_driver << 4) | \
+		($log_iapp   << 5) | \
+		($log_mlme   << 6)   \
+	))
+
+	append "$var" "logger_syslog=$log_mask" "$N"
+	append "$var" "logger_syslog_level=$log_level" "$N"
+	append "$var" "logger_stdout=$log_mask" "$N"
+	append "$var" "logger_stdout_level=$log_level" "$N"
+
+	return 0
+}
+
+_wpa_supplicant_common() {
+	local ifname="$1"
+
+	_rpath="/var/run/wpa_supplicant"
+	_config="${_rpath}-$ifname.conf"
+}
+
+wpa_supplicant_teardown_interface() {
+	_wpa_supplicant_common "$1"
+	rm -rf "$_rpath/$1" "$_config"
+}
+
+wpa_supplicant_prepare_interface() {
+	local ifname="$1"
+	_w_driver="$2"
+
+	_wpa_supplicant_common "$1"
+
+	json_get_vars mode wds
+
+	[ -n "$network_bridge" ] && {
+		fail=
+		case "$mode" in
+			adhoc)
+				fail=1
+			;;
+			sta)
+				[ "$wds" = 1 ] || fail=1
+			;;
+		esac
+
+		[ -n "$fail" ] && {
+			wireless_setup_vif_failed BRIDGE_NOT_ALLOWED
+			return 1
+		}
+	}
+
+	local ap_scan=
+
+	_w_mode="$mode"
+	_w_modestr=
+
+	[[ "$mode" = adhoc ]] && {
+		ap_scan="ap_scan=2"
+
+		_w_modestr="mode=1"
+	}
+
+	wpa_supplicant_teardown_interface "$ifname"
+	cat > "$_config" <<EOF
+$ap_scan
+EOF
+	return 0
+}
+
+wpa_supplicant_add_network() {
+	local ifname="$1"
+
+	_wpa_supplicant_common "$1"
+	wireless_vif_parse_encryption
+
+	json_get_vars \
+		ssid bssid key \
+		basic_rate mcast_rate \
+		ieee80211w
+
+	local key_mgmt='NONE'
+	local enc_str=
+	local network_data=
+	local T="	"
+
+	local wpa_key_mgmt="WPA-PSK"
+	local scan_ssid="scan_ssid=1"
+	local freq
+
+	[[ "$_w_mode" = "adhoc" ]] && {
+		append network_data "mode=1" "$N$T"
+		[ -n "$channel" ] && {
+			freq="$(get_freq "$phy" "$channel")"
+			append network_data "fixed_freq=1" "$N$T"
+			append network_data "frequency=$freq" "$N$T"
+		}
+
+		scan_ssid="scan_ssid=0"
+
+		[ "$_w_driver" = "nl80211" ] ||	wpa_key_mgmt="WPA-NONE"
+	}
+
+	[[ "$_w_mode" = "mesh" ]] && {
+		append network_data "mode=5" "$N$T"
+		[ -n "$channel" ] && {
+			freq="$(get_freq "$phy" "$channel")"
+			append network_data "frequency=$freq" "$N$T"
+		}
+		wpa_key_mgmt="SAE"
+		scan_ssid=""
+	}
+
+	[[ "$_w_mode" = "adhoc" -o "$_w_mode" = "mesh" ]] && append network_data "$_w_modestr" "$N$T"
+
+	case "$auth_type" in
+		none) ;;
+		wep)
+			local wep_keyidx=0
+			hostapd_append_wep_key network_data
+			append network_data "wep_tx_keyidx=$wep_keyidx" "$N$T"
+		;;
+		psk)
+			local passphrase
+
+			key_mgmt="$wpa_key_mgmt"
+			if [ ${#key} -eq 64 ]; then
+				passphrase="psk=${key}"
+			else
+				passphrase="psk=\"${key}\""
+			fi
+			append network_data "$passphrase" "$N$T"
+		;;
+		eap)
+			key_mgmt='WPA-EAP'
+
+			json_get_vars eap_type identity ca_cert
+			[ -n "$ca_cert" ] && append network_data "ca_cert=\"$ca_cert\"" "$N$T"
+			[ -n "$identity" ] && append network_data "identity=\"$identity\"" "$N$T"
+			case "$eap_type" in
+				tls)
+					json_get_vars client_cert priv_key priv_key_pwd
+					append network_data "client_cert=\"$client_cert\"" "$N$T"
+					append network_data "private_key=\"$priv_key\"" "$N$T"
+					append network_data "private_key_passwd=\"$priv_key_pwd\"" "$N$T"
+				;;
+				peap|ttls)
+					json_get_vars auth password
+					set_default auth MSCHAPV2
+					append network_data "phase2=\"$auth\"" "$N$T"
+					append network_data "password=\"$password\"" "$N$T"
+				;;
+			esac
+			append network_data "eap=$(echo $eap_type | tr 'a-z' 'A-Z')" "$N$T"
+		;;
+	esac
+
+	[ "$mode" = mesh ] || {
+		case "$wpa" in
+			1)
+				append network_data "proto=WPA" "$N$T"
+			;;
+			2)
+				append network_data "proto=RSN" "$N$T"
+			;;
+		esac
+
+		case "$ieee80211w" in
+			[012])
+				[ "$wpa" -ge 2 ] && append network_data "ieee80211w=$ieee80211w" "$N$T"
+			;;
+		esac
+	}
+	local beacon_int brates mrate
+	[ -n "$bssid" ] && append network_data "bssid=$bssid" "$N$T"
+	[ -n "$beacon_int" ] && append network_data "beacon_int=$beacon_int" "$N$T"
+
+	local bssid_blacklist bssid_whitelist
+	json_get_values bssid_blacklist bssid_blacklist
+	json_get_values bssid_whitelist bssid_whitelist
+
+	[ -n "$bssid_blacklist" ] && append network_data "bssid_blacklist=$bssid_blacklist" "$N$T"
+	[ -n "$bssid_whitelist" ] && append network_data "bssid_whitelist=$bssid_whitelist" "$N$T"
+
+	[ -n "$basic_rate" ] && {
+		local br rate_list=
+		for br in $basic_rate; do
+			wpa_supplicant_add_rate rate_list "$br"
+		done
+		[ -n "$rate_list" ] && append network_data "rates=$rate_list" "$N$T"
+	}
+
+	[ -n "$mcast_rate" ] && {
+		local mc_rate=
+		wpa_supplicant_add_rate mc_rate "$mcast_rate"
+		append network_data "mcast_rate=$mc_rate" "$N$T"
+	}
+
+	local ht_str
+	[[ "$_w_mode" = adhoc ]] || ibss_htmode=
+	[ -n "$ibss_htmode" ] && append network_data "htmode=$ibss_htmode" "$N$T"
+
+	cat >> "$_config" <<EOF
+network={
+	$scan_ssid
+	ssid="$ssid"
+	key_mgmt=$key_mgmt
+	$network_data
+}
+EOF
+	return 0
+}
+
+wpa_supplicant_run() {
+	local ifname="$1"; shift
+
+	_wpa_supplicant_common "$ifname"
+
+	/usr/sbin/wpa_supplicant -B \
+		${network_bridge:+-b $network_bridge} \
+		-P "/var/run/wpa_supplicant-${ifname}.pid" \
+		-D ${_w_driver:-wext} \
+		-i "$ifname" \
+		-c "$_config" \
+		-C "$_rpath" \
+		"$@"
+
+	ret="$?"
+	wireless_add_process "$(cat "/var/run/wpa_supplicant-${ifname}.pid")" /usr/sbin/wpa_supplicant 1
+
+	[ "$ret" != 0 ] && wireless_setup_vif_failed WPA_SUPPLICANT_FAILED
+
+	return $ret
+}
+
+hostapd_common_cleanup() {
+	killall hostapd wpa_supplicant meshd-nl80211
+}
diff --git a/package/network/services/hostapd/files/wpa_supplicant-full.config b/package/network/services/hostapd/files/wpa_supplicant-full.config
index 18c3f9a5c142b2eda67ec3136c73114555c4d131..a9d04ab1752bf8cd8a51d5d4a7cb0431463add57 100644
--- a/package/network/services/hostapd/files/wpa_supplicant-full.config
+++ b/package/network/services/hostapd/files/wpa_supplicant-full.config
@@ -41,7 +41,7 @@
 
 
 # Driver interface for Host AP driver
-#CONFIG_DRIVER_HOSTAP=y
+CONFIG_DRIVER_HOSTAP=y
 
 # Driver interface for Agere driver
 #CONFIG_DRIVER_HERMES=y
@@ -121,9 +121,6 @@ CONFIG_DRIVER_WIRED=y
 # included)
 CONFIG_IEEE8021X_EAPOL=y
 
-# EAP-FAST
-CONFIG_EAP_FAST=y
-
 # EAP-MD5
 CONFIG_EAP_MD5=y
 
@@ -370,7 +367,7 @@ CONFIG_INTERNAL_LIBTOMMATH_FAST=y
 #CONFIG_DYNAMIC_EAP_METHODS=y
 
 # IEEE Std 802.11r-2008 (Fast BSS Transition)
-CONFIG_IEEE80211R=y
+#CONFIG_IEEE80211R=y
 
 # Add support for writing debug log to a file (/tmp/wpa_supplicant-log-#.txt)
 #CONFIG_DEBUG_FILE=y
diff --git a/package/network/services/hostapd/files/wpa_supplicant-mini.config b/package/network/services/hostapd/files/wpa_supplicant-mini.config
index c272153b3a9ee52e3dd6370c533fd0d06fac9e20..a8d334d942e0618eb1224d093bb5047b1b40577a 100644
--- a/package/network/services/hostapd/files/wpa_supplicant-mini.config
+++ b/package/network/services/hostapd/files/wpa_supplicant-mini.config
@@ -41,7 +41,7 @@
 
 
 # Driver interface for Host AP driver
-#CONFIG_DRIVER_HOSTAP=y
+CONFIG_DRIVER_HOSTAP=y
 
 # Driver interface for Agere driver
 #CONFIG_DRIVER_HERMES=y
diff --git a/package/network/services/hostapd/files/wpa_supplicant-p2p.config b/package/network/services/hostapd/files/wpa_supplicant-p2p.config
index 563dace352f36e471374d40e37deee171d69094f..1c307d0e697b99036cafaed8b923cea0523114c2 100644
--- a/package/network/services/hostapd/files/wpa_supplicant-p2p.config
+++ b/package/network/services/hostapd/files/wpa_supplicant-p2p.config
@@ -41,7 +41,7 @@
 
 
 # Driver interface for Host AP driver
-#CONFIG_DRIVER_HOSTAP=y
+CONFIG_DRIVER_HOSTAP=y
 
 # Driver interface for Agere driver
 #CONFIG_DRIVER_HERMES=y
diff --git a/package/network/services/hostapd/files/wpa_supplicant.sh b/package/network/services/hostapd/files/wpa_supplicant.sh
new file mode 100644
index 0000000000000000000000000000000000000000..b6784843e8ea99763796d9bfe772b004468e7304
--- /dev/null
+++ b/package/network/services/hostapd/files/wpa_supplicant.sh
@@ -0,0 +1,194 @@
+wpa_supplicant_setup_vif() {
+	local vif="$1"
+	local driver="$2"
+	local key="$key"
+	local options="$3"
+	local freq=""
+	local ht="$5"
+	local ap_scan=""
+	local scan_ssid="1"
+	[ -n "$4" ] && freq="frequency=$4"
+
+	config_get enc "$vif" encryption
+	config_get key "$vif" key
+
+	local net_cfg bridge
+	config_get bridge "$vif" bridge
+	[ -z "$bridge" ] && {
+		net_cfg="$(find_net_config "$vif")"
+		[ -z "$net_cfg" ] || bridge="$(bridge_interface "$net_cfg")"
+		config_set "$vif" bridge "$bridge"
+	}
+
+	local mode ifname wds modestr=""
+	config_get mode "$vif" mode
+	config_get ifname "$vif" ifname
+	config_get_bool wds "$vif" wds 0
+	[ -z "$bridge" ] || [ "$mode" = ap ] || [ "$mode" = sta -a $wds -eq 1 ] || {
+		echo "wpa_supplicant_setup_vif($ifname): Refusing to bridge $mode mode interface"
+		return 1
+	}
+	[ "$mode" = "adhoc" ] && {
+		modestr="mode=1"
+		scan_ssid="0"
+		ap_scan="ap_scan=2"
+	}
+
+	key_mgmt='NONE'
+	case "$enc" in
+		*none*) ;;
+		*wep*)
+			config_get key "$vif" key
+			key="${key:-1}"
+			case "$key" in
+				[1234])
+					for idx in 1 2 3 4; do
+						local zidx
+						zidx=$(($idx - 1))
+						config_get ckey "$vif" "key${idx}"
+						[ -n "$ckey" ] && \
+							append "wep_key${zidx}" "wep_key${zidx}=$(prepare_key_wep "$ckey")"
+					done
+					wep_tx_keyidx="wep_tx_keyidx=$((key - 1))"
+				;;
+				*)
+					wep_key0="wep_key0=$(prepare_key_wep "$key")"
+					wep_tx_keyidx="wep_tx_keyidx=0"
+				;;
+			esac
+		;;
+		*psk*)
+			key_mgmt='WPA-PSK'
+			# if you want to use PSK with a non-nl80211 driver you
+			# have to use WPA-NONE and wext driver for wpa_s
+			[ "$mode" = "adhoc" -a "$driver" != "nl80211" ] && {
+				key_mgmt='WPA-NONE'
+				driver='wext'
+			}
+			if [ ${#key} -eq 64 ]; then
+				passphrase="psk=${key}"
+			else
+				passphrase="psk=\"${key}\""
+			fi
+			case "$enc" in
+				*psk2*)
+					proto='proto=RSN'
+					config_get ieee80211w "$vif" ieee80211w
+				;;
+				*psk*)
+					proto='proto=WPA'
+				;;
+			esac
+		;;
+		*wpa*|*8021x*)
+			proto='proto=WPA2'
+			key_mgmt='WPA-EAP'
+			config_get ieee80211w "$vif" ieee80211w
+			config_get ca_cert "$vif" ca_cert
+			config_get eap_type "$vif" eap_type
+			ca_cert=${ca_cert:+"ca_cert=\"$ca_cert\""}
+			case "$eap_type" in
+				tls)
+					pairwise='pairwise=CCMP'
+					group='group=CCMP'
+					config_get identity "$vif" identity
+					config_get client_cert "$vif" client_cert
+					config_get priv_key "$vif" priv_key
+					config_get priv_key_pwd "$vif" priv_key_pwd
+					identity="identity=\"$identity\""
+					client_cert="client_cert=\"$client_cert\""
+					priv_key="private_key=\"$priv_key\""
+					priv_key_pwd="private_key_passwd=\"$priv_key_pwd\""
+				;;
+				peap|ttls)
+					config_get auth "$vif" auth
+					config_get identity "$vif" identity
+					config_get password "$vif" password
+					phase2="phase2=\"auth=${auth:-MSCHAPV2}\""
+					identity="identity=\"$identity\""
+					password="${password:+password=\"$password\"}"
+				;;
+			esac
+			eap_type="eap=$(echo $eap_type | tr 'a-z' 'A-Z')"
+		;;
+	esac
+
+	case "$ieee80211w" in
+		[012])
+			ieee80211w="ieee80211w=$ieee80211w"
+		;;
+	esac
+
+	local fixed_freq bssid1 beacon_int brates mrate
+	config_get ifname "$vif" ifname
+	config_get bridge "$vif" bridge
+	config_get ssid "$vif" ssid
+	config_get bssid "$vif" bssid
+	bssid1=${bssid:+"bssid=$bssid"}
+	beacon_int=${beacon_int:+"beacon_int=$beacon_int"}
+
+	local br brval brsub brstr
+	[ -n "$basic_rate_list" ] && {
+		for br in $basic_rate_list; do
+			brval="$(($br / 1000))"
+			brsub="$((($br / 100) % 10))"
+			[ "$brsub" -gt 0 ] && brval="$brval.$brsub"
+			[ -n "$brstr" ] && brstr="$brstr,"
+			brstr="$brstr$brval"
+		done
+		brates=${basic_rate_list:+"rates=$brstr"}
+	}
+
+	local mcval=""
+	[ -n "$mcast_rate" ] && {
+		mcval="$(($mcast_rate / 1000))"
+		mcsub="$(( ($mcast_rate / 100) % 10 ))"
+		[ "$mcsub" -gt 0 ] && mcval="$mcval.$mcsub"
+		mrate=${mcast_rate:+"mcast_rate=$mcval"}
+	}
+
+	local ht_str
+	[ -n "$ht" ] && ht_str="htmode=$ht"
+
+	rm -rf /var/run/wpa_supplicant-$ifname
+	cat > /var/run/wpa_supplicant-$ifname.conf <<EOF
+ctrl_interface=/var/run/wpa_supplicant-$ifname
+$ap_scan
+network={
+	$modestr
+	scan_ssid=$scan_ssid
+	ssid="$ssid"
+	$bssid1
+	key_mgmt=$key_mgmt
+	$proto
+	$freq
+	${fixed:+"fixed_freq=1"}
+	$beacon_int
+	$brates
+	$mrate
+	$ht_str
+	$ieee80211w
+	$passphrase
+	$pairwise
+	$group
+	$eap_type
+	$ca_cert
+	$client_cert
+	$priv_key
+	$priv_key_pwd
+	$phase2
+	$identity
+	$password
+	$wep_key0
+	$wep_key1
+	$wep_key2
+	$wep_key3
+	$wep_tx_keyidx
+}
+EOF
+	if [ -n "$proto" -o "$key_mgmt" = "NONE" ]; then
+		wpa_supplicant ${bridge:+ -b $bridge} -B -P "/var/run/wifi-${ifname}.pid" -D ${driver:-wext} -i "$ifname" -c /var/run/wpa_supplicant-$ifname.conf $options
+	else
+		return 0
+	fi
+}
diff --git a/package/network/services/hostapd/patches/001-Fix-race-condition-between-AssocResp-callback-and-4a.patch b/package/network/services/hostapd/patches/001-Fix-race-condition-between-AssocResp-callback-and-4a.patch
deleted file mode 100644
index bf54e9df329496c0f1465c2e6ff9f2a75f8a61ef..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/001-Fix-race-condition-between-AssocResp-callback-and-4a.patch
+++ /dev/null
@@ -1,83 +0,0 @@
-From: Jouni Malinen <jouni@qca.qualcomm.com>
-Date: Tue, 20 Dec 2016 01:30:09 +0200
-Subject: [PATCH] Fix race condition between AssocResp callback and 4addr event
-
-It is apparently possible for the NL80211_CMD_UNEXPECTED_4ADDR_FRAME
-event to be delivered to hostapd before the NL80211_CMD_FRAME_TX_STATUS
-event for (Re)Association Response frame. This resulted in the 4-address
-WDS mode not getting enabled for a STA. This could occur in particular
-when operating under heavy load and the STA is reconnecting to the same
-AP in a sequence where Deauthentication frame is followed immediately by
-Authentication frame and the driver event processing gets delayed due to
-removal of the previous netdev taking time in the middle of this
-sequence.
-
-Fix this by recording a pending item for 4-address WDS enabling if the
-NL80211_CMD_UNEXPECTED_4ADDR_FRAME event would have been dropped due to
-incompleted association and then process this pending item if the TX
-status for the (Re)Association Response frame is received and it shows
-that the frame was acknowledged.
-
-Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
----
-
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -2634,6 +2634,8 @@ static void handle_assoc(struct hostapd_
- 	taxonomy_sta_info_assoc_req(hapd, sta, pos, left);
- #endif /* CONFIG_TAXONOMY */
- 
-+	sta->pending_wds_enable = 0;
-+
-  fail:
- 	/*
- 	 * In case of a successful response, add the station to the driver.
-@@ -3248,6 +3250,14 @@ static void handle_assoc_cb(struct hosta
- 
- 	hostapd_set_sta_flags(hapd, sta);
- 
-+	if (!(sta->flags & WLAN_STA_WDS) && sta->pending_wds_enable) {
-+		wpa_printf(MSG_DEBUG, "Enable 4-address WDS mode for STA "
-+			   MACSTR " based on pending request",
-+			   MAC2STR(sta->addr));
-+		sta->pending_wds_enable = 0;
-+		sta->flags |= WLAN_STA_WDS;
-+	}
-+
- 	if (sta->flags & WLAN_STA_WDS) {
- 		int ret;
- 		char ifname_wds[IFNAMSIZ + 1];
-@@ -3512,10 +3522,22 @@ void ieee802_11_rx_from_unknown(struct h
- 	struct sta_info *sta;
- 
- 	sta = ap_get_sta(hapd, src);
--	if (sta && (sta->flags & WLAN_STA_ASSOC)) {
-+	if (sta &&
-+	    ((sta->flags & WLAN_STA_ASSOC) ||
-+	     ((sta->flags & WLAN_STA_ASSOC_REQ_OK) && wds))) {
- 		if (!hapd->conf->wds_sta)
- 			return;
- 
-+		if ((sta->flags & (WLAN_STA_ASSOC | WLAN_STA_ASSOC_REQ_OK)) ==
-+		    WLAN_STA_ASSOC_REQ_OK) {
-+			wpa_printf(MSG_DEBUG,
-+				   "Postpone 4-address WDS mode enabling for STA "
-+				   MACSTR " since TX status for AssocResp is not yet known",
-+				   MAC2STR(sta->addr));
-+			sta->pending_wds_enable = 1;
-+			return;
-+		}
-+
- 		if (wds && !(sta->flags & WLAN_STA_WDS)) {
- 			int ret;
- 			char ifname_wds[IFNAMSIZ + 1];
---- a/src/ap/sta_info.h
-+++ b/src/ap/sta_info.h
-@@ -115,6 +115,7 @@ struct sta_info {
- 	unsigned int radius_das_match:1;
- 	unsigned int ecsa_supported:1;
- 	unsigned int added_unassoc:1;
-+	unsigned int pending_wds_enable:1;
- 
- 	u16 auth_alg;
- 
diff --git a/package/network/services/hostapd/patches/002-Fix-duplicate-Reassociation-Request-frame-dropping.patch b/package/network/services/hostapd/patches/002-Fix-duplicate-Reassociation-Request-frame-dropping.patch
deleted file mode 100644
index 6db1e9b34bf8aa92fec2384c2338f7bfbde6b362..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/002-Fix-duplicate-Reassociation-Request-frame-dropping.patch
+++ /dev/null
@@ -1,36 +0,0 @@
-From: Jouni Malinen <jouni@qca.qualcomm.com>
-Date: Sat, 14 Jan 2017 01:04:31 +0200
-Subject: [PATCH] Fix duplicate Reassociation Request frame dropping
-
-Relational operators (==) have higher precedence than the ternary
-conditional in C. The last_subtype check for association/reassociation
-was broken due to incorrect assumption about the precedence. Fix this by
-adding parenthesis around the ternary conditional.
-
-The previous implementation worked for Association Request frames by
-accident since WLAN_FC_STYPE_ASSOC_REQ happens to have value 0 and when
-the last receive frame was an Association Request frame, the
-sta->last_subtype == reassoc check was true and non-zero
-WLAN_FC_STYPE_REASSOC_REQ was interpreted as true. However, this was
-broken for Reassociation Request frame. reassoc == 1 in that case could
-have matched received Association Response frame (subtype == 1), but
-those are not received in AP mode and as such, this did not break other
-behavior apart from not being able to drop duplicated Reassociation
-Request frames.
-
-Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
----
-
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -2485,8 +2485,8 @@ static void handle_assoc(struct hostapd_
- 	if ((fc & WLAN_FC_RETRY) &&
- 	    sta->last_seq_ctrl != WLAN_INVALID_MGMT_SEQ &&
- 	    sta->last_seq_ctrl == seq_ctrl &&
--	    sta->last_subtype == reassoc ? WLAN_FC_STYPE_REASSOC_REQ :
--	    WLAN_FC_STYPE_ASSOC_REQ) {
-+	    sta->last_subtype == (reassoc ? WLAN_FC_STYPE_REASSOC_REQ :
-+				  WLAN_FC_STYPE_ASSOC_REQ)) {
- 		hostapd_logger(hapd, sta->addr, HOSTAPD_MODULE_IEEE80211,
- 			       HOSTAPD_LEVEL_DEBUG,
- 			       "Drop repeated association frame seq_ctrl=0x%x",
diff --git a/package/network/services/hostapd/patches/003-RSN-IBSS-Fix-TK-clearing-on-Authentication-frame-RX.patch b/package/network/services/hostapd/patches/003-RSN-IBSS-Fix-TK-clearing-on-Authentication-frame-RX.patch
deleted file mode 100644
index 0a3c27f89e3c802498c52b7e1342167999a760a4..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/003-RSN-IBSS-Fix-TK-clearing-on-Authentication-frame-RX.patch
+++ /dev/null
@@ -1,40 +0,0 @@
-From: Jouni Malinen <j@w1.fi>
-Date: Sat, 14 Jan 2017 13:56:18 +0200
-Subject: [PATCH] RSN IBSS: Fix TK clearing on Authentication frame RX
-
-When wpa_supplicant was processing a received Authentication frame (seq
-1) from a peer STA for which there was already a TK configured to the
-driver, debug log claimed that the PTK gets cleared, but the actual
-call to clear the key was actually dropped due to AUTH vs. SUPP set_key
-selection. Fix this by explicitly clearing the TK in case it was set
-and an Authentication frame (seq 1) is received.
-
-This fixes some cases where EAPOL-Key frames were sent encrypted using
-the old key when a peer STA restarted itself and lost the key and had to
-re-join the IBSS. Previously, that state required timing out the 4-way
-handshake and Deauthentication frame exchange to recover.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
-
---- a/wpa_supplicant/ibss_rsn.c
-+++ b/wpa_supplicant/ibss_rsn.c
-@@ -838,6 +838,18 @@ static void ibss_rsn_handle_auth_1_of_2(
- 		   MAC2STR(addr));
- 
- 	if (peer &&
-+	    peer->authentication_status & (IBSS_RSN_SET_PTK_SUPP |
-+					   IBSS_RSN_SET_PTK_AUTH)) {
-+		/* Clear the TK for this pair to allow recovery from the case
-+		 * where the peer STA has restarted and lost its key while we
-+		 * still have a pairwise key configured. */
-+		wpa_printf(MSG_DEBUG, "RSN: Clear pairwise key for peer "
-+			   MACSTR, MAC2STR(addr));
-+		wpa_drv_set_key(ibss_rsn->wpa_s, WPA_ALG_NONE, addr, 0, 0,
-+				NULL, 0, NULL, 0);
-+	}
-+
-+	if (peer &&
- 	    peer->authentication_status & IBSS_RSN_AUTH_EAPOL_BY_PEER) {
- 		if (peer->own_auth_tx.sec) {
- 			struct os_reltime now, diff;
diff --git a/package/network/services/hostapd/patches/004-hostapd-Add-possibility-to-send-debug-messages-to-sy.patch b/package/network/services/hostapd/patches/004-hostapd-Add-possibility-to-send-debug-messages-to-sy.patch
deleted file mode 100644
index 3417b5ac3c3f2e5fbea85ab2ab96302c84200676..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/004-hostapd-Add-possibility-to-send-debug-messages-to-sy.patch
+++ /dev/null
@@ -1,145 +0,0 @@
-From cc3dae85bd694506cdea66ae532d452fb8716297 Mon Sep 17 00:00:00 2001
-From: Wojciech Dubowik <Wojciech.Dubowik@neratec.com>
-Date: Mon, 23 Jan 2017 13:55:04 +0100
-Subject: [PATCH] hostapd: Add possibility to send debug messages to syslog
-
-We can only send module specific messages to syslog and not debug
-messages printed with wpa_printf. Add an extra command line parameter
-'-s' to allow it. The feature is enabled with compile flag
-CONFIG_DEBUG_SYSLOG as for wpa_supplicant and behaves in the same manner
-as the wpa_supplicant -s command line argument.
-
-Signed-off-by: Wojciech Dubowik <Wojciech.Dubowik@neratec.com>
----
- hostapd/Android.mk    |  4 ++++
- hostapd/Makefile      |  4 ++++
- hostapd/defconfig     |  3 +++
- hostapd/main.c        | 19 ++++++++++++++++++-
- src/utils/wpa_debug.c |  2 +-
- src/utils/wpa_debug.h |  3 +++
- 6 files changed, 33 insertions(+), 2 deletions(-)
-
---- a/hostapd/Android.mk
-+++ b/hostapd/Android.mk
-@@ -952,6 +952,10 @@ ifdef CONFIG_NO_STDOUT_DEBUG
- L_CFLAGS += -DCONFIG_NO_STDOUT_DEBUG
- endif
- 
-+ifdef CONFIG_DEBUG_SYSLOG
-+L_CFLAGS += -DCONFIG_DEBUG_SYSLOG
-+endif
-+
- ifdef CONFIG_DEBUG_LINUX_TRACING
- L_CFLAGS += -DCONFIG_DEBUG_LINUX_TRACING
- endif
---- a/hostapd/Makefile
-+++ b/hostapd/Makefile
-@@ -997,6 +997,10 @@ ifdef CONFIG_NO_STDOUT_DEBUG
- CFLAGS += -DCONFIG_NO_STDOUT_DEBUG
- endif
- 
-+ifdef CONFIG_DEBUG_SYSLOG
-+CFLAGS += -DCONFIG_DEBUG_SYSLOG
-+endif
-+
- ifdef CONFIG_DEBUG_LINUX_TRACING
- CFLAGS += -DCONFIG_DEBUG_LINUX_TRACING
- endif
---- a/hostapd/defconfig
-+++ b/hostapd/defconfig
-@@ -166,6 +166,9 @@ CONFIG_IPV6=y
- # Disabled by default.
- #CONFIG_DEBUG_FILE=y
- 
-+# Send debug messages to syslog instead of stdout
-+#CONFIG_DEBUG_SYSLOG=y
-+
- # Add support for sending all debug messages (regardless of debug verbosity)
- # to the Linux kernel tracing facility. This helps debug the entire stack by
- # making it easy to record everything happening from the driver up into the
---- a/hostapd/main.c
-+++ b/hostapd/main.c
-@@ -108,6 +108,10 @@ static void hostapd_logger_cb(void *ctx,
- 			    module_str ? module_str : "",
- 			    module_str ? ": " : "", txt);
- 
-+#ifdef CONFIG_DEBUG_SYSLOG
-+	if (wpa_debug_syslog)
-+		conf_stdout = 0;
-+#endif /* CONFIG_DEBUG_SYSLOG */
- 	if ((conf_stdout & module) && level >= conf_stdout_level) {
- 		wpa_debug_print_timestamp();
- 		wpa_printf(MSG_INFO, "%s", format);
-@@ -484,6 +488,9 @@ static void usage(void)
- 		"        (records all messages regardless of debug verbosity)\n"
- #endif /* CONFIG_DEBUG_LINUX_TRACING */
- 		"   -i   list of interface names to use\n"
-+#ifdef CONFIG_DEBUG_SYSLOG
-+		"   -s   log output to syslog instead of stdout\n"
-+#endif /* CONFIG_DEBUG_SYSLOG */
- 		"   -S   start all the interfaces synchronously\n"
- 		"   -t   include timestamps in some debug messages\n"
- 		"   -v   show hostapd version\n");
-@@ -661,7 +668,7 @@ int main(int argc, char *argv[])
- 	dl_list_init(&interfaces.global_ctrl_dst);
- 
- 	for (;;) {
--		c = getopt(argc, argv, "b:Bde:f:hi:KP:STtu:vg:G:");
-+		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:vg:G:");
- 		if (c < 0)
- 			break;
- 		switch (c) {
-@@ -718,6 +725,11 @@ int main(int argc, char *argv[])
- 			bss_config = tmp_bss;
- 			bss_config[num_bss_configs++] = optarg;
- 			break;
-+#ifdef CONFIG_DEBUG_SYSLOG
-+		case 's':
-+			wpa_debug_syslog = 1;
-+			break;
-+#endif /* CONFIG_DEBUG_SYSLOG */
- 		case 'S':
- 			start_ifaces_in_sync = 1;
- 			break;
-@@ -746,6 +758,10 @@ int main(int argc, char *argv[])
- 		wpa_debug_open_file(log_file);
- 	else
- 		wpa_debug_setup_stdout();
-+#ifdef CONFIG_DEBUG_SYSLOG
-+	if (wpa_debug_syslog)
-+		wpa_debug_open_syslog();
-+#endif /* CONFIG_DEBUG_SYSLOG */
- #ifdef CONFIG_DEBUG_LINUX_TRACING
- 	if (enable_trace_dbg) {
- 		int tret = wpa_debug_open_linux_tracing();
-@@ -882,6 +898,7 @@ int main(int argc, char *argv[])
- 	hostapd_global_deinit(pid_file, interfaces.eloop_initialized);
- 	os_free(pid_file);
- 
-+	wpa_debug_close_syslog();
- 	if (log_file)
- 		wpa_debug_close_file();
- 	wpa_debug_close_linux_tracing();
---- a/src/utils/wpa_debug.c
-+++ b/src/utils/wpa_debug.c
-@@ -13,7 +13,7 @@
- #ifdef CONFIG_DEBUG_SYSLOG
- #include <syslog.h>
- 
--static int wpa_debug_syslog = 0;
-+int wpa_debug_syslog = 0;
- #endif /* CONFIG_DEBUG_SYSLOG */
- 
- #ifdef CONFIG_DEBUG_LINUX_TRACING
---- a/src/utils/wpa_debug.h
-+++ b/src/utils/wpa_debug.h
-@@ -14,6 +14,9 @@
- extern int wpa_debug_level;
- extern int wpa_debug_show_keys;
- extern int wpa_debug_timestamp;
-+#ifdef CONFIG_DEBUG_SYSLOG
-+extern int wpa_debug_syslog;
-+#endif /* CONFIG_DEBUG_SYSLOG */
- 
- /* Debugging function - conditional printf and hex dump. Driver wrappers can
-  * use these for debugging purposes. */
diff --git a/package/network/services/hostapd/patches/005-hostapd-Avoid-key-reinstallation-in-FT-handshake.patch b/package/network/services/hostapd/patches/005-hostapd-Avoid-key-reinstallation-in-FT-handshake.patch
deleted file mode 100644
index 2136bb9d471c597f995a03ae885dae57fa4b252c..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/005-hostapd-Avoid-key-reinstallation-in-FT-handshake.patch
+++ /dev/null
@@ -1,154 +0,0 @@
-From: Mathy Vanhoef <Mathy.Vanhoef@cs.kuleuven.be>
-Date: Fri, 14 Jul 2017 15:15:35 +0200
-Subject: [PATCH] hostapd: Avoid key reinstallation in FT handshake
-
-Do not reinstall TK to the driver during Reassociation Response frame
-processing if the first attempt of setting the TK succeeded. This avoids
-issues related to clearing the TX/RX PN that could result in reusing
-same PN values for transmitted frames (e.g., due to CCM nonce reuse and
-also hitting replay protection on the receiver) and accepting replayed
-frames on RX side.
-
-This issue was introduced by the commit
-0e84c25434e6a1f283c7b4e62e483729085b78d2 ('FT: Fix PTK configuration in
-authenticator') which allowed wpa_ft_install_ptk() to be called multiple
-times with the same PTK. While the second configuration attempt is
-needed with some drivers, it must be done only if the first attempt
-failed.
-
-Signed-off-by: Mathy Vanhoef <Mathy.Vanhoef@cs.kuleuven.be>
----
-
---- a/src/ap/ieee802_11.c
-+++ b/src/ap/ieee802_11.c
-@@ -2154,6 +2154,7 @@ static int add_associated_sta(struct hos
- {
- 	struct ieee80211_ht_capabilities ht_cap;
- 	struct ieee80211_vht_capabilities vht_cap;
-+	int set = 1;
- 
- 	/*
- 	 * Remove the STA entry to ensure the STA PS state gets cleared and
-@@ -2161,9 +2162,18 @@ static int add_associated_sta(struct hos
- 	 * FT-over-the-DS, where a station re-associates back to the same AP but
- 	 * skips the authentication flow, or if working with a driver that
- 	 * does not support full AP client state.
-+	 *
-+	 * Skip this if the STA has already completed FT reassociation and the
-+	 * TK has been configured since the TX/RX PN must not be reset to 0 for
-+	 * the same key.
- 	 */
--	if (!sta->added_unassoc)
-+	if (!sta->added_unassoc &&
-+	    (!(sta->flags & WLAN_STA_AUTHORIZED) ||
-+	     !wpa_auth_sta_ft_tk_already_set(sta->wpa_sm))) {
- 		hostapd_drv_sta_remove(hapd, sta->addr);
-+		wpa_auth_sm_event(sta->wpa_sm, WPA_DRV_STA_REMOVED);
-+		set = 0;
-+	}
- 
- #ifdef CONFIG_IEEE80211N
- 	if (sta->flags & WLAN_STA_HT)
-@@ -2186,11 +2196,11 @@ static int add_associated_sta(struct hos
- 			    sta->flags & WLAN_STA_VHT ? &vht_cap : NULL,
- 			    sta->flags | WLAN_STA_ASSOC, sta->qosinfo,
- 			    sta->vht_opmode, sta->p2p_ie ? 1 : 0,
--			    sta->added_unassoc)) {
-+			    set)) {
- 		hostapd_logger(hapd, sta->addr,
- 			       HOSTAPD_MODULE_IEEE80211, HOSTAPD_LEVEL_NOTICE,
- 			       "Could not %s STA to kernel driver",
--			       sta->added_unassoc ? "set" : "add");
-+			       set ? "set" : "add");
- 
- 		if (sta->added_unassoc) {
- 			hostapd_drv_sta_remove(hapd, sta->addr);
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -1751,6 +1751,9 @@ int wpa_auth_sm_event(struct wpa_state_m
- #else /* CONFIG_IEEE80211R_AP */
- 		break;
- #endif /* CONFIG_IEEE80211R_AP */
-+	case WPA_DRV_STA_REMOVED:
-+		sm->tk_already_set = FALSE;
-+		return 0;
- 	}
- 
- #ifdef CONFIG_IEEE80211R_AP
-@@ -3725,6 +3728,14 @@ int wpa_auth_sta_wpa_version(struct wpa_
- }
- 
- 
-+int wpa_auth_sta_ft_tk_already_set(struct wpa_state_machine *sm)
-+{
-+	if (!sm || !wpa_key_mgmt_ft(sm->wpa_key_mgmt))
-+		return 0;
-+	return sm->tk_already_set;
-+}
-+
-+
- int wpa_auth_sta_clear_pmksa(struct wpa_state_machine *sm,
- 			     struct rsn_pmksa_cache_entry *entry)
- {
---- a/src/ap/wpa_auth_ft.c
-+++ b/src/ap/wpa_auth_ft.c
-@@ -794,6 +794,14 @@ void wpa_ft_install_ptk(struct wpa_state
- 		return;
- 	}
- 
-+	if (sm->tk_already_set) {
-+		/* Must avoid TK reconfiguration to prevent clearing of TX/RX
-+		 * PN in the driver */
-+		wpa_printf(MSG_DEBUG,
-+			   "FT: Do not re-install same PTK to the driver");
-+		return;
-+	}
-+
- 	/* FIX: add STA entry to kernel/driver here? The set_key will fail
- 	 * most likely without this.. At the moment, STA entry is added only
- 	 * after association has been completed. This function will be called
-@@ -806,6 +814,7 @@ void wpa_ft_install_ptk(struct wpa_state
- 
- 	/* FIX: MLME-SetProtection.Request(TA, Tx_Rx) */
- 	sm->pairwise_set = TRUE;
-+	sm->tk_already_set = TRUE;
- }
- 
- 
-@@ -1002,6 +1011,7 @@ static int wpa_ft_process_auth_req(struc
- 
- 	sm->pairwise = pairwise;
- 	sm->PTK_valid = TRUE;
-+	sm->tk_already_set = FALSE;
- 	wpa_ft_install_ptk(sm);
- 
- 	buflen = 2 + sizeof(struct rsn_mdie) + 2 + sizeof(struct rsn_ftie) +
---- a/src/ap/wpa_auth.h
-+++ b/src/ap/wpa_auth.h
-@@ -268,7 +268,7 @@ void wpa_receive(struct wpa_authenticato
- 		 u8 *data, size_t data_len);
- enum wpa_event {
- 	WPA_AUTH, WPA_ASSOC, WPA_DISASSOC, WPA_DEAUTH, WPA_REAUTH,
--	WPA_REAUTH_EAPOL, WPA_ASSOC_FT
-+	WPA_REAUTH_EAPOL, WPA_ASSOC_FT, WPA_DRV_STA_REMOVED
- };
- void wpa_remove_ptk(struct wpa_state_machine *sm);
- int wpa_auth_sm_event(struct wpa_state_machine *sm, enum wpa_event event);
-@@ -281,6 +281,7 @@ int wpa_auth_pairwise_set(struct wpa_sta
- int wpa_auth_get_pairwise(struct wpa_state_machine *sm);
- int wpa_auth_sta_key_mgmt(struct wpa_state_machine *sm);
- int wpa_auth_sta_wpa_version(struct wpa_state_machine *sm);
-+int wpa_auth_sta_ft_tk_already_set(struct wpa_state_machine *sm);
- int wpa_auth_sta_clear_pmksa(struct wpa_state_machine *sm,
- 			     struct rsn_pmksa_cache_entry *entry);
- struct rsn_pmksa_cache_entry *
---- a/src/ap/wpa_auth_i.h
-+++ b/src/ap/wpa_auth_i.h
-@@ -65,6 +65,7 @@ struct wpa_state_machine {
- 	struct wpa_ptk PTK;
- 	Boolean PTK_valid;
- 	Boolean pairwise_set;
-+	Boolean tk_already_set;
- 	int keycount;
- 	Boolean Pair;
- 	struct wpa_key_replay_counter {
diff --git a/package/network/services/hostapd/patches/006-Prevent-reinstallation-of-an-already-in-use-group-ke.patch b/package/network/services/hostapd/patches/006-Prevent-reinstallation-of-an-already-in-use-group-ke.patch
deleted file mode 100644
index 71c681e29b1346c3ab86db306dd0f5153bb36f87..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/006-Prevent-reinstallation-of-an-already-in-use-group-ke.patch
+++ /dev/null
@@ -1,244 +0,0 @@
-From: Mathy Vanhoef <Mathy.Vanhoef@cs.kuleuven.be>
-Date: Wed, 12 Jul 2017 16:03:24 +0200
-Subject: [PATCH] Prevent reinstallation of an already in-use group key
-
-Track the current GTK and IGTK that is in use and when receiving a
-(possibly retransmitted) Group Message 1 or WNM-Sleep Mode Response, do
-not install the given key if it is already in use. This prevents an
-attacker from trying to trick the client into resetting or lowering the
-sequence counter associated to the group key.
-
-Signed-off-by: Mathy Vanhoef <Mathy.Vanhoef@cs.kuleuven.be>
----
-
---- a/src/common/wpa_common.h
-+++ b/src/common/wpa_common.h
-@@ -207,6 +207,17 @@ struct wpa_ptk {
- 	size_t tk_len;
- };
- 
-+struct wpa_gtk {
-+	u8 gtk[WPA_GTK_MAX_LEN];
-+	size_t gtk_len;
-+};
-+
-+#ifdef CONFIG_IEEE80211W
-+struct wpa_igtk {
-+	u8 igtk[WPA_IGTK_MAX_LEN];
-+	size_t igtk_len;
-+};
-+#endif /* CONFIG_IEEE80211W */
- 
- /* WPA IE version 1
-  * 00-50-f2:1 (OUI:OUI type)
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -785,6 +785,15 @@ static int wpa_supplicant_install_gtk(st
- 	const u8 *_gtk = gd->gtk;
- 	u8 gtk_buf[32];
- 
-+	/* Detect possible key reinstallation */
-+	if (sm->gtk.gtk_len == (size_t) gd->gtk_len &&
-+	    os_memcmp(sm->gtk.gtk, gd->gtk, sm->gtk.gtk_len) == 0) {
-+		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
-+			"WPA: Not reinstalling already in-use GTK to the driver (keyidx=%d tx=%d len=%d)",
-+			gd->keyidx, gd->tx, gd->gtk_len);
-+		return 0;
-+	}
-+
- 	wpa_hexdump_key(MSG_DEBUG, "WPA: Group Key", gd->gtk, gd->gtk_len);
- 	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
- 		"WPA: Installing GTK to the driver (keyidx=%d tx=%d len=%d)",
-@@ -819,6 +828,9 @@ static int wpa_supplicant_install_gtk(st
- 	}
- 	os_memset(gtk_buf, 0, sizeof(gtk_buf));
- 
-+	sm->gtk.gtk_len = gd->gtk_len;
-+	os_memcpy(sm->gtk.gtk, gd->gtk, sm->gtk.gtk_len);
-+
- 	return 0;
- }
- 
-@@ -925,6 +937,48 @@ static int wpa_supplicant_pairwise_gtk(s
- }
- 
- 
-+#ifdef CONFIG_IEEE80211W
-+static int wpa_supplicant_install_igtk(struct wpa_sm *sm,
-+				       const struct wpa_igtk_kde *igtk)
-+{
-+	size_t len = wpa_cipher_key_len(sm->mgmt_group_cipher);
-+	u16 keyidx = WPA_GET_LE16(igtk->keyid);
-+
-+	/* Detect possible key reinstallation */
-+	if (sm->igtk.igtk_len == len &&
-+	    os_memcmp(sm->igtk.igtk, igtk->igtk, sm->igtk.igtk_len) == 0) {
-+		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
-+			"WPA: Not reinstalling already in-use IGTK to the driver (keyidx=%d)",
-+			keyidx);
-+		return  0;
-+	}
-+
-+	wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
-+		"WPA: IGTK keyid %d pn %02x%02x%02x%02x%02x%02x",
-+		keyidx, MAC2STR(igtk->pn));
-+	wpa_hexdump_key(MSG_DEBUG, "WPA: IGTK", igtk->igtk, len);
-+	if (keyidx > 4095) {
-+		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
-+			"WPA: Invalid IGTK KeyID %d", keyidx);
-+		return -1;
-+	}
-+	if (wpa_sm_set_key(sm, wpa_cipher_to_alg(sm->mgmt_group_cipher),
-+			   broadcast_ether_addr,
-+			   keyidx, 0, igtk->pn, sizeof(igtk->pn),
-+			   igtk->igtk, len) < 0) {
-+		wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
-+			"WPA: Failed to configure IGTK to the driver");
-+		return -1;
-+	}
-+
-+	sm->igtk.igtk_len = len;
-+	os_memcpy(sm->igtk.igtk, igtk->igtk, sm->igtk.igtk_len);
-+
-+	return 0;
-+}
-+#endif /* CONFIG_IEEE80211W */
-+
-+
- static int ieee80211w_set_keys(struct wpa_sm *sm,
- 			       struct wpa_eapol_ie_parse *ie)
- {
-@@ -935,30 +989,14 @@ static int ieee80211w_set_keys(struct wp
- 	if (ie->igtk) {
- 		size_t len;
- 		const struct wpa_igtk_kde *igtk;
--		u16 keyidx;
-+
- 		len = wpa_cipher_key_len(sm->mgmt_group_cipher);
- 		if (ie->igtk_len != WPA_IGTK_KDE_PREFIX_LEN + len)
- 			return -1;
-+
- 		igtk = (const struct wpa_igtk_kde *) ie->igtk;
--		keyidx = WPA_GET_LE16(igtk->keyid);
--		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG, "WPA: IGTK keyid %d "
--			"pn %02x%02x%02x%02x%02x%02x",
--			keyidx, MAC2STR(igtk->pn));
--		wpa_hexdump_key(MSG_DEBUG, "WPA: IGTK",
--				igtk->igtk, len);
--		if (keyidx > 4095) {
--			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
--				"WPA: Invalid IGTK KeyID %d", keyidx);
-+		if (wpa_supplicant_install_igtk(sm, igtk) < 0)
- 			return -1;
--		}
--		if (wpa_sm_set_key(sm, wpa_cipher_to_alg(sm->mgmt_group_cipher),
--				   broadcast_ether_addr,
--				   keyidx, 0, igtk->pn, sizeof(igtk->pn),
--				   igtk->igtk, len) < 0) {
--			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
--				"WPA: Failed to configure IGTK to the driver");
--			return -1;
--		}
- 	}
- 
- 	return 0;
-@@ -2451,7 +2489,7 @@ void wpa_sm_deinit(struct wpa_sm *sm)
-  */
- void wpa_sm_notify_assoc(struct wpa_sm *sm, const u8 *bssid)
- {
--	int clear_ptk = 1;
-+	int clear_keys = 1;
- 
- 	if (sm == NULL)
- 		return;
-@@ -2477,7 +2515,7 @@ void wpa_sm_notify_assoc(struct wpa_sm *
- 		/* Prepare for the next transition */
- 		wpa_ft_prepare_auth_request(sm, NULL);
- 
--		clear_ptk = 0;
-+		clear_keys = 0;
- 	}
- #endif /* CONFIG_IEEE80211R */
- #ifdef CONFIG_FILS
-@@ -2487,11 +2525,11 @@ void wpa_sm_notify_assoc(struct wpa_sm *
- 		 * AUTHENTICATED state to get the EAPOL port Authorized.
- 		 */
- 		wpa_supplicant_key_neg_complete(sm, sm->bssid, 1);
--		clear_ptk = 0;
-+		clear_keys = 0;
- 	}
- #endif /* CONFIG_FILS */
- 
--	if (clear_ptk) {
-+	if (clear_keys) {
- 		/*
- 		 * IEEE 802.11, 8.4.10: Delete PTK SA on (re)association if
- 		 * this is not part of a Fast BSS Transition.
-@@ -2501,6 +2539,10 @@ void wpa_sm_notify_assoc(struct wpa_sm *
- 		os_memset(&sm->ptk, 0, sizeof(sm->ptk));
- 		sm->tptk_set = 0;
- 		os_memset(&sm->tptk, 0, sizeof(sm->tptk));
-+		os_memset(&sm->gtk, 0, sizeof(sm->gtk));
-+#ifdef CONFIG_IEEE80211W
-+		os_memset(&sm->igtk, 0, sizeof(sm->igtk));
-+#endif /* CONFIG_IEEE80211W */
- 	}
- 
- #ifdef CONFIG_TDLS
-@@ -3052,6 +3094,10 @@ void wpa_sm_drop_sa(struct wpa_sm *sm)
- 	os_memset(sm->pmk, 0, sizeof(sm->pmk));
- 	os_memset(&sm->ptk, 0, sizeof(sm->ptk));
- 	os_memset(&sm->tptk, 0, sizeof(sm->tptk));
-+	os_memset(&sm->gtk, 0, sizeof(sm->gtk));
-+#ifdef CONFIG_IEEE80211W
-+	os_memset(&sm->igtk, 0, sizeof(sm->igtk));
-+#endif /* CONFIG_IEEE80211W */
- #ifdef CONFIG_IEEE80211R
- 	os_memset(sm->xxkey, 0, sizeof(sm->xxkey));
- 	os_memset(sm->pmk_r0, 0, sizeof(sm->pmk_r0));
-@@ -3124,29 +3170,11 @@ int wpa_wnmsleep_install_key(struct wpa_
- 		os_memset(&gd, 0, sizeof(gd));
- #ifdef CONFIG_IEEE80211W
- 	} else if (subelem_id == WNM_SLEEP_SUBELEM_IGTK) {
--		struct wpa_igtk_kde igd;
--		u16 keyidx;
-+		const struct wpa_igtk_kde *igtk;
- 
--		os_memset(&igd, 0, sizeof(igd));
--		keylen = wpa_cipher_key_len(sm->mgmt_group_cipher);
--		os_memcpy(igd.keyid, buf + 2, 2);
--		os_memcpy(igd.pn, buf + 4, 6);
--
--		keyidx = WPA_GET_LE16(igd.keyid);
--		os_memcpy(igd.igtk, buf + 10, keylen);
--
--		wpa_hexdump_key(MSG_DEBUG, "Install IGTK (WNM SLEEP)",
--				igd.igtk, keylen);
--		if (wpa_sm_set_key(sm, wpa_cipher_to_alg(sm->mgmt_group_cipher),
--				   broadcast_ether_addr,
--				   keyidx, 0, igd.pn, sizeof(igd.pn),
--				   igd.igtk, keylen) < 0) {
--			wpa_printf(MSG_DEBUG, "Failed to install the IGTK in "
--				   "WNM mode");
--			os_memset(&igd, 0, sizeof(igd));
-+		igtk = (const struct wpa_igtk_kde *) (buf + 2);
-+		if (wpa_supplicant_install_igtk(sm, igtk) < 0)
- 			return -1;
--		}
--		os_memset(&igd, 0, sizeof(igd));
- #endif /* CONFIG_IEEE80211W */
- 	} else {
- 		wpa_printf(MSG_DEBUG, "Unknown element id");
---- a/src/rsn_supp/wpa_i.h
-+++ b/src/rsn_supp/wpa_i.h
-@@ -31,6 +31,10 @@ struct wpa_sm {
- 	u8 rx_replay_counter[WPA_REPLAY_COUNTER_LEN];
- 	int rx_replay_counter_set;
- 	u8 request_counter[WPA_REPLAY_COUNTER_LEN];
-+	struct wpa_gtk gtk;
-+#ifdef CONFIG_IEEE80211W
-+	struct wpa_igtk igtk;
-+#endif /* CONFIG_IEEE80211W */
- 
- 	struct eapol_sm *eapol; /* EAPOL state machine from upper level code */
- 
diff --git a/package/network/services/hostapd/patches/007-Extend-protection-of-GTK-IGTK-reinstallation-of-WNM-.patch b/package/network/services/hostapd/patches/007-Extend-protection-of-GTK-IGTK-reinstallation-of-WNM-.patch
deleted file mode 100644
index 650bf43e9144842fb8f082f404247f9ad1250194..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/007-Extend-protection-of-GTK-IGTK-reinstallation-of-WNM-.patch
+++ /dev/null
@@ -1,173 +0,0 @@
-From: Jouni Malinen <j@w1.fi>
-Date: Sun, 1 Oct 2017 12:12:24 +0300
-Subject: [PATCH] Extend protection of GTK/IGTK reinstallation of WNM-Sleep
- Mode cases
-
-This extends the protection to track last configured GTK/IGTK value
-separately from EAPOL-Key frames and WNM-Sleep Mode frames to cover a
-corner case where these two different mechanisms may get used when the
-GTK/IGTK has changed and tracking a single value is not sufficient to
-detect a possible key reconfiguration.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
-
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -780,14 +780,17 @@ struct wpa_gtk_data {
- 
- static int wpa_supplicant_install_gtk(struct wpa_sm *sm,
- 				      const struct wpa_gtk_data *gd,
--				      const u8 *key_rsc)
-+				      const u8 *key_rsc, int wnm_sleep)
- {
- 	const u8 *_gtk = gd->gtk;
- 	u8 gtk_buf[32];
- 
- 	/* Detect possible key reinstallation */
--	if (sm->gtk.gtk_len == (size_t) gd->gtk_len &&
--	    os_memcmp(sm->gtk.gtk, gd->gtk, sm->gtk.gtk_len) == 0) {
-+	if ((sm->gtk.gtk_len == (size_t) gd->gtk_len &&
-+	     os_memcmp(sm->gtk.gtk, gd->gtk, sm->gtk.gtk_len) == 0) ||
-+	    (sm->gtk_wnm_sleep.gtk_len == (size_t) gd->gtk_len &&
-+	     os_memcmp(sm->gtk_wnm_sleep.gtk, gd->gtk,
-+		       sm->gtk_wnm_sleep.gtk_len) == 0)) {
- 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
- 			"WPA: Not reinstalling already in-use GTK to the driver (keyidx=%d tx=%d len=%d)",
- 			gd->keyidx, gd->tx, gd->gtk_len);
-@@ -828,8 +831,14 @@ static int wpa_supplicant_install_gtk(st
- 	}
- 	os_memset(gtk_buf, 0, sizeof(gtk_buf));
- 
--	sm->gtk.gtk_len = gd->gtk_len;
--	os_memcpy(sm->gtk.gtk, gd->gtk, sm->gtk.gtk_len);
-+	if (wnm_sleep) {
-+		sm->gtk_wnm_sleep.gtk_len = gd->gtk_len;
-+		os_memcpy(sm->gtk_wnm_sleep.gtk, gd->gtk,
-+			  sm->gtk_wnm_sleep.gtk_len);
-+	} else {
-+		sm->gtk.gtk_len = gd->gtk_len;
-+		os_memcpy(sm->gtk.gtk, gd->gtk, sm->gtk.gtk_len);
-+	}
- 
- 	return 0;
- }
-@@ -923,7 +932,7 @@ static int wpa_supplicant_pairwise_gtk(s
- 	    (wpa_supplicant_check_group_cipher(sm, sm->group_cipher,
- 					       gtk_len, gtk_len,
- 					       &gd.key_rsc_len, &gd.alg) ||
--	     wpa_supplicant_install_gtk(sm, &gd, key_rsc))) {
-+	     wpa_supplicant_install_gtk(sm, &gd, key_rsc, 0))) {
- 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
- 			"RSN: Failed to install GTK");
- 		os_memset(&gd, 0, sizeof(gd));
-@@ -939,14 +948,18 @@ static int wpa_supplicant_pairwise_gtk(s
- 
- #ifdef CONFIG_IEEE80211W
- static int wpa_supplicant_install_igtk(struct wpa_sm *sm,
--				       const struct wpa_igtk_kde *igtk)
-+				       const struct wpa_igtk_kde *igtk,
-+				       int wnm_sleep)
- {
- 	size_t len = wpa_cipher_key_len(sm->mgmt_group_cipher);
- 	u16 keyidx = WPA_GET_LE16(igtk->keyid);
- 
- 	/* Detect possible key reinstallation */
--	if (sm->igtk.igtk_len == len &&
--	    os_memcmp(sm->igtk.igtk, igtk->igtk, sm->igtk.igtk_len) == 0) {
-+	if ((sm->igtk.igtk_len == len &&
-+	     os_memcmp(sm->igtk.igtk, igtk->igtk, sm->igtk.igtk_len) == 0) ||
-+	    (sm->igtk_wnm_sleep.igtk_len == len &&
-+	     os_memcmp(sm->igtk_wnm_sleep.igtk, igtk->igtk,
-+		       sm->igtk_wnm_sleep.igtk_len) == 0)) {
- 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
- 			"WPA: Not reinstalling already in-use IGTK to the driver (keyidx=%d)",
- 			keyidx);
-@@ -971,8 +984,14 @@ static int wpa_supplicant_install_igtk(s
- 		return -1;
- 	}
- 
--	sm->igtk.igtk_len = len;
--	os_memcpy(sm->igtk.igtk, igtk->igtk, sm->igtk.igtk_len);
-+	if (wnm_sleep) {
-+		sm->igtk_wnm_sleep.igtk_len = len;
-+		os_memcpy(sm->igtk_wnm_sleep.igtk, igtk->igtk,
-+			  sm->igtk_wnm_sleep.igtk_len);
-+	} else {
-+		sm->igtk.igtk_len = len;
-+		os_memcpy(sm->igtk.igtk, igtk->igtk, sm->igtk.igtk_len);
-+	}
- 
- 	return 0;
- }
-@@ -995,7 +1014,7 @@ static int ieee80211w_set_keys(struct wp
- 			return -1;
- 
- 		igtk = (const struct wpa_igtk_kde *) ie->igtk;
--		if (wpa_supplicant_install_igtk(sm, igtk) < 0)
-+		if (wpa_supplicant_install_igtk(sm, igtk, 0) < 0)
- 			return -1;
- 	}
- 
-@@ -1641,7 +1660,7 @@ static void wpa_supplicant_process_1_of_
- 	if (wpa_supplicant_rsc_relaxation(sm, key->key_rsc))
- 		key_rsc = null_rsc;
- 
--	if (wpa_supplicant_install_gtk(sm, &gd, key_rsc) ||
-+	if (wpa_supplicant_install_gtk(sm, &gd, key_rsc, 0) ||
- 	    wpa_supplicant_send_2_of_2(sm, key, ver, key_info) < 0)
- 		goto failed;
- 	os_memset(&gd, 0, sizeof(gd));
-@@ -2540,8 +2559,10 @@ void wpa_sm_notify_assoc(struct wpa_sm *
- 		sm->tptk_set = 0;
- 		os_memset(&sm->tptk, 0, sizeof(sm->tptk));
- 		os_memset(&sm->gtk, 0, sizeof(sm->gtk));
-+		os_memset(&sm->gtk_wnm_sleep, 0, sizeof(sm->gtk_wnm_sleep));
- #ifdef CONFIG_IEEE80211W
- 		os_memset(&sm->igtk, 0, sizeof(sm->igtk));
-+		os_memset(&sm->igtk_wnm_sleep, 0, sizeof(sm->igtk_wnm_sleep));
- #endif /* CONFIG_IEEE80211W */
- 	}
- 
-@@ -3095,8 +3116,10 @@ void wpa_sm_drop_sa(struct wpa_sm *sm)
- 	os_memset(&sm->ptk, 0, sizeof(sm->ptk));
- 	os_memset(&sm->tptk, 0, sizeof(sm->tptk));
- 	os_memset(&sm->gtk, 0, sizeof(sm->gtk));
-+	os_memset(&sm->gtk_wnm_sleep, 0, sizeof(sm->gtk_wnm_sleep));
- #ifdef CONFIG_IEEE80211W
- 	os_memset(&sm->igtk, 0, sizeof(sm->igtk));
-+	os_memset(&sm->igtk_wnm_sleep, 0, sizeof(sm->igtk_wnm_sleep));
- #endif /* CONFIG_IEEE80211W */
- #ifdef CONFIG_IEEE80211R
- 	os_memset(sm->xxkey, 0, sizeof(sm->xxkey));
-@@ -3161,7 +3184,7 @@ int wpa_wnmsleep_install_key(struct wpa_
- 
- 		wpa_hexdump_key(MSG_DEBUG, "Install GTK (WNM SLEEP)",
- 				gd.gtk, gd.gtk_len);
--		if (wpa_supplicant_install_gtk(sm, &gd, key_rsc)) {
-+		if (wpa_supplicant_install_gtk(sm, &gd, key_rsc, 1)) {
- 			os_memset(&gd, 0, sizeof(gd));
- 			wpa_printf(MSG_DEBUG, "Failed to install the GTK in "
- 				   "WNM mode");
-@@ -3173,7 +3196,7 @@ int wpa_wnmsleep_install_key(struct wpa_
- 		const struct wpa_igtk_kde *igtk;
- 
- 		igtk = (const struct wpa_igtk_kde *) (buf + 2);
--		if (wpa_supplicant_install_igtk(sm, igtk) < 0)
-+		if (wpa_supplicant_install_igtk(sm, igtk, 1) < 0)
- 			return -1;
- #endif /* CONFIG_IEEE80211W */
- 	} else {
---- a/src/rsn_supp/wpa_i.h
-+++ b/src/rsn_supp/wpa_i.h
-@@ -32,8 +32,10 @@ struct wpa_sm {
- 	int rx_replay_counter_set;
- 	u8 request_counter[WPA_REPLAY_COUNTER_LEN];
- 	struct wpa_gtk gtk;
-+	struct wpa_gtk gtk_wnm_sleep;
- #ifdef CONFIG_IEEE80211W
- 	struct wpa_igtk igtk;
-+	struct wpa_igtk igtk_wnm_sleep;
- #endif /* CONFIG_IEEE80211W */
- 
- 	struct eapol_sm *eapol; /* EAPOL state machine from upper level code */
diff --git a/package/network/services/hostapd/patches/008-Prevent-installation-of-an-all-zero-TK.patch b/package/network/services/hostapd/patches/008-Prevent-installation-of-an-all-zero-TK.patch
deleted file mode 100644
index e0f1773f2958c05af72aff67845d159f1e1c52b9..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/008-Prevent-installation-of-an-all-zero-TK.patch
+++ /dev/null
@@ -1,65 +0,0 @@
-From: Mathy Vanhoef <Mathy.Vanhoef@cs.kuleuven.be>
-Date: Fri, 29 Sep 2017 04:22:51 +0200
-Subject: [PATCH] Prevent installation of an all-zero TK
-
-Properly track whether a PTK has already been installed to the driver
-and the TK part cleared from memory. This prevents an attacker from
-trying to trick the client into installing an all-zero TK.
-
-This fixes the earlier fix in commit
-ad00d64e7d8827b3cebd665a0ceb08adabf15e1e ('Fix TK configuration to the
-driver in EAPOL-Key 3/4 retry case') which did not take into account
-possibility of an extra message 1/4 showing up between retries of
-message 3/4.
-
-Signed-off-by: Mathy Vanhoef <Mathy.Vanhoef@cs.kuleuven.be>
----
-
---- a/src/common/wpa_common.h
-+++ b/src/common/wpa_common.h
-@@ -205,6 +205,7 @@ struct wpa_ptk {
- 	size_t kck_len;
- 	size_t kek_len;
- 	size_t tk_len;
-+	int installed; /* 1 if key has already been installed to driver */
- };
- 
- struct wpa_gtk {
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -581,7 +581,6 @@ static void wpa_supplicant_process_1_of_
- 		os_memset(buf, 0, sizeof(buf));
- 	}
- 	sm->tptk_set = 1;
--	sm->tk_to_set = 1;
- 
- 	kde = sm->assoc_wpa_ie;
- 	kde_len = sm->assoc_wpa_ie_len;
-@@ -686,7 +685,7 @@ static int wpa_supplicant_install_ptk(st
- 	enum wpa_alg alg;
- 	const u8 *key_rsc;
- 
--	if (!sm->tk_to_set) {
-+	if (sm->ptk.installed) {
- 		wpa_dbg(sm->ctx->msg_ctx, MSG_DEBUG,
- 			"WPA: Do not re-install same PTK to the driver");
- 		return 0;
-@@ -730,7 +729,7 @@ static int wpa_supplicant_install_ptk(st
- 
- 	/* TK is not needed anymore in supplicant */
- 	os_memset(sm->ptk.tk, 0, WPA_TK_MAX_LEN);
--	sm->tk_to_set = 0;
-+	sm->ptk.installed = 1;
- 
- 	if (sm->wpa_ptk_rekey) {
- 		eloop_cancel_timeout(wpa_sm_rekey_ptk, sm, NULL);
---- a/src/rsn_supp/wpa_i.h
-+++ b/src/rsn_supp/wpa_i.h
-@@ -24,7 +24,6 @@ struct wpa_sm {
- 	struct wpa_ptk ptk, tptk;
- 	int ptk_set, tptk_set;
- 	unsigned int msg_3_of_4_ok:1;
--	unsigned int tk_to_set:1;
- 	u8 snonce[WPA_NONCE_LEN];
- 	u8 anonce[WPA_NONCE_LEN]; /* ANonce from the last 1/4 msg */
- 	int renew_snonce;
diff --git a/package/network/services/hostapd/patches/009-Fix-PTK-rekeying-to-generate-a-new-ANonce.patch b/package/network/services/hostapd/patches/009-Fix-PTK-rekeying-to-generate-a-new-ANonce.patch
deleted file mode 100644
index 8d9bd42ace18571c3ac5286f07b7631d13e66b7a..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/009-Fix-PTK-rekeying-to-generate-a-new-ANonce.patch
+++ /dev/null
@@ -1,56 +0,0 @@
-From: Jouni Malinen <j@w1.fi>
-Date: Sun, 1 Oct 2017 12:32:57 +0300
-Subject: [PATCH] Fix PTK rekeying to generate a new ANonce
-
-The Authenticator state machine path for PTK rekeying ended up bypassing
-the AUTHENTICATION2 state where a new ANonce is generated when going
-directly to the PTKSTART state since there is no need to try to
-determine the PMK again in such a case. This is far from ideal since the
-new PTK would depend on a new nonce only from the supplicant.
-
-Fix this by generating a new ANonce when moving to the PTKSTART state
-for the purpose of starting new 4-way handshake to rekey PTK.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
-
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -1912,6 +1912,21 @@ SM_STATE(WPA_PTK, AUTHENTICATION2)
- }
- 
- 
-+static int wpa_auth_sm_ptk_update(struct wpa_state_machine *sm)
-+{
-+	if (random_get_bytes(sm->ANonce, WPA_NONCE_LEN)) {
-+		wpa_printf(MSG_ERROR,
-+			   "WPA: Failed to get random data for ANonce");
-+		sm->Disconnect = TRUE;
-+		return -1;
-+	}
-+	wpa_hexdump(MSG_DEBUG, "WPA: Assign new ANonce", sm->ANonce,
-+		    WPA_NONCE_LEN);
-+	sm->TimeoutCtr = 0;
-+	return 0;
-+}
-+
-+
- SM_STATE(WPA_PTK, INITPMK)
- {
- 	u8 msk[2 * PMK_LEN];
-@@ -2932,9 +2947,12 @@ SM_STEP(WPA_PTK)
- 		SM_ENTER(WPA_PTK, AUTHENTICATION);
- 	else if (sm->ReAuthenticationRequest)
- 		SM_ENTER(WPA_PTK, AUTHENTICATION2);
--	else if (sm->PTKRequest)
--		SM_ENTER(WPA_PTK, PTKSTART);
--	else switch (sm->wpa_ptk_state) {
-+	else if (sm->PTKRequest) {
-+		if (wpa_auth_sm_ptk_update(sm) < 0)
-+			SM_ENTER(WPA_PTK, DISCONNECTED);
-+		else
-+			SM_ENTER(WPA_PTK, PTKSTART);
-+	} else switch (sm->wpa_ptk_state) {
- 	case WPA_PTK_INITIALIZE:
- 		break;
- 	case WPA_PTK_DISCONNECT:
diff --git a/package/network/services/hostapd/patches/010-TDLS-Reject-TPK-TK-reconfiguration.patch b/package/network/services/hostapd/patches/010-TDLS-Reject-TPK-TK-reconfiguration.patch
deleted file mode 100644
index d6e500b11b8383262a77de182dc903ff003ee56d..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/010-TDLS-Reject-TPK-TK-reconfiguration.patch
+++ /dev/null
@@ -1,124 +0,0 @@
-From: Jouni Malinen <j@w1.fi>
-Date: Fri, 22 Sep 2017 11:03:15 +0300
-Subject: [PATCH] TDLS: Reject TPK-TK reconfiguration
-
-Do not try to reconfigure the same TPK-TK to the driver after it has
-been successfully configured. This is an explicit check to avoid issues
-related to resetting the TX/RX packet number. There was already a check
-for this for TPK M2 (retries of that message are ignored completely), so
-that behavior does not get modified.
-
-For TPK M3, the TPK-TK could have been reconfigured, but that was
-followed by immediate teardown of the link due to an issue in updating
-the STA entry. Furthermore, for TDLS with any real security (i.e.,
-ignoring open/WEP), the TPK message exchange is protected on the AP path
-and simple replay attacks are not feasible.
-
-As an additional corner case, make sure the local nonce gets updated if
-the peer uses a very unlikely "random nonce" of all zeros.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
-
---- a/src/rsn_supp/tdls.c
-+++ b/src/rsn_supp/tdls.c
-@@ -112,6 +112,7 @@ struct wpa_tdls_peer {
- 		u8 tk[16]; /* TPK-TK; assuming only CCMP will be used */
- 	} tpk;
- 	int tpk_set;
-+	int tk_set; /* TPK-TK configured to the driver */
- 	int tpk_success;
- 	int tpk_in_progress;
- 
-@@ -192,6 +193,20 @@ static int wpa_tdls_set_key(struct wpa_s
- 	u8 rsc[6];
- 	enum wpa_alg alg;
- 
-+	if (peer->tk_set) {
-+		/*
-+		 * This same TPK-TK has already been configured to the driver
-+		 * and this new configuration attempt (likely due to an
-+		 * unexpected retransmitted frame) would result in clearing
-+		 * the TX/RX sequence number which can break security, so must
-+		 * not allow that to happen.
-+		 */
-+		wpa_printf(MSG_INFO, "TDLS: TPK-TK for the peer " MACSTR
-+			   " has already been configured to the driver - do not reconfigure",
-+			   MAC2STR(peer->addr));
-+		return -1;
-+	}
-+
- 	os_memset(rsc, 0, 6);
- 
- 	switch (peer->cipher) {
-@@ -209,12 +224,15 @@ static int wpa_tdls_set_key(struct wpa_s
- 		return -1;
- 	}
- 
-+	wpa_printf(MSG_DEBUG, "TDLS: Configure pairwise key for peer " MACSTR,
-+		   MAC2STR(peer->addr));
- 	if (wpa_sm_set_key(sm, alg, peer->addr, -1, 1,
- 			   rsc, sizeof(rsc), peer->tpk.tk, key_len) < 0) {
- 		wpa_printf(MSG_WARNING, "TDLS: Failed to set TPK to the "
- 			   "driver");
- 		return -1;
- 	}
-+	peer->tk_set = 1;
- 	return 0;
- }
- 
-@@ -696,7 +714,7 @@ static void wpa_tdls_peer_clear(struct w
- 	peer->cipher = 0;
- 	peer->qos_info = 0;
- 	peer->wmm_capable = 0;
--	peer->tpk_set = peer->tpk_success = 0;
-+	peer->tk_set = peer->tpk_set = peer->tpk_success = 0;
- 	peer->chan_switch_enabled = 0;
- 	os_memset(&peer->tpk, 0, sizeof(peer->tpk));
- 	os_memset(peer->inonce, 0, WPA_NONCE_LEN);
-@@ -1159,6 +1177,7 @@ skip_rsnie:
- 		wpa_tdls_peer_free(sm, peer);
- 		return -1;
- 	}
-+	peer->tk_set = 0; /* A new nonce results in a new TK */
- 	wpa_hexdump(MSG_DEBUG, "TDLS: Initiator Nonce for TPK handshake",
- 		    peer->inonce, WPA_NONCE_LEN);
- 	os_memcpy(ftie->Snonce, peer->inonce, WPA_NONCE_LEN);
-@@ -1751,6 +1770,19 @@ static int wpa_tdls_addset_peer(struct w
- }
- 
- 
-+static int tdls_nonce_set(const u8 *nonce)
-+{
-+	int i;
-+
-+	for (i = 0; i < WPA_NONCE_LEN; i++) {
-+		if (nonce[i])
-+			return 1;
-+	}
-+
-+	return 0;
-+}
-+
-+
- static int wpa_tdls_process_tpk_m1(struct wpa_sm *sm, const u8 *src_addr,
- 				   const u8 *buf, size_t len)
- {
-@@ -2004,7 +2036,8 @@ skip_rsn:
- 	peer->rsnie_i_len = kde.rsn_ie_len;
- 	peer->cipher = cipher;
- 
--	if (os_memcmp(peer->inonce, ftie->Snonce, WPA_NONCE_LEN) != 0) {
-+	if (os_memcmp(peer->inonce, ftie->Snonce, WPA_NONCE_LEN) != 0 ||
-+	    !tdls_nonce_set(peer->inonce)) {
- 		/*
- 		 * There is no point in updating the RNonce for every obtained
- 		 * TPK M1 frame (e.g., retransmission due to timeout) with the
-@@ -2020,6 +2053,7 @@ skip_rsn:
- 				"TDLS: Failed to get random data for responder nonce");
- 			goto error;
- 		}
-+		peer->tk_set = 0; /* A new nonce results in a new TK */
- 	}
- 
- #if 0
diff --git a/package/network/services/hostapd/patches/011-WNM-Ignore-WNM-Sleep-Mode-Response-without-pending-r.patch b/package/network/services/hostapd/patches/011-WNM-Ignore-WNM-Sleep-Mode-Response-without-pending-r.patch
deleted file mode 100644
index 13d78b8cbdea0203c968691e3635d5d86efe64c1..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/011-WNM-Ignore-WNM-Sleep-Mode-Response-without-pending-r.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-From: Jouni Malinen <j@w1.fi>
-Date: Fri, 22 Sep 2017 11:25:02 +0300
-Subject: [PATCH] WNM: Ignore WNM-Sleep Mode Response without pending
- request
-
-Commit 03ed0a52393710be6bdae657d1b36efa146520e5 ('WNM: Ignore WNM-Sleep
-Mode Response if WNM-Sleep Mode has not been used') started ignoring the
-response when no WNM-Sleep Mode Request had been used during the
-association. This can be made tighter by clearing the used flag when
-successfully processing a response. This adds an additional layer of
-protection against unexpected retransmissions of the response frame.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
-
---- a/wpa_supplicant/wnm_sta.c
-+++ b/wpa_supplicant/wnm_sta.c
-@@ -260,7 +260,7 @@ static void ieee802_11_rx_wnmsleep_resp(
- 
- 	if (!wpa_s->wnmsleep_used) {
- 		wpa_printf(MSG_DEBUG,
--			   "WNM: Ignore WNM-Sleep Mode Response frame since WNM-Sleep Mode has not been used in this association");
-+			   "WNM: Ignore WNM-Sleep Mode Response frame since WNM-Sleep Mode operation has not been requested");
- 		return;
- 	}
- 
-@@ -299,6 +299,8 @@ static void ieee802_11_rx_wnmsleep_resp(
- 		return;
- 	}
- 
-+	wpa_s->wnmsleep_used = 0;
-+
- 	if (wnmsleep_ie->status == WNM_STATUS_SLEEP_ACCEPT ||
- 	    wnmsleep_ie->status == WNM_STATUS_SLEEP_EXIT_ACCEPT_GTK_UPDATE) {
- 		wpa_printf(MSG_DEBUG, "Successfully recv WNM-Sleep Response "
diff --git a/package/network/services/hostapd/patches/012-FT-Do-not-allow-multiple-Reassociation-Response-fram.patch b/package/network/services/hostapd/patches/012-FT-Do-not-allow-multiple-Reassociation-Response-fram.patch
deleted file mode 100644
index 12904faf1fde4cf4ca7b813f500ff86a5ba718cd..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/012-FT-Do-not-allow-multiple-Reassociation-Response-fram.patch
+++ /dev/null
@@ -1,68 +0,0 @@
-From: Jouni Malinen <j@w1.fi>
-Date: Fri, 22 Sep 2017 12:06:37 +0300
-Subject: [PATCH] FT: Do not allow multiple Reassociation Response frames
-
-The driver is expected to not report a second association event without
-the station having explicitly request a new association. As such, this
-case should not be reachable. However, since reconfiguring the same
-pairwise or group keys to the driver could result in nonce reuse issues,
-be extra careful here and do an additional state check to avoid this
-even if the local driver ends up somehow accepting an unexpected
-Reassociation Response frame.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
-
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -2568,6 +2568,9 @@ void wpa_sm_notify_assoc(struct wpa_sm *
- #ifdef CONFIG_TDLS
- 	wpa_tdls_assoc(sm);
- #endif /* CONFIG_TDLS */
-+#ifdef CONFIG_IEEE80211R
-+	sm->ft_reassoc_completed = 0;
-+#endif /* CONFIG_IEEE80211R */
- 
- #ifdef CONFIG_P2P
- 	os_memset(sm->p2p_ip_addr, 0, sizeof(sm->p2p_ip_addr));
---- a/src/rsn_supp/wpa_ft.c
-+++ b/src/rsn_supp/wpa_ft.c
-@@ -153,6 +153,7 @@ static u8 * wpa_ft_gen_req_ies(struct wp
- 	u16 capab;
- 
- 	sm->ft_completed = 0;
-+	sm->ft_reassoc_completed = 0;
- 
- 	buf_len = 2 + sizeof(struct rsn_mdie) + 2 + sizeof(struct rsn_ftie) +
- 		2 + sm->r0kh_id_len + ric_ies_len + 100;
-@@ -681,6 +682,11 @@ int wpa_ft_validate_reassoc_resp(struct
- 		return -1;
- 	}
- 
-+	if (sm->ft_reassoc_completed) {
-+		wpa_printf(MSG_DEBUG, "FT: Reassociation has already been completed for this FT protocol instance - ignore unexpected retransmission");
-+		return 0;
-+	}
-+
- 	if (wpa_ft_parse_ies(ies, ies_len, &parse) < 0) {
- 		wpa_printf(MSG_DEBUG, "FT: Failed to parse IEs");
- 		return -1;
-@@ -781,6 +787,8 @@ int wpa_ft_validate_reassoc_resp(struct
- 		return -1;
- 	}
- 
-+	sm->ft_reassoc_completed = 1;
-+
- 	if (wpa_ft_process_gtk_subelem(sm, parse.gtk, parse.gtk_len) < 0)
- 		return -1;
- 
---- a/src/rsn_supp/wpa_i.h
-+++ b/src/rsn_supp/wpa_i.h
-@@ -128,6 +128,7 @@ struct wpa_sm {
- 	size_t r0kh_id_len;
- 	u8 r1kh_id[FT_R1KH_ID_LEN];
- 	int ft_completed;
-+	int ft_reassoc_completed;
- 	int over_the_ds_in_progress;
- 	u8 target_ap[ETH_ALEN]; /* over-the-DS target AP */
- 	int set_ptk_after_assoc;
diff --git a/package/network/services/hostapd/patches/013-Add-hostapd-options-wpa_group_update_count-and-wpa_p.patch b/package/network/services/hostapd/patches/013-Add-hostapd-options-wpa_group_update_count-and-wpa_p.patch
deleted file mode 100644
index 623c2be3459b34ee1fdc9f6ef54d4db5249663b5..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/013-Add-hostapd-options-wpa_group_update_count-and-wpa_p.patch
+++ /dev/null
@@ -1,305 +0,0 @@
-From 41f140d38617e1fd3fa88c1667c1bce0cad79224 Mon Sep 17 00:00:00 2001
-From: =?UTF-8?q?G=C3=BCnther=20Kelleter?= <guenther.kelleter@devolo.de>
-Date: Thu, 5 Jan 2017 17:00:33 +0100
-Subject: [PATCH] Add hostapd options wpa_group_update_count and
- wpa_pairwise_update_count
-MIME-Version: 1.0
-Content-Type: text/plain; charset=UTF-8
-Content-Transfer-Encoding: 8bit
-
-wpa_group_update_count and wpa_pairwise_update_count can now be used to
-set the GTK and PTK rekey retry limits (dot11RSNAConfigGroupUpdateCount
-and dot11RSNAConfigPairwiseUpdateCount). Defaults set to current
-hardcoded value (4).
-
-Some stations may suffer from frequent deauthentications due to GTK
-rekey failures: EAPOL 1/2 frame is not answered during the total timeout
-period of currently ~3.5 seconds. For example, a Galaxy S6 with Android
-6.0.1 appears to go into power save mode for up to 5 seconds. Increasing
-wpa_group_update_count to 6 fixed this issue.
-
-Signed-off-by: Günther Kelleter <guenther.kelleter@devolo.de>
----
- hostapd/config_file.c     | 22 ++++++++++++++++++++++
- hostapd/hostapd.conf      | 11 +++++++++++
- src/ap/ap_config.c        |  2 ++
- src/ap/ap_config.h        |  2 ++
- src/ap/wpa_auth.c         | 37 ++++++++++++++++++-------------------
- src/ap/wpa_auth.h         |  2 ++
- src/ap/wpa_auth_glue.c    |  2 ++
- src/ap/wpa_auth_i.h       |  4 ++--
- wpa_supplicant/ibss_rsn.c |  2 ++
- wpa_supplicant/mesh_rsn.c |  2 ++
- 10 files changed, 65 insertions(+), 21 deletions(-)
-
-diff --git a/hostapd/config_file.c b/hostapd/config_file.c
-index 8cfa198c3..02693a5b1 100644
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2489,6 +2489,28 @@ static int hostapd_config_fill(struct hostapd_config *conf,
- 		bss->wpa_gmk_rekey = atoi(pos);
- 	} else if (os_strcmp(buf, "wpa_ptk_rekey") == 0) {
- 		bss->wpa_ptk_rekey = atoi(pos);
-+	} else if (os_strcmp(buf, "wpa_group_update_count") == 0) {
-+		char *endp;
-+		unsigned long val = strtoul(pos, &endp, 0);
-+
-+		if (*endp || val < 1 || val > (u32) -1) {
-+			wpa_printf(MSG_ERROR,
-+				   "Line %d: Invalid wpa_group_update_count=%lu; allowed range 1..4294967295",
-+				   line, val);
-+			return 1;
-+		}
-+		bss->wpa_group_update_count = (u32) val;
-+	} else if (os_strcmp(buf, "wpa_pairwise_update_count") == 0) {
-+		char *endp;
-+		unsigned long val = strtoul(pos, &endp, 0);
-+
-+		if (*endp || val < 1 || val > (u32) -1) {
-+			wpa_printf(MSG_ERROR,
-+				   "Line %d: Invalid wpa_pairwise_update_count=%lu; allowed range 1..4294967295",
-+				   line, val);
-+			return 1;
-+		}
-+		bss->wpa_pairwise_update_count = (u32) val;
- 	} else if (os_strcmp(buf, "wpa_passphrase") == 0) {
- 		int len = os_strlen(pos);
- 		if (len < 8 || len > 63) {
-diff --git a/hostapd/hostapd.conf b/hostapd/hostapd.conf
-index 314f3842b..1fb1bd987 100644
---- a/hostapd/hostapd.conf
-+++ b/hostapd/hostapd.conf
-@@ -1221,6 +1221,11 @@ own_ip_addr=127.0.0.1
- # (dot11RSNAConfigGroupRekeyStrict)
- #wpa_strict_rekey=1
- 
-+# The number of times EAPOL-Key Message 1/2 in the RSN Group Key Handshake is
-+#retried per GTK Handshake attempt. (dot11RSNAConfigGroupUpdateCount)
-+# Range 1..4294967295; default: 4
-+#wpa_group_update_count=4
-+
- # Time interval for rekeying GMK (master key used internally to generate GTKs
- # (in seconds).
- #wpa_gmk_rekey=86400
-@@ -1229,6 +1234,12 @@ own_ip_addr=127.0.0.1
- # PTK to mitigate some attacks against TKIP deficiencies.
- #wpa_ptk_rekey=600
- 
-+# The number of times EAPOL-Key Message 1/4 and Message 3/4 in the RSN 4-Way
-+# Handshake are retried per 4-Way Handshake attempt.
-+# (dot11RSNAConfigPairwiseUpdateCount)
-+# Range 1..4294967295; default: 4
-+#wpa_pairwise_update_count=4
-+
- # Enable IEEE 802.11i/RSN/WPA2 pre-authentication. This is used to speed up
- # roaming be pre-authenticating IEEE 802.1X/EAP part of the full RSN
- # authentication and key handshake before actually associating with a new AP.
-diff --git a/src/ap/ap_config.c b/src/ap/ap_config.c
-index c2b80ad97..9abcab7fb 100644
---- a/src/ap/ap_config.c
-+++ b/src/ap/ap_config.c
-@@ -56,6 +56,8 @@ void hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
- 
- 	bss->wpa_group_rekey = 600;
- 	bss->wpa_gmk_rekey = 86400;
-+	bss->wpa_group_update_count = 4;
-+	bss->wpa_pairwise_update_count = 4;
- 	bss->wpa_key_mgmt = WPA_KEY_MGMT_PSK;
- 	bss->wpa_pairwise = WPA_CIPHER_TKIP;
- 	bss->wpa_group = WPA_CIPHER_TKIP;
-diff --git a/src/ap/ap_config.h b/src/ap/ap_config.h
-index 31b1e7762..7495dc96f 100644
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -330,6 +330,8 @@ struct hostapd_bss_config {
- 	int wpa_strict_rekey;
- 	int wpa_gmk_rekey;
- 	int wpa_ptk_rekey;
-+	u32 wpa_group_update_count;
-+	u32 wpa_pairwise_update_count;
- 	int rsn_pairwise;
- 	int rsn_preauth;
- 	char *rsn_preauth_interfaces;
-diff --git a/src/ap/wpa_auth.c b/src/ap/wpa_auth.c
-index 0bd901fbf..8c082f426 100644
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -60,8 +60,6 @@ static void wpa_group_put(struct wpa_authenticator *wpa_auth,
- 			  struct wpa_group *group);
- static u8 * ieee80211w_kde_add(struct wpa_state_machine *sm, u8 *pos);
- 
--static const u32 dot11RSNAConfigGroupUpdateCount = 4;
--static const u32 dot11RSNAConfigPairwiseUpdateCount = 4;
- static const u32 eapol_key_timeout_first = 100; /* ms */
- static const u32 eapol_key_timeout_subseq = 1000; /* ms */
- static const u32 eapol_key_timeout_first_group = 500; /* ms */
-@@ -1623,7 +1621,7 @@ static void wpa_send_eapol(struct wpa_authenticator *wpa_auth,
- {
- 	int timeout_ms;
- 	int pairwise = key_info & WPA_KEY_INFO_KEY_TYPE;
--	int ctr;
-+	u32 ctr;
- 
- 	if (sm == NULL)
- 		return;
-@@ -1640,7 +1638,7 @@ static void wpa_send_eapol(struct wpa_authenticator *wpa_auth,
- 	if (pairwise && ctr == 1 && !(key_info & WPA_KEY_INFO_MIC))
- 		sm->pending_1_of_4_timeout = 1;
- 	wpa_printf(MSG_DEBUG, "WPA: Use EAPOL-Key timeout of %u ms (retry "
--		   "counter %d)", timeout_ms, ctr);
-+		   "counter %u)", timeout_ms, ctr);
- 	eloop_register_timeout(timeout_ms / 1000, (timeout_ms % 1000) * 1000,
- 			       wpa_send_eapol_timeout, wpa_auth, sm);
- }
-@@ -2002,7 +2000,7 @@ SM_STATE(WPA_PTK, PTKSTART)
- 	sm->alt_snonce_valid = FALSE;
- 
- 	sm->TimeoutCtr++;
--	if (sm->TimeoutCtr > (int) dot11RSNAConfigPairwiseUpdateCount) {
-+	if (sm->TimeoutCtr > sm->wpa_auth->conf.wpa_pairwise_update_count) {
- 		/* No point in sending the EAPOL-Key - we will disconnect
- 		 * immediately following this. */
- 		return;
-@@ -2693,7 +2691,7 @@ SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
- 	sm->TimeoutEvt = FALSE;
- 
- 	sm->TimeoutCtr++;
--	if (sm->TimeoutCtr > (int) dot11RSNAConfigPairwiseUpdateCount) {
-+	if (sm->TimeoutCtr > sm->wpa_auth->conf.wpa_pairwise_update_count) {
- 		/* No point in sending the EAPOL-Key - we will disconnect
- 		 * immediately following this. */
- 		return;
-@@ -2988,11 +2986,12 @@ SM_STEP(WPA_PTK)
- 		    sm->EAPOLKeyPairwise)
- 			SM_ENTER(WPA_PTK, PTKCALCNEGOTIATING);
- 		else if (sm->TimeoutCtr >
--			 (int) dot11RSNAConfigPairwiseUpdateCount) {
-+			 sm->wpa_auth->conf.wpa_pairwise_update_count) {
- 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
--			wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
--					 "PTKSTART: Retry limit %d reached",
--					 dot11RSNAConfigPairwiseUpdateCount);
-+			wpa_auth_vlogger(
-+				sm->wpa_auth, sm->addr, LOGGER_DEBUG,
-+				"PTKSTART: Retry limit %u reached",
-+				sm->wpa_auth->conf.wpa_pairwise_update_count);
- 			SM_ENTER(WPA_PTK, DISCONNECT);
- 		} else if (sm->TimeoutEvt)
- 			SM_ENTER(WPA_PTK, PTKSTART);
-@@ -3016,12 +3015,12 @@ SM_STEP(WPA_PTK)
- 			 sm->EAPOLKeyPairwise && sm->MICVerified)
- 			SM_ENTER(WPA_PTK, PTKINITDONE);
- 		else if (sm->TimeoutCtr >
--			 (int) dot11RSNAConfigPairwiseUpdateCount) {
-+			 sm->wpa_auth->conf.wpa_pairwise_update_count) {
- 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
--			wpa_auth_vlogger(sm->wpa_auth, sm->addr, LOGGER_DEBUG,
--					 "PTKINITNEGOTIATING: Retry limit %d "
--					 "reached",
--					 dot11RSNAConfigPairwiseUpdateCount);
-+			wpa_auth_vlogger(
-+				sm->wpa_auth, sm->addr, LOGGER_DEBUG,
-+				"PTKINITNEGOTIATING: Retry limit %u reached",
-+				sm->wpa_auth->conf.wpa_pairwise_update_count);
- 			SM_ENTER(WPA_PTK, DISCONNECT);
- 		} else if (sm->TimeoutEvt)
- 			SM_ENTER(WPA_PTK, PTKINITNEGOTIATING);
-@@ -3056,7 +3055,7 @@ SM_STATE(WPA_PTK_GROUP, REKEYNEGOTIATING)
- 	SM_ENTRY_MA(WPA_PTK_GROUP, REKEYNEGOTIATING, wpa_ptk_group);
- 
- 	sm->GTimeoutCtr++;
--	if (sm->GTimeoutCtr > (int) dot11RSNAConfigGroupUpdateCount) {
-+	if (sm->GTimeoutCtr > sm->wpa_auth->conf.wpa_group_update_count) {
- 		/* No point in sending the EAPOL-Key - we will disconnect
- 		 * immediately following this. */
- 		return;
-@@ -3154,7 +3153,7 @@ SM_STEP(WPA_PTK_GROUP)
- 		    !sm->EAPOLKeyPairwise && sm->MICVerified)
- 			SM_ENTER(WPA_PTK_GROUP, REKEYESTABLISHED);
- 		else if (sm->GTimeoutCtr >
--			 (int) dot11RSNAConfigGroupUpdateCount)
-+			 sm->wpa_auth->conf.wpa_group_update_count)
- 			SM_ENTER(WPA_PTK_GROUP, KEYERROR);
- 		else if (sm->TimeoutEvt)
- 			SM_ENTER(WPA_PTK_GROUP, REKEYNEGOTIATING);
-@@ -3614,8 +3613,8 @@ int wpa_get_mib(struct wpa_authenticator *wpa_auth, char *buf, size_t buflen)
- 		"dot11RSNAConfigNumberOfGTKSAReplayCounters=0\n",
- 		RSN_VERSION,
- 		!!wpa_auth->conf.wpa_strict_rekey,
--		dot11RSNAConfigGroupUpdateCount,
--		dot11RSNAConfigPairwiseUpdateCount,
-+		wpa_auth->conf.wpa_group_update_count,
-+		wpa_auth->conf.wpa_pairwise_update_count,
- 		wpa_cipher_key_len(wpa_auth->conf.wpa_group) * 8,
- 		dot11RSNAConfigPMKLifetime,
- 		dot11RSNAConfigPMKReauthThreshold,
-diff --git a/src/ap/wpa_auth.h b/src/ap/wpa_auth.h
-index 9cbe3889b..0920a169d 100644
---- a/src/ap/wpa_auth.h
-+++ b/src/ap/wpa_auth.h
-@@ -144,6 +144,8 @@ struct wpa_auth_config {
- 	int wpa_strict_rekey;
- 	int wpa_gmk_rekey;
- 	int wpa_ptk_rekey;
-+	u32 wpa_group_update_count;
-+	u32 wpa_pairwise_update_count;
- 	int rsn_pairwise;
- 	int rsn_preauth;
- 	int eapol_version;
-diff --git a/src/ap/wpa_auth_glue.c b/src/ap/wpa_auth_glue.c
-index 22518a1f1..394f77a66 100644
---- a/src/ap/wpa_auth_glue.c
-+++ b/src/ap/wpa_auth_glue.c
-@@ -41,6 +41,8 @@ static void hostapd_wpa_auth_conf(struct hostapd_bss_config *conf,
- 	wconf->wpa_strict_rekey = conf->wpa_strict_rekey;
- 	wconf->wpa_gmk_rekey = conf->wpa_gmk_rekey;
- 	wconf->wpa_ptk_rekey = conf->wpa_ptk_rekey;
-+	wconf->wpa_group_update_count = conf->wpa_group_update_count;
-+	wconf->wpa_pairwise_update_count = conf->wpa_pairwise_update_count;
- 	wconf->rsn_pairwise = conf->rsn_pairwise;
- 	wconf->rsn_preauth = conf->rsn_preauth;
- 	wconf->eapol_version = conf->eapol_version;
-diff --git a/src/ap/wpa_auth_i.h b/src/ap/wpa_auth_i.h
-index 065a624ad..cda2c5065 100644
---- a/src/ap/wpa_auth_i.h
-+++ b/src/ap/wpa_auth_i.h
-@@ -48,8 +48,8 @@ struct wpa_state_machine {
- 	Boolean AuthenticationRequest;
- 	Boolean ReAuthenticationRequest;
- 	Boolean Disconnect;
--	int TimeoutCtr;
--	int GTimeoutCtr;
-+	u32 TimeoutCtr;
-+	u32 GTimeoutCtr;
- 	Boolean TimeoutEvt;
- 	Boolean EAPOLKeyReceived;
- 	Boolean EAPOLKeyPairwise;
-diff --git a/wpa_supplicant/ibss_rsn.c b/wpa_supplicant/ibss_rsn.c
-index 521a692ba..954061ae4 100644
---- a/wpa_supplicant/ibss_rsn.c
-+++ b/wpa_supplicant/ibss_rsn.c
-@@ -428,6 +428,8 @@ static int ibss_rsn_auth_init_group(struct ibss_rsn *ibss_rsn,
- 	conf.wpa_group = WPA_CIPHER_CCMP;
- 	conf.eapol_version = 2;
- 	conf.wpa_group_rekey = ssid->group_rekey ? ssid->group_rekey : 600;
-+	conf.wpa_group_update_count = 4;
-+	conf.wpa_pairwise_update_count = 4;
- 
- 	ibss_rsn->auth_group = wpa_init(own_addr, &conf, &cb, ibss_rsn);
- 	if (ibss_rsn->auth_group == NULL) {
-diff --git a/wpa_supplicant/mesh_rsn.c b/wpa_supplicant/mesh_rsn.c
-index 33040f30b..628382cbf 100644
---- a/wpa_supplicant/mesh_rsn.c
-+++ b/wpa_supplicant/mesh_rsn.c
-@@ -158,6 +158,8 @@ static int __mesh_rsn_auth_init(struct mesh_rsn *rsn, const u8 *addr,
- 	conf.wpa_group = rsn->group_cipher;
- 	conf.eapol_version = 0;
- 	conf.wpa_group_rekey = -1;
-+	conf.wpa_group_update_count = 4;
-+	conf.wpa_pairwise_update_count = 4;
- #ifdef CONFIG_IEEE80211W
- 	conf.ieee80211w = ieee80211w;
- 	if (ieee80211w != NO_MGMT_FRAME_PROTECTION)
--- 
-2.13.6
-
diff --git a/package/network/services/hostapd/patches/014-WPA-Extra-defense-against-PTK-reinstalls-in-4-way-ha.patch b/package/network/services/hostapd/patches/014-WPA-Extra-defense-against-PTK-reinstalls-in-4-way-ha.patch
deleted file mode 100644
index 40f6b56965ecbf35abca08b5c5e5968e3bb6135b..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/014-WPA-Extra-defense-against-PTK-reinstalls-in-4-way-ha.patch
+++ /dev/null
@@ -1,34 +0,0 @@
-From a00e946c1c9a1f9cc65c72900d2a444ceb1f872e Mon Sep 17 00:00:00 2001
-From: Mathy Vanhoef <Mathy.Vanhoef@cs.kuleuven.be>
-Date: Thu, 5 Oct 2017 23:53:01 +0200
-Subject: [PATCH] WPA: Extra defense against PTK reinstalls in 4-way handshake
-
-Currently, reinstallations of the PTK are prevented by (1) assuring the
-same TPTK is only set once as the PTK, and (2) that one particular PTK
-is only installed once. This patch makes it more explicit that point (1)
-is required to prevent key reinstallations. At the same time, this patch
-hardens wpa_supplicant such that future changes do not accidentally
-break this property.
-
-Signed-off-by: Mathy Vanhoef <Mathy.Vanhoef@cs.kuleuven.be>
----
- src/rsn_supp/wpa.c | 8 ++++++++
- 1 file changed, 8 insertions(+)
-
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -1728,6 +1728,14 @@ static int wpa_supplicant_verify_eapol_k
- 			sm->ptk_set = 1;
- 			os_memcpy(&sm->ptk, &sm->tptk, sizeof(sm->ptk));
- 			os_memset(&sm->tptk, 0, sizeof(sm->tptk));
-+			/*
-+			 * This assures the same TPTK in sm->tptk can never be
-+			 * copied twice to sm->pkt as the new PTK. In
-+			 * combination with the installed flag in the wpa_ptk
-+			 * struct, this assures the same PTK is only installed
-+			 * once.
-+			 */
-+			sm->renew_snonce = 1;
- 		}
- 	}
- 
diff --git a/package/network/services/hostapd/patches/015-Clear-PMK-length-and-check-for-this-when-deriving-PT.patch b/package/network/services/hostapd/patches/015-Clear-PMK-length-and-check-for-this-when-deriving-PT.patch
deleted file mode 100644
index ed7d79ec1b728e92abd08836f418562a6f3243c7..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/015-Clear-PMK-length-and-check-for-this-when-deriving-PT.patch
+++ /dev/null
@@ -1,53 +0,0 @@
-From b488a12948751f57871f09baa345e59b23959a41 Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <j@w1.fi>
-Date: Sun, 8 Oct 2017 13:18:02 +0300
-Subject: [PATCH] Clear PMK length and check for this when deriving PTK
-
-Instead of setting the default PMK length for the cleared PMK, set the
-length to 0 and explicitly check for this when deriving PTK to avoid
-unexpected key derivation with an all-zeroes key should it be possible
-to somehow trigger PTK derivation to happen before PMK derivation.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
- src/common/wpa_common.c | 5 +++++
- src/rsn_supp/wpa.c      | 7 ++++---
- 2 files changed, 9 insertions(+), 3 deletions(-)
-
---- a/src/common/wpa_common.c
-+++ b/src/common/wpa_common.c
-@@ -225,6 +225,11 @@ int wpa_pmk_to_ptk(const u8 *pmk, size_t
- 	u8 tmp[WPA_KCK_MAX_LEN + WPA_KEK_MAX_LEN + WPA_TK_MAX_LEN];
- 	size_t ptk_len;
- 
-+	if (pmk_len == 0) {
-+		wpa_printf(MSG_ERROR, "WPA: No PMK set for PT derivation");
-+		return -1;
-+	}
-+
- 	if (os_memcmp(addr1, addr2, ETH_ALEN) < 0) {
- 		os_memcpy(data, addr1, ETH_ALEN);
- 		os_memcpy(data + ETH_ALEN, addr2, ETH_ALEN);
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -584,7 +584,8 @@ static void wpa_supplicant_process_1_of_
- 	/* Calculate PTK which will be stored as a temporary PTK until it has
- 	 * been verified when processing message 3/4. */
- 	ptk = &sm->tptk;
--	wpa_derive_ptk(sm, src_addr, key, ptk);
-+	if (wpa_derive_ptk(sm, src_addr, key, ptk) < 0)
-+		goto failed;
- 	if (sm->pairwise_cipher == WPA_CIPHER_TKIP) {
- 		u8 buf[8];
- 		/* Supplicant: swap tx/rx Mic keys */
-@@ -2705,8 +2706,8 @@ void wpa_sm_set_pmk_from_pmksa(struct wp
- 		sm->pmk_len = sm->cur_pmksa->pmk_len;
- 		os_memcpy(sm->pmk, sm->cur_pmksa->pmk, sm->pmk_len);
- 	} else {
--		sm->pmk_len = PMK_LEN;
--		os_memset(sm->pmk, 0, PMK_LEN);
-+		sm->pmk_len = 0;
-+		os_memset(sm->pmk, 0, PMK_LEN_MAX);
- 	}
- }
- 
diff --git a/package/network/services/hostapd/patches/016-Optional-AP-side-workaround-for-key-reinstallation-a.patch b/package/network/services/hostapd/patches/016-Optional-AP-side-workaround-for-key-reinstallation-a.patch
deleted file mode 100644
index e413521cd01d1358435ac09b7bf9d567b9368a38..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/016-Optional-AP-side-workaround-for-key-reinstallation-a.patch
+++ /dev/null
@@ -1,221 +0,0 @@
-From 6f234c1e2ee1ede29f2412b7012b3345ed8e52d3 Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <j@w1.fi>
-Date: Mon, 16 Oct 2017 18:37:43 +0300
-Subject: [PATCH] Optional AP side workaround for key reinstallation attacks
-
-This adds a new hostapd configuration parameter
-wpa_disable_eapol_key_retries=1 that can be used to disable
-retransmission of EAPOL-Key frames that are used to install
-keys (EAPOL-Key message 3/4 and group message 1/2). This is
-similar to setting wpa_group_update_count=1 and
-wpa_pairwise_update_count=1, but with no impact to message 1/4
-retries and with extended timeout for messages 4/4 and group
-message 2/2 to avoid causing issues with stations that may use
-aggressive power saving have very long time in replying to the
-EAPOL-Key messages.
-
-This option can be used to work around key reinstallation attacks
-on the station (supplicant) side in cases those station devices
-cannot be updated for some reason. By removing the
-retransmissions the attacker cannot cause key reinstallation with
-a delayed frame transmission. This is related to the station side
-vulnerabilities CVE-2017-13077, CVE-2017-13078, CVE-2017-13079,
-CVE-2017-13080, and CVE-2017-13081.
-
-This workaround might cause interoperability issues and reduced
-robustness of key negotiation especially in environments with
-heavy traffic load due to the number of attempts to perform the
-key exchange is reduced significantly. As such, this workaround
-is disabled by default (unless overridden in build
-configuration). To enable this, set the parameter to 1.
-
-It is also possible to enable this in the build by default by
-adding the following to the build configuration:
-
-CFLAGS += -DDEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES=1
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
- hostapd/config_file.c  |  2 ++
- hostapd/defconfig      |  4 ++++
- hostapd/hostapd.conf   | 24 ++++++++++++++++++++++++
- src/ap/ap_config.c     |  6 ++++++
- src/ap/ap_config.h     |  1 +
- src/ap/wpa_auth.c      | 22 ++++++++++++++++++++--
- src/ap/wpa_auth.h      |  1 +
- src/ap/wpa_auth_glue.c |  2 ++
- 8 files changed, 60 insertions(+), 2 deletions(-)
-
---- a/hostapd/config_file.c
-+++ b/hostapd/config_file.c
-@@ -2515,6 +2515,8 @@ static int hostapd_config_fill(struct ho
- 			return 1;
- 		}
- 		bss->wpa_pairwise_update_count = (u32) val;
-+	} else if (os_strcmp(buf, "wpa_disable_eapol_key_retries") == 0) {
-+		bss->wpa_disable_eapol_key_retries = atoi(pos);
- 	} else if (os_strcmp(buf, "wpa_passphrase") == 0) {
- 		int len = os_strlen(pos);
- 		if (len < 8 || len > 63) {
---- a/hostapd/defconfig
-+++ b/hostapd/defconfig
-@@ -355,3 +355,7 @@ CONFIG_IPV6=y
- # Include internal line edit mode in hostapd_cli. This can be used to provide
- # limited command line editing and history support.
- #CONFIG_WPA_CLI_EDIT=y
-+
-+# Override default value for the wpa_disable_eapol_key_retries configuration
-+# parameter. See that parameter in hostapd.conf for more details.
-+#CFLAGS += -DDEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES=1
---- a/hostapd/hostapd.conf
-+++ b/hostapd/hostapd.conf
-@@ -1240,6 +1240,30 @@ own_ip_addr=127.0.0.1
- # Range 1..4294967295; default: 4
- #wpa_pairwise_update_count=4
- 
-+# Workaround for key reinstallation attacks
-+#
-+# This parameter can be used to disable retransmission of EAPOL-Key frames that
-+# are used to install keys (EAPOL-Key message 3/4 and group message 1/2). This
-+# is similar to setting wpa_group_update_count=1 and
-+# wpa_pairwise_update_count=1, but with no impact to message 1/4 and with
-+# extended timeout on the response to avoid causing issues with stations that
-+# may use aggressive power saving have very long time in replying to the
-+# EAPOL-Key messages.
-+#
-+# This option can be used to work around key reinstallation attacks on the
-+# station (supplicant) side in cases those station devices cannot be updated
-+# for some reason. By removing the retransmissions the attacker cannot cause
-+# key reinstallation with a delayed frame transmission. This is related to the
-+# station side vulnerabilities CVE-2017-13077, CVE-2017-13078, CVE-2017-13079,
-+# CVE-2017-13080, and CVE-2017-13081.
-+#
-+# This workaround might cause interoperability issues and reduced robustness of
-+# key negotiation especially in environments with heavy traffic load due to the
-+# number of attempts to perform the key exchange is reduced significantly. As
-+# such, this workaround is disabled by default (unless overridden in build
-+# configuration). To enable this, set the parameter to 1.
-+#wpa_disable_eapol_key_retries=1
-+
- # Enable IEEE 802.11i/RSN/WPA2 pre-authentication. This is used to speed up
- # roaming be pre-authenticating IEEE 802.1X/EAP part of the full RSN
- # authentication and key handshake before actually associating with a new AP.
---- a/src/ap/ap_config.c
-+++ b/src/ap/ap_config.c
-@@ -36,6 +36,10 @@ static void hostapd_config_free_vlan(str
- }
- 
- 
-+#ifndef DEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES
-+#define DEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES 0
-+#endif /* DEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES */
-+
- void hostapd_config_defaults_bss(struct hostapd_bss_config *bss)
- {
- 	dl_list_init(&bss->anqp_elem);
-@@ -57,6 +61,8 @@ void hostapd_config_defaults_bss(struct
- 	bss->wpa_gmk_rekey = 86400;
- 	bss->wpa_group_update_count = 4;
- 	bss->wpa_pairwise_update_count = 4;
-+	bss->wpa_disable_eapol_key_retries =
-+		DEFAULT_WPA_DISABLE_EAPOL_KEY_RETRIES;
- 	bss->wpa_key_mgmt = WPA_KEY_MGMT_PSK;
- 	bss->wpa_pairwise = WPA_CIPHER_TKIP;
- 	bss->wpa_group = WPA_CIPHER_TKIP;
---- a/src/ap/ap_config.h
-+++ b/src/ap/ap_config.h
-@@ -332,6 +332,7 @@ struct hostapd_bss_config {
- 	int wpa_ptk_rekey;
- 	u32 wpa_group_update_count;
- 	u32 wpa_pairwise_update_count;
-+	int wpa_disable_eapol_key_retries;
- 	int rsn_pairwise;
- 	int rsn_preauth;
- 	char *rsn_preauth_interfaces;
---- a/src/ap/wpa_auth.c
-+++ b/src/ap/wpa_auth.c
-@@ -63,6 +63,7 @@ static u8 * ieee80211w_kde_add(struct wp
- static const u32 eapol_key_timeout_first = 100; /* ms */
- static const u32 eapol_key_timeout_subseq = 1000; /* ms */
- static const u32 eapol_key_timeout_first_group = 500; /* ms */
-+static const u32 eapol_key_timeout_no_retrans = 4000; /* ms */
- 
- /* TODO: make these configurable */
- static const int dot11RSNAConfigPMKLifetime = 43200;
-@@ -1629,6 +1630,9 @@ static void wpa_send_eapol(struct wpa_au
- 			eapol_key_timeout_first_group;
- 	else
- 		timeout_ms = eapol_key_timeout_subseq;
-+	if (wpa_auth->conf.wpa_disable_eapol_key_retries &&
-+	    (!pairwise || (key_info & WPA_KEY_INFO_MIC)))
-+		timeout_ms = eapol_key_timeout_no_retrans;
- 	if (pairwise && ctr == 1 && !(key_info & WPA_KEY_INFO_MIC))
- 		sm->pending_1_of_4_timeout = 1;
- 	wpa_printf(MSG_DEBUG, "WPA: Use EAPOL-Key timeout of %u ms (retry "
-@@ -2700,6 +2704,11 @@ SM_STATE(WPA_PTK, PTKINITNEGOTIATING)
- 	sm->TimeoutEvt = FALSE;
- 
- 	sm->TimeoutCtr++;
-+	if (sm->wpa_auth->conf.wpa_disable_eapol_key_retries &&
-+	    sm->TimeoutCtr > 1) {
-+		/* Do not allow retransmission of EAPOL-Key msg 3/4 */
-+		return;
-+	}
- 	if (sm->TimeoutCtr > sm->wpa_auth->conf.wpa_pairwise_update_count) {
- 		/* No point in sending the EAPOL-Key - we will disconnect
- 		 * immediately following this. */
-@@ -3027,7 +3036,9 @@ SM_STEP(WPA_PTK)
- 			 sm->EAPOLKeyPairwise && sm->MICVerified)
- 			SM_ENTER(WPA_PTK, PTKINITDONE);
- 		else if (sm->TimeoutCtr >
--			 sm->wpa_auth->conf.wpa_pairwise_update_count) {
-+			 sm->wpa_auth->conf.wpa_pairwise_update_count ||
-+			 (sm->wpa_auth->conf.wpa_disable_eapol_key_retries &&
-+			  sm->TimeoutCtr > 1)) {
- 			wpa_auth->dot11RSNA4WayHandshakeFailures++;
- 			wpa_auth_vlogger(
- 				sm->wpa_auth, sm->addr, LOGGER_DEBUG,
-@@ -3067,6 +3078,11 @@ SM_STATE(WPA_PTK_GROUP, REKEYNEGOTIATING
- 	SM_ENTRY_MA(WPA_PTK_GROUP, REKEYNEGOTIATING, wpa_ptk_group);
- 
- 	sm->GTimeoutCtr++;
-+	if (sm->wpa_auth->conf.wpa_disable_eapol_key_retries &&
-+	    sm->GTimeoutCtr > 1) {
-+		/* Do not allow retransmission of EAPOL-Key group msg 1/2 */
-+		return;
-+	}
- 	if (sm->GTimeoutCtr > sm->wpa_auth->conf.wpa_group_update_count) {
- 		/* No point in sending the EAPOL-Key - we will disconnect
- 		 * immediately following this. */
-@@ -3165,7 +3181,9 @@ SM_STEP(WPA_PTK_GROUP)
- 		    !sm->EAPOLKeyPairwise && sm->MICVerified)
- 			SM_ENTER(WPA_PTK_GROUP, REKEYESTABLISHED);
- 		else if (sm->GTimeoutCtr >
--			 sm->wpa_auth->conf.wpa_group_update_count)
-+			 sm->wpa_auth->conf.wpa_group_update_count ||
-+			 (sm->wpa_auth->conf.wpa_disable_eapol_key_retries &&
-+			  sm->GTimeoutCtr > 1))
- 			SM_ENTER(WPA_PTK_GROUP, KEYERROR);
- 		else if (sm->TimeoutEvt)
- 			SM_ENTER(WPA_PTK_GROUP, REKEYNEGOTIATING);
---- a/src/ap/wpa_auth.h
-+++ b/src/ap/wpa_auth.h
-@@ -146,6 +146,7 @@ struct wpa_auth_config {
- 	int wpa_ptk_rekey;
- 	u32 wpa_group_update_count;
- 	u32 wpa_pairwise_update_count;
-+	int wpa_disable_eapol_key_retries;
- 	int rsn_pairwise;
- 	int rsn_preauth;
- 	int eapol_version;
---- a/src/ap/wpa_auth_glue.c
-+++ b/src/ap/wpa_auth_glue.c
-@@ -42,6 +42,8 @@ static void hostapd_wpa_auth_conf(struct
- 	wconf->wpa_gmk_rekey = conf->wpa_gmk_rekey;
- 	wconf->wpa_ptk_rekey = conf->wpa_ptk_rekey;
- 	wconf->wpa_group_update_count = conf->wpa_group_update_count;
-+	wconf->wpa_disable_eapol_key_retries =
-+		conf->wpa_disable_eapol_key_retries;
- 	wconf->wpa_pairwise_update_count = conf->wpa_pairwise_update_count;
- 	wconf->rsn_pairwise = conf->rsn_pairwise;
- 	wconf->rsn_preauth = conf->rsn_preauth;
diff --git a/package/network/services/hostapd/patches/017-Additional-consistentcy-checks-for-PTK-component-len.patch b/package/network/services/hostapd/patches/017-Additional-consistentcy-checks-for-PTK-component-len.patch
deleted file mode 100644
index 9655b5cb1fa4759b2446ce19b052ca7ffd529d38..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/017-Additional-consistentcy-checks-for-PTK-component-len.patch
+++ /dev/null
@@ -1,92 +0,0 @@
-From a6ea665300919d6a3af22b1f4237203647fda93a Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <j@w1.fi>
-Date: Tue, 17 Oct 2017 00:01:11 +0300
-Subject: [PATCH] Additional consistentcy checks for PTK component lengths
-
-Verify that TK, KCK, and KEK lengths are set to consistent values within
-struct wpa_ptk before using them in supplicant. This is an additional
-layer of protection against unexpected states.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
- src/common/wpa_common.c |  6 ++++++
- src/rsn_supp/wpa.c      | 26 ++++++++++++++++++++------
- 2 files changed, 26 insertions(+), 6 deletions(-)
-
---- a/src/common/wpa_common.c
-+++ b/src/common/wpa_common.c
-@@ -93,6 +93,12 @@ int wpa_eapol_key_mic(const u8 *key, siz
- {
- 	u8 hash[SHA384_MAC_LEN];
- 
-+	if (key_len == 0) {
-+		wpa_printf(MSG_DEBUG,
-+			   "WPA: KCK not set - cannot calculate MIC");
-+		return -1;
-+	}
-+
- 	switch (ver) {
- #ifndef CONFIG_FIPS
- 	case WPA_KEY_INFO_TYPE_HMAC_MD5_RC4:
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -710,6 +710,11 @@ static int wpa_supplicant_install_ptk(st
- 
- 	alg = wpa_cipher_to_alg(sm->pairwise_cipher);
- 	keylen = wpa_cipher_key_len(sm->pairwise_cipher);
-+	if (keylen <= 0 || (unsigned int) keylen != sm->ptk.tk_len) {
-+		wpa_printf(MSG_DEBUG, "WPA: TK length mismatch: %d != %lu",
-+			   keylen, (long unsigned int) sm->ptk.tk_len);
-+		return -1;
-+	}
- 	rsclen = wpa_cipher_rsc_len(sm->pairwise_cipher);
- 
- 	if (sm->proto == WPA_PROTO_RSN || sm->proto == WPA_PROTO_OSEN) {
-@@ -730,6 +735,7 @@ static int wpa_supplicant_install_ptk(st
- 
- 	/* TK is not needed anymore in supplicant */
- 	os_memset(sm->ptk.tk, 0, WPA_TK_MAX_LEN);
-+	sm->ptk.tk_len = 0;
- 	sm->ptk.installed = 1;
- 
- 	if (sm->wpa_ptk_rekey) {
-@@ -1699,9 +1705,10 @@ static int wpa_supplicant_verify_eapol_k
- 	os_memcpy(mic, key + 1, mic_len);
- 	if (sm->tptk_set) {
- 		os_memset(key + 1, 0, mic_len);
--		wpa_eapol_key_mic(sm->tptk.kck, sm->tptk.kck_len, sm->key_mgmt,
--				  ver, buf, len, (u8 *) (key + 1));
--		if (os_memcmp_const(mic, key + 1, mic_len) != 0) {
-+		if (wpa_eapol_key_mic(sm->tptk.kck, sm->tptk.kck_len,
-+				      sm->key_mgmt,
-+				      ver, buf, len, (u8 *) (key + 1)) < 0 ||
-+		    os_memcmp_const(mic, key + 1, mic_len) != 0) {
- 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
- 				"WPA: Invalid EAPOL-Key MIC "
- 				"when using TPTK - ignoring TPTK");
-@@ -1724,9 +1731,10 @@ static int wpa_supplicant_verify_eapol_k
- 
- 	if (!ok && sm->ptk_set) {
- 		os_memset(key + 1, 0, mic_len);
--		wpa_eapol_key_mic(sm->ptk.kck, sm->ptk.kck_len, sm->key_mgmt,
--				  ver, buf, len, (u8 *) (key + 1));
--		if (os_memcmp_const(mic, key + 1, mic_len) != 0) {
-+		if (wpa_eapol_key_mic(sm->ptk.kck, sm->ptk.kck_len,
-+				      sm->key_mgmt,
-+				      ver, buf, len, (u8 *) (key + 1)) < 0 ||
-+		    os_memcmp_const(mic, key + 1, mic_len) != 0) {
- 			wpa_msg(sm->ctx->msg_ctx, MSG_WARNING,
- 				"WPA: Invalid EAPOL-Key MIC - "
- 				"dropping packet");
-@@ -3689,6 +3697,11 @@ int fils_process_assoc_resp(struct wpa_s
- 
- 	alg = wpa_cipher_to_alg(sm->pairwise_cipher);
- 	keylen = wpa_cipher_key_len(sm->pairwise_cipher);
-+	if (keylen <= 0 || (unsigned int) keylen != sm->ptk.tk_len) {
-+		wpa_printf(MSG_DEBUG, "FILS: TK length mismatch: %u != %lu",
-+			   keylen, (long unsigned int) sm->ptk.tk_len);
-+		goto fail;
-+	}
- 	rsclen = wpa_cipher_rsc_len(sm->pairwise_cipher);
- 	wpa_hexdump_key(MSG_DEBUG, "FILS: Set TK to driver",
- 			sm->ptk.tk, keylen);
diff --git a/package/network/services/hostapd/patches/018-Clear-BSSID-information-in-supplicant-state-machine-.patch b/package/network/services/hostapd/patches/018-Clear-BSSID-information-in-supplicant-state-machine-.patch
deleted file mode 100644
index 808d34586bd0fce19ab2dd1127fdc00b96a31d8f..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/018-Clear-BSSID-information-in-supplicant-state-machine-.patch
+++ /dev/null
@@ -1,25 +0,0 @@
-From c0fe5f125a9d4a6564e1f4956ccc3809bf2fd69d Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <j@w1.fi>
-Date: Tue, 17 Oct 2017 01:15:24 +0300
-Subject: [PATCH] Clear BSSID information in supplicant state machine on
- disconnection
-
-This fixes a corner case where RSN pre-authentication candidate from
-scan results was ignored if the station was associated with that BSS
-just before running the new scan for the connection.
-
-Signed-off-by: Jouni Malinen <j@w1.fi>
----
- src/rsn_supp/wpa.c | 1 +
- 1 file changed, 1 insertion(+)
-
---- a/src/rsn_supp/wpa.c
-+++ b/src/rsn_supp/wpa.c
-@@ -2662,6 +2662,7 @@ void wpa_sm_notify_disassoc(struct wpa_s
- 	wpa_sm_drop_sa(sm);
- 
- 	sm->msg_3_of_4_ok = 0;
-+	os_memset(sm->bssid, 0, ETH_ALEN);
- }
- 
- 
diff --git a/package/network/services/hostapd/patches/019-WNM-Ignore-WNM-Sleep-Mode-Request-in-wnm_sleep_mode-.patch b/package/network/services/hostapd/patches/019-WNM-Ignore-WNM-Sleep-Mode-Request-in-wnm_sleep_mode-.patch
deleted file mode 100644
index 13426e4db1eb2d560933f9e7c03453aac2ca4735..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/019-WNM-Ignore-WNM-Sleep-Mode-Request-in-wnm_sleep_mode-.patch
+++ /dev/null
@@ -1,35 +0,0 @@
-From 114f2830d2c2aee6db23d48240e93415a256a37c Mon Sep 17 00:00:00 2001
-From: Jouni Malinen <jouni@qca.qualcomm.com>
-Date: Fri, 20 Oct 2017 17:39:42 +0300
-Subject: [PATCH] WNM: Ignore WNM-Sleep Mode Request in wnm_sleep_mode=0 case
-
-The hostapd wnm_sleep_mode parameter was previously used to control
-advertisement of WNM-Sleep Mode support, but it was not used when
-processing a request to use WNM-Sleep Mode. Add an explicit check during
-request processing as well so that any misbehaving station is ignored.
-
-Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
----
- src/ap/wnm_ap.c | 7 +++++++
- 1 file changed, 7 insertions(+)
-
-diff --git a/src/ap/wnm_ap.c b/src/ap/wnm_ap.c
-index 7c4fde0..973e4d3 100644
---- a/src/ap/wnm_ap.c
-+++ b/src/ap/wnm_ap.c
-@@ -200,6 +200,13 @@ static void ieee802_11_rx_wnmsleep_req(struct hostapd_data *hapd,
- 	u8 *tfsreq_ie_end = NULL;
- 	u16 tfsreq_ie_len = 0;
- 
-+	if (!hapd->conf->wnm_sleep_mode) {
-+		wpa_printf(MSG_DEBUG, "Ignore WNM-Sleep Mode Request from "
-+			   MACSTR " since WNM-Sleep Mode is disabled",
-+			   MAC2STR(addr));
-+		return;
-+	}
-+
- 	dialog_token = *pos++;
- 	while (pos + 1 < frm + len) {
- 		u8 ie_len = pos[1];
--- 
-2.1.4
diff --git a/package/network/services/hostapd/patches/100-daemonize_fix.patch b/package/network/services/hostapd/patches/100-daemonize_fix.patch
deleted file mode 100644
index fad84669a6b646d39d18d0381c0d98b7e1fd1e76..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/100-daemonize_fix.patch
+++ /dev/null
@@ -1,97 +0,0 @@
---- a/src/utils/os_unix.c
-+++ b/src/utils/os_unix.c
-@@ -10,6 +10,7 @@
- 
- #include <time.h>
- #include <sys/wait.h>
-+#include <fcntl.h>
- 
- #ifdef ANDROID
- #include <sys/capability.h>
-@@ -179,59 +180,46 @@ int os_gmtime(os_time_t t, struct os_tm
- 	return 0;
- }
- 
--
--#ifdef __APPLE__
--#include <fcntl.h>
--static int os_daemon(int nochdir, int noclose)
-+int os_daemonize(const char *pid_file)
- {
--	int devnull;
-+	int pid = 0, i, devnull;
- 
--	if (chdir("/") < 0)
--		return -1;
-+#if defined(__uClinux__) || defined(__sun__)
-+	return -1;
-+#else /* defined(__uClinux__) || defined(__sun__) */
- 
--	devnull = open("/dev/null", O_RDWR);
--	if (devnull < 0)
-+#ifndef __APPLE__
-+	pid = fork();
-+	if (pid < 0)
- 		return -1;
-+#endif
- 
--	if (dup2(devnull, STDIN_FILENO) < 0) {
--		close(devnull);
--		return -1;
-+	if (pid > 0) {
-+		if (pid_file) {
-+			FILE *f = fopen(pid_file, "w");
-+			if (f) {
-+				fprintf(f, "%u\n", pid);
-+				fclose(f);
-+			}
-+		}
-+		_exit(0);
- 	}
- 
--	if (dup2(devnull, STDOUT_FILENO) < 0) {
--		close(devnull);
-+	if (setsid() < 0)
- 		return -1;
--	}
- 
--	if (dup2(devnull, STDERR_FILENO) < 0) {
--		close(devnull);
-+	if (chdir("/") < 0)
- 		return -1;
--	}
--
--	return 0;
--}
--#else /* __APPLE__ */
--#define os_daemon daemon
--#endif /* __APPLE__ */
- 
--
--int os_daemonize(const char *pid_file)
--{
--#if defined(__uClinux__) || defined(__sun__)
--	return -1;
--#else /* defined(__uClinux__) || defined(__sun__) */
--	if (os_daemon(0, 0)) {
--		perror("daemon");
-+	devnull = open("/dev/null", O_RDWR);
-+	if (devnull < 0)
- 		return -1;
--	}
- 
--	if (pid_file) {
--		FILE *f = fopen(pid_file, "w");
--		if (f) {
--			fprintf(f, "%u\n", getpid());
--			fclose(f);
--		}
--	}
-+	for (i = 0; i <= STDERR_FILENO; i++)
-+		dup2(devnull, i);
-+
-+	if (devnull > 2)
-+		close(devnull);
- 
- 	return -0;
- #endif /* defined(__uClinux__) || defined(__sun__) */
diff --git a/package/network/services/hostapd/patches/100-mesh_mode_fix.patch b/package/network/services/hostapd/patches/100-mesh_mode_fix.patch
new file mode 100644
index 0000000000000000000000000000000000000000..ceb4c53afacfb1dd5430a487147e73b3de4f7239
--- /dev/null
+++ b/package/network/services/hostapd/patches/100-mesh_mode_fix.patch
@@ -0,0 +1,12 @@
+--- a/src/drivers/driver_nl80211.c
++++ b/src/drivers/driver_nl80211.c
+@@ -2332,7 +2332,8 @@ wpa_driver_nl80211_finish_drv_init(struc
+ 
+ 	if (drv->hostapd || bss->static_ap)
+ 		nlmode = NL80211_IFTYPE_AP;
+-	else if (bss->if_dynamic)
++	else if (bss->if_dynamic ||
++		 nl80211_get_ifmode(bss) == NL80211_IFTYPE_MESH_POINT)
+ 		nlmode = nl80211_get_ifmode(bss);
+ 	else
+ 		nlmode = NL80211_IFTYPE_STATION;
diff --git a/package/network/services/hostapd/patches/110-no_eapol_fix.patch b/package/network/services/hostapd/patches/110-no_eapol_fix.patch
deleted file mode 100644
index 5181721e3be9ab717e768bd475ef1ff6b5b4be4d..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/110-no_eapol_fix.patch
+++ /dev/null
@@ -1,14 +0,0 @@
---- a/wpa_supplicant/wpa_supplicant.c
-+++ b/wpa_supplicant/wpa_supplicant.c
-@@ -259,9 +259,10 @@ void wpa_supplicant_cancel_auth_timeout(
-  */
- void wpa_supplicant_initiate_eapol(struct wpa_supplicant *wpa_s)
- {
-+	struct wpa_ssid *ssid = wpa_s->current_ssid;
-+
- #ifdef IEEE8021X_EAPOL
- 	struct eapol_config eapol_conf;
--	struct wpa_ssid *ssid = wpa_s->current_ssid;
- 
- #ifdef CONFIG_IBSS_RSN
- 	if (ssid->mode == WPAS_MODE_IBSS &&
diff --git a/package/network/services/hostapd/patches/120-daemonize_fix.patch b/package/network/services/hostapd/patches/120-daemonize_fix.patch
new file mode 100644
index 0000000000000000000000000000000000000000..0389406a98a11a9eb4d5df64a30896e57dea103b
--- /dev/null
+++ b/package/network/services/hostapd/patches/120-daemonize_fix.patch
@@ -0,0 +1,97 @@
+--- a/src/utils/os_unix.c
++++ b/src/utils/os_unix.c
+@@ -10,6 +10,7 @@
+ 
+ #include <time.h>
+ #include <sys/wait.h>
++#include <fcntl.h>
+ 
+ #ifdef ANDROID
+ #include <sys/capability.h>
+@@ -179,59 +180,46 @@ int os_gmtime(os_time_t t, struct os_tm
+ 	return 0;
+ }
+ 
+-
+-#ifdef __APPLE__
+-#include <fcntl.h>
+-static int os_daemon(int nochdir, int noclose)
++int os_daemonize(const char *pid_file)
+ {
+-	int devnull;
++	int pid = 0, i, devnull;
+ 
+-	if (chdir("/") < 0)
+-		return -1;
++#if defined(__uClinux__) || defined(__sun__)
++	return -1;
++#else /* defined(__uClinux__) || defined(__sun__) */
+ 
+-	devnull = open("/dev/null", O_RDWR);
+-	if (devnull < 0)
++#ifndef __APPLE__
++	pid = fork();
++	if (pid < 0)
+ 		return -1;
++#endif
+ 
+-	if (dup2(devnull, STDIN_FILENO) < 0) {
+-		close(devnull);
+-		return -1;
++	if (pid > 0) {
++		if (pid_file) {
++			FILE *f = fopen(pid_file, "w");
++			if (f) {
++				fprintf(f, "%u\n", pid);
++				fclose(f);
++			}
++		}
++		_exit(0);
+ 	}
+ 
+-	if (dup2(devnull, STDOUT_FILENO) < 0) {
+-		close(devnull);
++	if (setsid() < 0)
+ 		return -1;
+-	}
+ 
+-	if (dup2(devnull, STDERR_FILENO) < 0) {
+-		close(devnull);
++	if (chdir("/") < 0)
+ 		return -1;
+-	}
+ 
+-	return 0;
+-}
+-#else /* __APPLE__ */
+-#define os_daemon daemon
+-#endif /* __APPLE__ */
+-
+-
+-int os_daemonize(const char *pid_file)
+-{
+-#if defined(__uClinux__) || defined(__sun__)
+-	return -1;
+-#else /* defined(__uClinux__) || defined(__sun__) */
+-	if (os_daemon(0, 0)) {
+-		perror("daemon");
++	devnull = open("/dev/null", O_RDWR);
++	if (devnull < 0)
+ 		return -1;
+-	}
+ 
+-	if (pid_file) {
+-		FILE *f = fopen(pid_file, "w");
+-		if (f) {
+-			fprintf(f, "%u\n", getpid());
+-			fclose(f);
+-		}
+-	}
++	for (i = 0; i <= STDERR_FILENO; i++)
++		dup2(devnull, i);
++
++	if (devnull > 2)
++		close(devnull);
+ 
+ 	return -0;
+ #endif /* defined(__uClinux__) || defined(__sun__) */
diff --git a/package/network/services/hostapd/patches/120-disable_bridge_packet_workaround.patch b/package/network/services/hostapd/patches/120-disable_bridge_packet_workaround.patch
deleted file mode 100644
index fdd5da9bf5e99cad1a998f80f435ac26097274cd..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/120-disable_bridge_packet_workaround.patch
+++ /dev/null
@@ -1,12 +0,0 @@
---- a/src/l2_packet/l2_packet_linux.c
-+++ b/src/l2_packet/l2_packet_linux.c
-@@ -337,8 +337,7 @@ struct l2_packet_data * l2_packet_init_b
- 
- 	l2 = l2_packet_init(br_ifname, own_addr, protocol, rx_callback,
- 			    rx_callback_ctx, l2_hdr);
--	if (!l2)
--		return NULL;
-+	return l2;
- 
- #ifndef CONFIG_NO_LINUX_PACKET_SOCKET_WAR
- 	/*
diff --git a/package/network/services/hostapd/patches/130-no_eapol_fix.patch b/package/network/services/hostapd/patches/130-no_eapol_fix.patch
new file mode 100644
index 0000000000000000000000000000000000000000..5aee3d07f16b1f5665fab1b2a31794c32e18cbac
--- /dev/null
+++ b/package/network/services/hostapd/patches/130-no_eapol_fix.patch
@@ -0,0 +1,14 @@
+--- a/wpa_supplicant/wpa_supplicant.c
++++ b/wpa_supplicant/wpa_supplicant.c
+@@ -257,9 +257,10 @@ void wpa_supplicant_cancel_auth_timeout(
+  */
+ void wpa_supplicant_initiate_eapol(struct wpa_supplicant *wpa_s)
+ {
++	struct wpa_ssid *ssid = wpa_s->current_ssid;
++
+ #ifdef IEEE8021X_EAPOL
+ 	struct eapol_config eapol_conf;
+-	struct wpa_ssid *ssid = wpa_s->current_ssid;
+ 
+ #ifdef CONFIG_IBSS_RSN
+ 	if (ssid->mode == WPAS_MODE_IBSS &&
diff --git a/package/network/services/hostapd/patches/140-disable_bridge_packet_workaround.patch b/package/network/services/hostapd/patches/140-disable_bridge_packet_workaround.patch
new file mode 100644
index 0000000000000000000000000000000000000000..fdd5da9bf5e99cad1a998f80f435ac26097274cd
--- /dev/null
+++ b/package/network/services/hostapd/patches/140-disable_bridge_packet_workaround.patch
@@ -0,0 +1,12 @@
+--- a/src/l2_packet/l2_packet_linux.c
++++ b/src/l2_packet/l2_packet_linux.c
+@@ -337,8 +337,7 @@ struct l2_packet_data * l2_packet_init_b
+ 
+ 	l2 = l2_packet_init(br_ifname, own_addr, protocol, rx_callback,
+ 			    rx_callback_ctx, l2_hdr);
+-	if (!l2)
+-		return NULL;
++	return l2;
+ 
+ #ifndef CONFIG_NO_LINUX_PACKET_SOCKET_WAR
+ 	/*
diff --git a/package/network/services/hostapd/patches/200-multicall.patch b/package/network/services/hostapd/patches/200-multicall.patch
index f0348201ffad25669147ac60dea3490d62d24fd1..e9d49d40fa5eba3e579b33cc31cd1bc60d0679c3 100644
--- a/package/network/services/hostapd/patches/200-multicall.patch
+++ b/package/network/services/hostapd/patches/200-multicall.patch
@@ -8,7 +8,7 @@
  
  ifndef CONFIG_NO_GITVER
  # Add VERSION_STR postfix for builds from a git repository
-@@ -198,7 +199,8 @@ endif
+@@ -190,7 +191,8 @@ endif
  
  ifdef CONFIG_NO_VLAN
  CFLAGS += -DCONFIG_NO_VLAN
@@ -18,7 +18,7 @@
  OBJS += ../src/ap/vlan_init.o
  OBJS += ../src/ap/vlan_ifconfig.o
  OBJS += ../src/ap/vlan.o
-@@ -330,10 +332,14 @@ CFLAGS += -DCONFIG_MBO
+@@ -315,10 +317,14 @@ CFLAGS += -DCONFIG_MBO
  OBJS += ../src/ap/mbo_ap.o
  endif
  
@@ -36,7 +36,7 @@
  LIBS += $(DRV_AP_LIBS)
  
  ifdef CONFIG_L2_PACKET
-@@ -1077,6 +1083,12 @@ install: $(addprefix $(DESTDIR)$(BINDIR)
+@@ -1051,6 +1057,12 @@ install: $(addprefix $(DESTDIR)$(BINDIR)
  
  BCHECK=../src/drivers/build.hostapd
  
@@ -49,15 +49,15 @@
  hostapd: $(BCHECK) $(OBJS)
  	$(Q)$(CC) $(LDFLAGS) -o hostapd $(OBJS) $(LIBS)
  	@$(E) "  LD " $@
-@@ -1118,6 +1130,12 @@ HOBJS += ../src/crypto/aes-internal.o
+@@ -1092,6 +1104,12 @@ HOBJS += ../src/crypto/aes-internal.o
  HOBJS += ../src/crypto/aes-internal-enc.o
  endif
  
 +dump_cflags:
-+	@printf "%s " "$(CFLAGS)"
++	@echo -n $(CFLAGS) " "
 +
 +dump_ldflags:
-+	@printf "%s " "$(LDFLAGS) $(LIBS) $(EXTRALIBS)"
++	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
 +
  nt_password_hash: $(NOBJS)
  	$(Q)$(CC) $(LDFLAGS) -o nt_password_hash $(NOBJS) $(LIBS_n)
@@ -72,17 +72,7 @@
  
  ifndef CONFIG_NO_GITVER
  # Add VERSION_STR postfix for builds from a git repository
-@@ -329,7 +330,9 @@ endif
- ifdef CONFIG_IBSS_RSN
- NEED_RSN_AUTHENTICATOR=y
- CFLAGS += -DCONFIG_IBSS_RSN
-+ifndef MULTICALL
- CFLAGS += -DCONFIG_NO_VLAN
-+endif
- OBJS += ibss_rsn.o
- endif
- 
-@@ -820,6 +823,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
+@@ -803,6 +804,10 @@ ifdef CONFIG_DYNAMIC_EAP_METHODS
  CFLAGS += -DCONFIG_DYNAMIC_EAP_METHODS
  LIBS += -ldl -rdynamic
  endif
@@ -93,7 +83,7 @@
  endif
  
  ifdef CONFIG_MACSEC
-@@ -840,9 +847,11 @@ NEED_EAP_COMMON=y
+@@ -823,9 +828,11 @@ NEED_EAP_COMMON=y
  NEED_RSN_AUTHENTICATOR=y
  CFLAGS += -DCONFIG_AP
  OBJS += ap.o
@@ -105,7 +95,7 @@
  OBJS += ../src/ap/hostapd.o
  OBJS += ../src/ap/wpa_auth_glue.o
  OBJS += ../src/ap/utils.o
-@@ -910,6 +919,12 @@ endif
+@@ -898,10 +905,18 @@ endif
  ifdef CONFIG_HS20
  OBJS += ../src/ap/hs20.o
  endif
@@ -117,10 +107,6 @@
 +  endif
  endif
  
- ifdef CONFIG_MBO
-@@ -918,7 +933,9 @@ CFLAGS += -DCONFIG_MBO
- endif
- 
  ifdef NEED_RSN_AUTHENTICATOR
 +ifndef MULTICALL
  CFLAGS += -DCONFIG_NO_RADIUS
@@ -128,7 +114,7 @@
  NEED_AES_WRAP=y
  OBJS += ../src/ap/wpa_auth.o
  OBJS += ../src/ap/wpa_auth_ie.o
-@@ -1706,6 +1723,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
+@@ -1680,6 +1695,12 @@ wpa_priv: $(BCHECK) $(OBJS_priv)
  
  $(OBJS_c) $(OBJS_t) $(OBJS_t2) $(OBJS) $(BCHECK) $(EXTRA_progs): .config
  
@@ -141,22 +127,22 @@
  wpa_supplicant: $(BCHECK) $(OBJS) $(EXTRA_progs)
  	$(Q)$(LDO) $(LDFLAGS) -o wpa_supplicant $(OBJS) $(LIBS) $(EXTRALIBS)
  	@$(E) "  LD " $@
-@@ -1808,6 +1831,12 @@ endif
+@@ -1782,6 +1803,12 @@ endif
  		-e 's|\@DBUS_INTERFACE\@|$(DBUS_INTERFACE)|g' $< >$@
  	@$(E) "  sed" $<
  
 +dump_cflags:
-+	@printf "%s " "$(CFLAGS)"
++	@echo -n $(CFLAGS) " "
 +
 +dump_ldflags:
-+	@printf "%s " "$(LDFLAGS) $(LIBS) $(EXTRALIBS)"
++	@echo -n $(LDFLAGS) $(LIBS) $(EXTRALIBS) " "
 +
  wpa_supplicant.exe: wpa_supplicant
  	mv -f $< $@
  wpa_cli.exe: wpa_cli
 --- a/src/drivers/driver.h
 +++ b/src/drivers/driver.h
-@@ -4968,8 +4968,8 @@ union wpa_event_data {
+@@ -4794,8 +4794,8 @@ union wpa_event_data {
   * Driver wrapper code should call this function whenever an event is received
   * from the driver.
   */
@@ -167,7 +153,7 @@
  
  /**
   * wpa_supplicant_event_global - Report a driver event for wpa_supplicant
-@@ -4981,7 +4981,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -4807,7 +4807,7 @@ void wpa_supplicant_event(void *ctx, enu
   * Same as wpa_supplicant_event(), but we search for the interface in
   * wpa_global.
   */
@@ -178,7 +164,7 @@
  /*
 --- a/src/ap/drv_callbacks.c
 +++ b/src/ap/drv_callbacks.c
-@@ -1163,8 +1163,8 @@ static void hostapd_event_dfs_cac_starte
+@@ -1157,8 +1157,8 @@ static void hostapd_event_dfs_cac_starte
  #endif /* NEED_AP_MLME */
  
  
@@ -189,7 +175,7 @@
  {
  	struct hostapd_data *hapd = ctx;
  #ifndef CONFIG_NO_STDOUT_DEBUG
-@@ -1373,7 +1373,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -1367,7 +1367,7 @@ void wpa_supplicant_event(void *ctx, enu
  }
  
  
@@ -200,7 +186,7 @@
  	struct hapd_interfaces *interfaces = ctx;
 --- a/wpa_supplicant/wpa_priv.c
 +++ b/wpa_supplicant/wpa_priv.c
-@@ -1031,8 +1031,8 @@ static void wpa_priv_send_ft_response(st
+@@ -940,8 +940,8 @@ static void wpa_priv_send_ft_response(st
  }
  
  
@@ -211,7 +197,7 @@
  {
  	struct wpa_priv_interface *iface = ctx;
  
-@@ -1101,7 +1101,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -1010,7 +1010,7 @@ void wpa_supplicant_event(void *ctx, enu
  }
  
  
@@ -220,7 +206,7 @@
  				 union wpa_event_data *data)
  {
  	struct wpa_priv_global *global = ctx;
-@@ -1213,6 +1213,8 @@ int main(int argc, char *argv[])
+@@ -1122,6 +1122,8 @@ int main(int argc, char *argv[])
  	if (os_program_init())
  		return -1;
  
@@ -231,7 +217,7 @@
  	os_memset(&global, 0, sizeof(global));
 --- a/wpa_supplicant/events.c
 +++ b/wpa_supplicant/events.c
-@@ -3610,8 +3610,8 @@ static void wpa_supplicant_event_assoc_a
+@@ -3384,8 +3384,8 @@ static void wpa_supplicant_event_assoc_a
  }
  
  
@@ -242,7 +228,7 @@
  {
  	struct wpa_supplicant *wpa_s = ctx;
  	int resched;
-@@ -4315,7 +4315,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -4051,7 +4051,7 @@ void wpa_supplicant_event(void *ctx, enu
  #endif /* CONFIG_AP */
  		break;
  	case EVENT_ACS_CHANNEL_SELECTED:
@@ -251,7 +237,7 @@
  		if (!wpa_s->ap_iface)
  			break;
  		hostapd_acs_channel_selected(wpa_s->ap_iface->bss[0],
-@@ -4337,7 +4337,7 @@ void wpa_supplicant_event(void *ctx, enu
+@@ -4065,7 +4065,7 @@ void wpa_supplicant_event(void *ctx, enu
  }
  
  
@@ -262,7 +248,7 @@
  	struct wpa_supplicant *wpa_s;
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -5136,7 +5136,6 @@ struct wpa_interface * wpa_supplicant_ma
+@@ -4982,7 +4982,6 @@ struct wpa_interface * wpa_supplicant_ma
  	return NULL;
  }
  
@@ -270,7 +256,7 @@
  /**
   * wpa_supplicant_match_existing - Match existing interfaces
   * @global: Pointer to global data from wpa_supplicant_init()
-@@ -5173,6 +5172,11 @@ static int wpa_supplicant_match_existing
+@@ -5019,6 +5018,11 @@ static int wpa_supplicant_match_existing
  
  #endif /* CONFIG_MATCH_IFACE */
  
@@ -282,7 +268,7 @@
  
  /**
   * wpa_supplicant_add_iface - Add a new network interface
-@@ -5428,6 +5432,8 @@ struct wpa_global * wpa_supplicant_init(
+@@ -5274,6 +5278,8 @@ struct wpa_global * wpa_supplicant_init(
  #ifndef CONFIG_NO_WPA_MSG
  	wpa_msg_register_ifname_cb(wpa_supplicant_msg_ifname_cb);
  #endif /* CONFIG_NO_WPA_MSG */
@@ -293,7 +279,7 @@
  		wpa_debug_open_file(params->wpa_debug_file_path);
 --- a/hostapd/main.c
 +++ b/hostapd/main.c
-@@ -590,6 +590,11 @@ fail:
+@@ -583,6 +583,11 @@ fail:
  	return -1;
  }
  
@@ -305,18 +291,18 @@
  
  #ifdef CONFIG_WPS
  static int gen_uuid(const char *txt_addr)
-@@ -667,6 +672,8 @@ int main(int argc, char *argv[])
+@@ -660,6 +665,8 @@ int main(int argc, char *argv[])
  	interfaces.global_ctrl_sock = -1;
  	dl_list_init(&interfaces.global_ctrl_dst);
  
 +	wpa_supplicant_event = hostapd_wpa_event;
 +	wpa_supplicant_event_global = hostapd_wpa_event_global;
  	for (;;) {
- 		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:vg:G:");
+ 		c = getopt(argc, argv, "b:Bde:f:hi:KP:STtu:vg:G:");
  		if (c < 0)
 --- a/src/drivers/drivers.c
 +++ b/src/drivers/drivers.c
-@@ -10,6 +10,10 @@
+@@ -10,6 +10,11 @@
  #include "utils/common.h"
  #include "driver.h"
  
@@ -324,9 +310,10 @@
 +			     union wpa_event_data *data);
 +void (*wpa_supplicant_event_global)(void *ctx, enum wpa_event_type event,
 +			     union wpa_event_data *data);
- 
- const struct wpa_driver_ops *const wpa_drivers[] =
- {
++
+ #ifdef CONFIG_DRIVER_WEXT
+ extern struct wpa_driver_ops wpa_driver_wext_ops; /* driver_wext.c */
+ #endif /* CONFIG_DRIVER_WEXT */
 --- a/wpa_supplicant/eapol_test.c
 +++ b/wpa_supplicant/eapol_test.c
 @@ -29,7 +29,12 @@
diff --git a/package/network/services/hostapd/patches/300-noscan.patch b/package/network/services/hostapd/patches/300-noscan.patch
index 9dc0f2c393775abb91eb727fc6d96d3fa7802c1e..bb3d57b0ea2856f440b13e382417477a5b152e8d 100644
--- a/package/network/services/hostapd/patches/300-noscan.patch
+++ b/package/network/services/hostapd/patches/300-noscan.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/config_file.c
 +++ b/hostapd/config_file.c
-@@ -2953,6 +2953,10 @@ static int hostapd_config_fill(struct ho
+@@ -2861,6 +2861,10 @@ static int hostapd_config_fill(struct ho
  		}
  #endif /* CONFIG_IEEE80211W */
  #ifdef CONFIG_IEEE80211N
@@ -13,7 +13,7 @@
  	} else if (os_strcmp(buf, "ht_capab") == 0) {
 --- a/src/ap/ap_config.h
 +++ b/src/ap/ap_config.h
-@@ -681,6 +681,8 @@ struct hostapd_config {
+@@ -655,6 +655,8 @@ struct hostapd_config {
  
  	int ht_op_mode_fixed;
  	u16 ht_capab;
diff --git a/package/network/services/hostapd/patches/310-rescan_immediately.patch b/package/network/services/hostapd/patches/310-rescan_immediately.patch
index ccc9781fa0bc76526c96a53f7613a13eed3bc978..d9486ed4051bd8e77e91219488ba01f8ebfc0f81 100644
--- a/package/network/services/hostapd/patches/310-rescan_immediately.patch
+++ b/package/network/services/hostapd/patches/310-rescan_immediately.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -3696,7 +3696,7 @@ wpa_supplicant_alloc(struct wpa_supplica
+@@ -3548,7 +3548,7 @@ wpa_supplicant_alloc(struct wpa_supplica
  	if (wpa_s == NULL)
  		return NULL;
  	wpa_s->scan_req = INITIAL_SCAN_REQ;
diff --git a/package/network/services/hostapd/patches/320-optional_rfkill.patch b/package/network/services/hostapd/patches/320-optional_rfkill.patch
index bdc1764578483d8effbcd7b8bca43fa4fb4db346..cf2a2c108b0c58597c4a10ccd9c7be242a6ae649 100644
--- a/package/network/services/hostapd/patches/320-optional_rfkill.patch
+++ b/package/network/services/hostapd/patches/320-optional_rfkill.patch
@@ -1,6 +1,6 @@
 --- a/src/drivers/drivers.mak
 +++ b/src/drivers/drivers.mak
-@@ -49,7 +49,6 @@ NEED_SME=y
+@@ -36,7 +36,6 @@ NEED_SME=y
  NEED_AP_MLME=y
  NEED_NETLINK=y
  NEED_LINUX_IOCTL=y
@@ -8,7 +8,7 @@
  NEED_RADIOTAP=y
  
  ifdef CONFIG_LIBNL32
-@@ -136,7 +135,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
+@@ -123,7 +122,6 @@ DRV_WPA_CFLAGS += -DCONFIG_DRIVER_WEXT
  CONFIG_WIRELESS_EXTENSION=y
  NEED_NETLINK=y
  NEED_LINUX_IOCTL=y
@@ -16,7 +16,7 @@
  endif
  
  ifdef CONFIG_DRIVER_NDIS
-@@ -162,7 +160,6 @@ endif
+@@ -149,7 +147,6 @@ endif
  ifdef CONFIG_WIRELESS_EXTENSION
  DRV_WPA_CFLAGS += -DCONFIG_WIRELESS_EXTENSION
  DRV_WPA_OBJS += ../src/drivers/driver_wext.o
@@ -24,7 +24,7 @@
  endif
  
  ifdef NEED_NETLINK
-@@ -175,6 +172,7 @@ endif
+@@ -162,6 +159,7 @@ endif
  
  ifdef NEED_RFKILL
  DRV_OBJS += ../src/drivers/rfkill.o
diff --git a/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch b/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
index ebb12f69fff938ddcf04c5103e517a315e615227..ca4601247b9c093a986e543d188726380301263e 100644
--- a/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
+++ b/package/network/services/hostapd/patches/330-nl80211_fix_set_freq.patch
@@ -1,6 +1,6 @@
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -4104,7 +4104,7 @@ static int nl80211_set_channel(struct i8
+@@ -3795,7 +3795,7 @@ static int nl80211_set_channel(struct i8
  		   freq->freq, freq->ht_enabled, freq->vht_enabled,
  		   freq->bandwidth, freq->center_freq1, freq->center_freq2);
  
diff --git a/package/network/services/hostapd/patches/340-reload_freq_change.patch b/package/network/services/hostapd/patches/340-reload_freq_change.patch
index 0dcd7c913e829738648b2513fc027ffd60a494cd..086ade9cedec664ee566764f8f09bd2fd730ba53 100644
--- a/package/network/services/hostapd/patches/340-reload_freq_change.patch
+++ b/package/network/services/hostapd/patches/340-reload_freq_change.patch
@@ -1,6 +1,6 @@
 --- a/src/ap/hostapd.c
 +++ b/src/ap/hostapd.c
-@@ -80,6 +80,25 @@ static void hostapd_reload_bss(struct ho
+@@ -80,6 +80,16 @@ static void hostapd_reload_bss(struct ho
  #endif /* CONFIG_NO_RADIUS */
  
  	ssid = &hapd->conf->ssid;
@@ -13,39 +13,14 @@
 +			 hapd->iconf->vht_oper_chwidth,
 +			 hapd->iconf->vht_oper_centr_freq_seg0_idx,
 +			 hapd->iconf->vht_oper_centr_freq_seg1_idx);
-+
-+	if (hapd->iface->current_mode) {
-+		if (hostapd_prepare_rates(hapd->iface, hapd->iface->current_mode)) {
-+			wpa_printf(MSG_ERROR, "Failed to prepare rates table.");
-+			hostapd_logger(hapd, NULL, HOSTAPD_MODULE_IEEE80211,
-+				       HOSTAPD_LEVEL_WARNING,
-+				       "Failed to prepare rates table.");
-+		}
-+	}
 +
  	if (!ssid->wpa_psk_set && ssid->wpa_psk && !ssid->wpa_psk->next &&
  	    ssid->wpa_passphrase_set && ssid->wpa_passphrase) {
  		/*
-@@ -158,6 +177,7 @@ int hostapd_reload_config(struct hostapd
- 	struct hostapd_data *hapd = iface->bss[0];
- 	struct hostapd_config *newconf, *oldconf;
- 	size_t j;
-+	int i;
- 
- 	if (iface->config_fname == NULL) {
- 		/* Only in-memory config in use - assume it has been updated */
-@@ -179,21 +199,20 @@ int hostapd_reload_config(struct hostapd
+@@ -179,21 +189,12 @@ int hostapd_reload_config(struct hostapd
  	oldconf = hapd->iconf;
  	iface->conf = newconf;
  
-+	for (i = 0; i < iface->num_hw_features; i++) {
-+		struct hostapd_hw_modes *mode = &iface->hw_features[i];
-+		if (mode->mode == iface->conf->hw_mode) {
-+			iface->current_mode = mode;
-+			break;
-+		}
-+	}
-+
 +	if (iface->conf->channel)
 +		iface->freq = hostapd_hw_get_freq(hapd, iface->conf->channel);
 +
diff --git a/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch b/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
index be10a413e602b34baad54921ea19fab8070bf961..247f154e3059aaf25df321b496ff255b50b8ddf4 100644
--- a/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
+++ b/package/network/services/hostapd/patches/350-nl80211_del_beacon_bss.patch
@@ -1,6 +1,6 @@
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -2490,13 +2490,18 @@ wpa_driver_nl80211_finish_drv_init(struc
+@@ -2394,13 +2394,18 @@ wpa_driver_nl80211_finish_drv_init(struc
  }
  
  
@@ -22,7 +22,7 @@
  	return send_and_recv_msgs(drv, msg, NULL, NULL);
  }
  
-@@ -2548,7 +2553,7 @@ static void wpa_driver_nl80211_deinit(st
+@@ -2452,7 +2457,7 @@ static void wpa_driver_nl80211_deinit(st
  	nl80211_remove_monitor_interface(drv);
  
  	if (is_ap_interface(drv->nlmode))
@@ -31,7 +31,7 @@
  
  	if (drv->eapol_sock >= 0) {
  		eloop_unregister_read_sock(drv->eapol_sock);
-@@ -4703,8 +4708,7 @@ static void nl80211_teardown_ap(struct i
+@@ -4385,8 +4390,7 @@ static void nl80211_teardown_ap(struct i
  		nl80211_remove_monitor_interface(drv);
  	else
  		nl80211_mgmt_unsubscribe(bss, "AP teardown");
@@ -41,7 +41,7 @@
  }
  
  
-@@ -6728,8 +6732,6 @@ static int wpa_driver_nl80211_if_remove(
+@@ -6387,8 +6391,6 @@ static int wpa_driver_nl80211_if_remove(
  	} else {
  		wpa_printf(MSG_DEBUG, "nl80211: First BSS - reassign context");
  		nl80211_teardown_ap(bss);
@@ -50,7 +50,7 @@
  		nl80211_destroy_bss(bss);
  		if (!bss->added_if)
  			i802_set_iface_flags(bss, 0);
-@@ -7091,8 +7093,7 @@ static int wpa_driver_nl80211_deinit_ap(
+@@ -6750,8 +6752,7 @@ static int wpa_driver_nl80211_deinit_ap(
  	struct wpa_driver_nl80211_data *drv = bss->drv;
  	if (!is_ap_interface(drv->nlmode))
  		return -1;
@@ -60,7 +60,7 @@
  
  	/*
  	 * If the P2P GO interface was dynamically added, then it is
-@@ -7111,8 +7112,7 @@ static int wpa_driver_nl80211_stop_ap(vo
+@@ -6770,8 +6771,7 @@ static int wpa_driver_nl80211_stop_ap(vo
  	struct wpa_driver_nl80211_data *drv = bss->drv;
  	if (!is_ap_interface(drv->nlmode))
  		return -1;
diff --git a/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch b/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
index 83bec2a25c5fc4434577a7b4faca3ce7f2399f5f..1e405cbf0edcda8604080f9c00f0eeb35c106218 100644
--- a/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
+++ b/package/network/services/hostapd/patches/360-ctrl_iface_reload.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -55,6 +55,7 @@
+@@ -54,6 +54,7 @@
  #include "fst/fst_ctrl_iface.h"
  #include "config_file.h"
  #include "ctrl_iface.h"
@@ -8,7 +8,7 @@
  
  
  #define HOSTAPD_CLI_DUP_VALUE_MAX_LEN 256
-@@ -73,6 +74,7 @@ static void hostapd_ctrl_iface_send(stru
+@@ -72,6 +73,7 @@ static void hostapd_ctrl_iface_send(stru
  				    enum wpa_msg_type type,
  				    const char *buf, size_t len);
  
@@ -16,7 +16,7 @@
  
  static int hostapd_ctrl_iface_attach(struct hostapd_data *hapd,
  				     struct sockaddr_storage *from,
-@@ -124,6 +126,61 @@ static int hostapd_ctrl_iface_new_sta(st
+@@ -123,6 +125,61 @@ static int hostapd_ctrl_iface_new_sta(st
  	return 0;
  }
  
@@ -78,7 +78,7 @@
  
  #ifdef CONFIG_IEEE80211W
  #ifdef NEED_AP_MLME
-@@ -2620,6 +2677,8 @@ static int hostapd_ctrl_iface_receive_pr
+@@ -2483,6 +2540,8 @@ static int hostapd_ctrl_iface_receive_pr
  	} else if (os_strncmp(buf, "VENDOR ", 7) == 0) {
  		reply_len = hostapd_ctrl_iface_vendor(hapd, buf + 7, reply,
  						      reply_size);
@@ -89,7 +89,7 @@
  #ifdef RADIUS_SERVER
 --- a/src/ap/ctrl_iface_ap.c
 +++ b/src/ap/ctrl_iface_ap.c
-@@ -624,7 +624,13 @@ int hostapd_parse_csa_settings(const cha
+@@ -593,7 +593,13 @@ int hostapd_parse_csa_settings(const cha
  
  int hostapd_ctrl_iface_stop_ap(struct hostapd_data *hapd)
  {
diff --git a/package/network/services/hostapd/patches/370-ap_sta_support.patch b/package/network/services/hostapd/patches/370-ap_sta_support.patch
index 03819b33725c399912443e1333c4f60e49a994ac..6b70215c437251c54889382191167490ffc9e377 100644
--- a/package/network/services/hostapd/patches/370-ap_sta_support.patch
+++ b/package/network/services/hostapd/patches/370-ap_sta_support.patch
@@ -34,8 +34,8 @@
  -include .config
  -include $(if $(MULTICALL),../hostapd/.config)
  
-@@ -115,6 +119,8 @@ OBJS_c += ../src/utils/common.o
- OBJS_c += ../src/common/cli.o
+@@ -113,6 +117,8 @@ OBJS_c += ../src/utils/wpa_debug.o
+ OBJS_c += ../src/utils/common.o
  OBJS += wmm_ac.o
  
 +OBJS += ../src/common/wpa_ctrl.o
@@ -101,7 +101,7 @@
  /* Configure default/group WEP keys for static WEP */
  int wpa_set_wep_keys(struct wpa_supplicant *wpa_s, struct wpa_ssid *ssid)
  {
-@@ -819,8 +868,12 @@ void wpa_supplicant_set_state(struct wpa
+@@ -812,8 +861,12 @@ void wpa_supplicant_set_state(struct wpa
  		wpas_p2p_completed(wpa_s);
  
  		sme_sched_obss_scan(wpa_s, 1);
@@ -114,7 +114,7 @@
  		wpa_s->new_connection = 1;
  		wpa_drv_set_operstate(wpa_s, 0);
  #ifndef IEEE8021X_EAPOL
-@@ -4790,6 +4843,20 @@ static int wpa_supplicant_init_iface(str
+@@ -4638,6 +4691,20 @@ static int wpa_supplicant_init_iface(str
  			   sizeof(wpa_s->bridge_ifname));
  	}
  
@@ -135,7 +135,7 @@
  	/* RSNA Supplicant Key Management - INITIALIZE */
  	eapol_sm_notify_portEnabled(wpa_s->eapol, FALSE);
  	eapol_sm_notify_portValid(wpa_s->eapol, FALSE);
-@@ -5083,6 +5150,11 @@ static void wpa_supplicant_deinit_iface(
+@@ -4929,6 +4996,11 @@ static void wpa_supplicant_deinit_iface(
  	if (terminate)
  		wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_TERMINATING);
  
@@ -155,9 +155,9 @@
  #include "common/ieee802_11_defs.h"
 +#include "common/ieee802_11_common.h"
  #include "drivers/driver.h"
- #include "eap_peer/eap.h"
  #include "wpa_supplicant_i.h"
-@@ -290,6 +291,10 @@ static void calculate_update_time(const
+ #include "config.h"
+@@ -287,6 +288,10 @@ static void calculate_update_time(const
  static void wpa_bss_copy_res(struct wpa_bss *dst, struct wpa_scan_res *src,
  			     struct os_reltime *fetch_time)
  {
@@ -168,7 +168,7 @@
  	dst->flags = src->flags;
  	os_memcpy(dst->bssid, src->bssid, ETH_ALEN);
  	dst->freq = src->freq;
-@@ -302,6 +307,15 @@ static void wpa_bss_copy_res(struct wpa_
+@@ -299,6 +304,15 @@ static void wpa_bss_copy_res(struct wpa_
  	dst->est_throughput = src->est_throughput;
  	dst->snr = src->snr;
  
@@ -199,7 +199,7 @@
  	       "  -g = global ctrl_interface\n"
  	       "  -G = global ctrl_interface group\n"
  	       "  -h = show this help text\n"
-+	       "  -H = connect to a hostapd instance to manage state changes\n"
++		   "  -H = connect to a hostapd instance to manage state changes\n"
  	       "  -i = interface name\n"
  	       "  -I = additional configuration file\n"
  	       "  -K = include keys (passwords, etc.) in debug output\n"
@@ -224,11 +224,11 @@
  			break;
 --- a/wpa_supplicant/bss.h
 +++ b/wpa_supplicant/bss.h
-@@ -80,6 +80,10 @@ struct wpa_bss {
+@@ -79,6 +79,10 @@ struct wpa_bss {
  	u8 ssid[SSID_MAX_LEN];
  	/** Length of SSID */
  	size_t ssid_len;
-+	/** HT capabilities */
++	/** HT caapbilities */
 +	u16 ht_capab;
 +	/* Five octets of HT Operation Information */
 +	u8 ht_param;
diff --git a/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch b/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
index b4729581c4aa4cc7e8e37ddbc605dd337b658a92..ef9c9db9a50907444e410ba5aa5b31f5b95a7083 100644
--- a/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
+++ b/package/network/services/hostapd/patches/380-disable_ctrl_iface_mib.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -220,6 +220,9 @@ endif
+@@ -212,6 +212,9 @@ endif
  ifdef CONFIG_NO_CTRL_IFACE
  CFLAGS += -DCONFIG_NO_CTRL_IFACE
  else
@@ -12,7 +12,7 @@
  else
 --- a/hostapd/ctrl_iface.c
 +++ b/hostapd/ctrl_iface.c
-@@ -2471,6 +2471,7 @@ static int hostapd_ctrl_iface_receive_pr
+@@ -2342,6 +2342,7 @@ static int hostapd_ctrl_iface_receive_pr
  						      reply_size);
  	} else if (os_strcmp(buf, "STATUS-DRIVER") == 0) {
  		reply_len = hostapd_drv_status(hapd, reply, reply_size);
@@ -20,7 +20,7 @@
  	} else if (os_strcmp(buf, "MIB") == 0) {
  		reply_len = ieee802_11_get_mib(hapd, reply, reply_size);
  		if (reply_len >= 0) {
-@@ -2512,6 +2513,7 @@ static int hostapd_ctrl_iface_receive_pr
+@@ -2383,6 +2384,7 @@ static int hostapd_ctrl_iface_receive_pr
  	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
  		reply_len = hostapd_ctrl_iface_sta_next(hapd, buf + 9, reply,
  							reply_size);
@@ -30,7 +30,7 @@
  			reply_len = -1;
 --- a/wpa_supplicant/Makefile
 +++ b/wpa_supplicant/Makefile
-@@ -891,6 +891,9 @@ ifdef CONFIG_MBO
+@@ -872,6 +872,9 @@ ifdef CONFIG_MBO
  OBJS += ../src/ap/mbo_ap.o
  endif
  ifdef CONFIG_CTRL_IFACE
@@ -42,7 +42,7 @@
  
 --- a/wpa_supplicant/ctrl_iface.c
 +++ b/wpa_supplicant/ctrl_iface.c
-@@ -1907,7 +1907,7 @@ static int wpa_supplicant_ctrl_iface_sta
+@@ -1895,7 +1895,7 @@ static int wpa_supplicant_ctrl_iface_sta
  			pos += ret;
  		}
  
@@ -51,7 +51,7 @@
  		if (wpa_s->ap_iface) {
  			pos += ap_ctrl_iface_wpa_get_status(wpa_s, pos,
  							    end - pos,
-@@ -9032,6 +9032,7 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -8687,6 +8687,7 @@ char * wpa_supplicant_ctrl_iface_process
  			reply_len = -1;
  	} else if (os_strncmp(buf, "NOTE ", 5) == 0) {
  		wpa_printf(MSG_INFO, "NOTE: %s", buf + 5);
@@ -59,7 +59,7 @@
  	} else if (os_strcmp(buf, "MIB") == 0) {
  		reply_len = wpa_sm_get_mib(wpa_s->wpa, reply, reply_size);
  		if (reply_len >= 0) {
-@@ -9039,6 +9040,7 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -8694,6 +8695,7 @@ char * wpa_supplicant_ctrl_iface_process
  						      reply + reply_len,
  						      reply_size - reply_len);
  		}
@@ -67,7 +67,7 @@
  	} else if (os_strncmp(buf, "STATUS", 6) == 0) {
  		reply_len = wpa_supplicant_ctrl_iface_status(
  			wpa_s, buf + 6, reply, reply_size);
-@@ -9517,6 +9519,7 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -9164,6 +9166,7 @@ char * wpa_supplicant_ctrl_iface_process
  		reply_len = wpa_supplicant_ctrl_iface_bss(
  			wpa_s, buf + 4, reply, reply_size);
  #ifdef CONFIG_AP
@@ -75,7 +75,7 @@
  	} else if (os_strcmp(buf, "STA-FIRST") == 0) {
  		reply_len = ap_ctrl_iface_sta_first(wpa_s, reply, reply_size);
  	} else if (os_strncmp(buf, "STA ", 4) == 0) {
-@@ -9525,12 +9528,15 @@ char * wpa_supplicant_ctrl_iface_process
+@@ -9172,12 +9175,15 @@ char * wpa_supplicant_ctrl_iface_process
  	} else if (os_strncmp(buf, "STA-NEXT ", 9) == 0) {
  		reply_len = ap_ctrl_iface_sta_next(wpa_s, buf + 9, reply,
  						   reply_size);
@@ -93,15 +93,15 @@
  			reply_len = -1;
 --- a/src/ap/ctrl_iface_ap.c
 +++ b/src/ap/ctrl_iface_ap.c
-@@ -25,6 +25,7 @@
+@@ -24,6 +24,7 @@
+ #include "ap_drv_ops.h"
  #include "mbo_ap.h"
- #include "taxonomy.h"
  
 +#ifdef CONFIG_CTRL_IFACE_MIB
  
  static int hostapd_get_sta_tx_rx(struct hostapd_data *hapd,
  				 struct sta_info *sta,
-@@ -250,6 +251,7 @@ int hostapd_ctrl_iface_sta_next(struct h
+@@ -249,6 +250,7 @@ int hostapd_ctrl_iface_sta_next(struct h
  	return hostapd_ctrl_iface_sta_mib(hapd, sta->next, buf, buflen);
  }
  
@@ -111,7 +111,7 @@
  static int p2p_manager_disconnect(struct hostapd_data *hapd, u16 stype,
 --- a/src/ap/ieee802_1x.c
 +++ b/src/ap/ieee802_1x.c
-@@ -2490,6 +2490,7 @@ static const char * bool_txt(Boolean val
+@@ -2441,6 +2441,7 @@ static const char * bool_txt(Boolean val
  	return val ? "TRUE" : "FALSE";
  }
  
@@ -119,7 +119,7 @@
  
  int ieee802_1x_get_mib(struct hostapd_data *hapd, char *buf, size_t buflen)
  {
-@@ -2665,6 +2666,7 @@ int ieee802_1x_get_mib_sta(struct hostap
+@@ -2616,6 +2617,7 @@ int ieee802_1x_get_mib_sta(struct hostap
  	return len;
  }
  
@@ -129,7 +129,7 @@
  static void ieee802_1x_wnm_notif_send(void *eloop_ctx, void *timeout_ctx)
 --- a/src/ap/wpa_auth.c
 +++ b/src/ap/wpa_auth.c
-@@ -3565,6 +3565,7 @@ static const char * wpa_bool_txt(int val
+@@ -3069,6 +3069,7 @@ static const char * wpa_bool_txt(int val
  	return val ? "TRUE" : "FALSE";
  }
  
@@ -137,7 +137,7 @@
  
  #define RSN_SUITE "%02x-%02x-%02x-%d"
  #define RSN_SUITE_ARG(s) \
-@@ -3709,7 +3710,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
+@@ -3213,7 +3214,7 @@ int wpa_get_mib_sta(struct wpa_state_mac
  
  	return len;
  }
@@ -148,7 +148,7 @@
  {
 --- a/src/rsn_supp/wpa.c
 +++ b/src/rsn_supp/wpa.c
-@@ -2308,6 +2308,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
+@@ -2108,6 +2108,8 @@ static u32 wpa_key_mgmt_suite(struct wpa
  }
  
  
@@ -157,7 +157,7 @@
  #define RSN_SUITE "%02x-%02x-%02x-%d"
  #define RSN_SUITE_ARG(s) \
  ((s) >> 24) & 0xff, ((s) >> 16) & 0xff, ((s) >> 8) & 0xff, (s) & 0xff
-@@ -2391,6 +2393,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
+@@ -2191,6 +2193,7 @@ int wpa_sm_get_mib(struct wpa_sm *sm, ch
  
  	return (int) len;
  }
@@ -167,7 +167,7 @@
  
 --- a/wpa_supplicant/ap.c
 +++ b/wpa_supplicant/ap.c
-@@ -1119,7 +1119,7 @@ int wpas_ap_wps_nfc_report_handover(stru
+@@ -1114,7 +1114,7 @@ int wpas_ap_wps_nfc_report_handover(stru
  #endif /* CONFIG_WPS */
  
  
diff --git a/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch b/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
index 7f147aec1d97762a5e8e3711bc8b88abf16041ea..c9e7bf4209fcde62dd965cd12754e6876067ed01 100644
--- a/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
+++ b/package/network/services/hostapd/patches/390-wpa_ie_cap_workaround.patch
@@ -1,6 +1,6 @@
 --- a/src/common/wpa_common.c
 +++ b/src/common/wpa_common.c
-@@ -1445,6 +1445,31 @@ u32 wpa_akm_to_suite(int akm)
+@@ -1244,6 +1244,31 @@ u32 wpa_akm_to_suite(int akm)
  }
  
  
@@ -32,7 +32,7 @@
  int wpa_compare_rsn_ie(int ft_initial_assoc,
  		       const u8 *ie1, size_t ie1len,
  		       const u8 *ie2, size_t ie2len)
-@@ -1452,8 +1477,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
+@@ -1251,8 +1276,19 @@ int wpa_compare_rsn_ie(int ft_initial_as
  	if (ie1 == NULL || ie2 == NULL)
  		return -1;
  
diff --git a/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch b/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch
index c10176371f7c982b8500ed979b968ff1e8c61e04..f5872cd5979e48aa0f918635af0852f2c1acb027 100644
--- a/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch
+++ b/package/network/services/hostapd/patches/400-wps_single_auth_enc_type.patch
@@ -1,6 +1,6 @@
 --- a/src/ap/wps_hostapd.c
 +++ b/src/ap/wps_hostapd.c
-@@ -346,8 +346,7 @@ static int hapd_wps_reconfig_in_memory(s
+@@ -352,8 +352,7 @@ static int hapd_wps_reconfig_in_memory(s
  				bss->wpa_pairwise |= WPA_CIPHER_GCMP;
  			else
  				bss->wpa_pairwise |= WPA_CIPHER_CCMP;
@@ -10,7 +10,7 @@
  			bss->wpa_pairwise |= WPA_CIPHER_TKIP;
  		bss->rsn_pairwise = bss->wpa_pairwise;
  		bss->wpa_group = wpa_select_ap_group_cipher(bss->wpa,
-@@ -1067,8 +1066,7 @@ int hostapd_init_wps(struct hostapd_data
+@@ -1073,8 +1072,7 @@ int hostapd_init_wps(struct hostapd_data
  		if (conf->rsn_pairwise & (WPA_CIPHER_CCMP | WPA_CIPHER_GCMP)) {
  			wps->encr_types |= WPS_ENCR_AES;
  			wps->encr_types_rsn |= WPS_ENCR_AES;
diff --git a/package/network/services/hostapd/patches/410-limit_debug_messages.patch b/package/network/services/hostapd/patches/410-limit_debug_messages.patch
index b7dbbd0dc7e29c63347075657794080a65ede06d..a48b6962ee3e420f4abc79e772b9bcb049559dee 100644
--- a/package/network/services/hostapd/patches/410-limit_debug_messages.patch
+++ b/package/network/services/hostapd/patches/410-limit_debug_messages.patch
@@ -84,7 +84,7 @@
  	char *buf;
 --- a/src/utils/wpa_debug.h
 +++ b/src/utils/wpa_debug.h
-@@ -52,6 +52,17 @@ int wpa_debug_reopen_file(void);
+@@ -49,6 +49,17 @@ int wpa_debug_reopen_file(void);
  void wpa_debug_close_file(void);
  void wpa_debug_setup_stdout(void);
  
@@ -102,7 +102,7 @@
  /**
   * wpa_debug_printf_timestamp - Print timestamp for debug output
   *
-@@ -72,9 +83,15 @@ void wpa_debug_print_timestamp(void);
+@@ -69,9 +80,15 @@ void wpa_debug_print_timestamp(void);
   *
   * Note: New line '\n' is added to the end of the text when printing to stdout.
   */
@@ -119,7 +119,7 @@
  /**
   * wpa_hexdump - conditional hex dump
   * @level: priority level (MSG_*) of the message
-@@ -86,7 +103,13 @@ PRINTF_FORMAT(2, 3);
+@@ -83,7 +100,13 @@ PRINTF_FORMAT(2, 3);
   * output may be directed to stdout, stderr, and/or syslog based on
   * configuration. The contents of buf is printed out has hex dump.
   */
@@ -134,7 +134,7 @@
  
  static inline void wpa_hexdump_buf(int level, const char *title,
  				   const struct wpabuf *buf)
-@@ -108,7 +131,13 @@ static inline void wpa_hexdump_buf(int l
+@@ -105,7 +128,13 @@ static inline void wpa_hexdump_buf(int l
   * like wpa_hexdump(), but by default, does not include secret keys (passwords,
   * etc.) in debug output.
   */
@@ -149,7 +149,7 @@
  
  static inline void wpa_hexdump_buf_key(int level, const char *title,
  				       const struct wpabuf *buf)
-@@ -130,8 +159,14 @@ static inline void wpa_hexdump_buf_key(i
+@@ -127,8 +156,14 @@ static inline void wpa_hexdump_buf_key(i
   * the hex numbers and ASCII characters (for printable range) are shown. 16
   * bytes per line will be shown.
   */
@@ -166,7 +166,7 @@
  
  /**
   * wpa_hexdump_ascii_key - conditional hex dump, hide keys
-@@ -147,8 +182,14 @@ void wpa_hexdump_ascii(int level, const
+@@ -144,8 +179,14 @@ void wpa_hexdump_ascii(int level, const
   * bytes per line will be shown. This works like wpa_hexdump_ascii(), but by
   * default, does not include secret keys (passwords, etc.) in debug output.
   */
@@ -183,7 +183,7 @@
  
  /*
   * wpa_dbg() behaves like wpa_msg(), but it can be removed from build to reduce
-@@ -185,7 +226,12 @@ void wpa_hexdump_ascii_key(int level, co
+@@ -182,7 +223,12 @@ void wpa_hexdump_ascii_key(int level, co
   *
   * Note: New line '\n' is added to the end of the text when printing to stdout.
   */
@@ -197,7 +197,7 @@
  
  /**
   * wpa_msg_ctrl - Conditional printf for ctrl_iface monitors
-@@ -199,8 +245,13 @@ void wpa_msg(void *ctx, int level, const
+@@ -196,8 +242,13 @@ void wpa_msg(void *ctx, int level, const
   * attached ctrl_iface monitors. In other words, it can be used for frequent
   * events that do not need to be sent to syslog.
   */
diff --git a/package/network/services/hostapd/patches/420-indicate-features.patch b/package/network/services/hostapd/patches/420-indicate-features.patch
index ac699f4e495d43eaec7ef6503706ca483c4ce9e7..335e71eb519851305f813b4aa95ca5239b7e46f9 100644
--- a/package/network/services/hostapd/patches/420-indicate-features.patch
+++ b/package/network/services/hostapd/patches/420-indicate-features.patch
@@ -8,16 +8,16 @@
  #include "crypto/random.h"
  #include "crypto/tls.h"
  #include "common/version.h"
-@@ -675,7 +676,7 @@ int main(int argc, char *argv[])
+@@ -668,7 +669,7 @@ int main(int argc, char *argv[])
  	wpa_supplicant_event = hostapd_wpa_event;
  	wpa_supplicant_event_global = hostapd_wpa_event_global;
  	for (;;) {
--		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:vg:G:");
-+		c = getopt(argc, argv, "b:Bde:f:hi:KP:sSTtu:g:G:v::");
+-		c = getopt(argc, argv, "b:Bde:f:hi:KP:STtu:vg:G:");
++		c = getopt(argc, argv, "b:Bde:f:hi:KP:STtu:g:G:v::");
  		if (c < 0)
  			break;
  		switch (c) {
-@@ -712,6 +713,8 @@ int main(int argc, char *argv[])
+@@ -705,6 +706,8 @@ int main(int argc, char *argv[])
  			break;
  #endif /* CONFIG_DEBUG_LINUX_TRACING */
  		case 'v':
@@ -60,3 +60,23 @@
  			goto out;
  		case 'W':
  			params.wait_for_monitor++;
+--- /dev/null
++++ b/src/utils/build_features.h
+@@ -0,0 +1,17 @@
++#ifndef BUILD_FEATURES_H
++#define BUILD_FEATURES_H
++
++static inline int has_feature(const char *feat)
++{
++#ifdef IEEE8021X_EAPOL
++	if (!strcmp(feat, "eap"))
++		return 1;
++#endif
++#ifdef IEEE80211N
++	if (!strcmp(feat, "11n"))
++		return 1;
++#endif
++	return 0;
++}
++
++#endif /* BUILD_FEATURES_H */
diff --git a/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch b/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
index eba79d28c4d0f991b71d8a4214cc1cc3b0fe24bb..d07b747c3d299dd1561251fcfd5a89a41214edb5 100644
--- a/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
+++ b/package/network/services/hostapd/patches/430-hostapd_cli_ifdef.patch
@@ -1,6 +1,22 @@
 --- a/hostapd/hostapd_cli.c
 +++ b/hostapd/hostapd_cli.c
-@@ -447,7 +447,6 @@ static int hostapd_cli_cmd_sa_query(stru
+@@ -69,7 +69,6 @@ static const char *const commands_help =
+ #ifdef CONFIG_IEEE80211W
+ "   sa_query <addr>      send SA Query to a station\n"
+ #endif /* CONFIG_IEEE80211W */
+-#ifdef CONFIG_WPS
+ "   wps_pin <uuid> <pin> [timeout] [addr]  add WPS Enrollee PIN\n"
+ "   wps_check_pin <PIN>  verify PIN checksum\n"
+ "   wps_pbc              indicate button pushed to initiate PBC\n"
+@@ -82,7 +81,6 @@ static const char *const commands_help =
+ "   wps_ap_pin <cmd> [params..]  enable/disable AP PIN\n"
+ "   wps_config <SSID> <auth> <encr> <key>  configure AP\n"
+ "   wps_get_status       show current WPS status\n"
+-#endif /* CONFIG_WPS */
+ "   get_config           show current configuration\n"
+ "   help                 show this usage help\n"
+ "   interface [ifname]   show interfaces/select interface\n"
+@@ -418,7 +416,6 @@ static int hostapd_cli_cmd_sa_query(stru
  #endif /* CONFIG_IEEE80211W */
  
  
@@ -8,7 +24,7 @@
  static int hostapd_cli_cmd_wps_pin(struct wpa_ctrl *ctrl, int argc,
  				   char *argv[])
  {
-@@ -673,7 +672,6 @@ static int hostapd_cli_cmd_wps_config(st
+@@ -644,7 +641,6 @@ static int hostapd_cli_cmd_wps_config(st
  			 ssid_hex, argv[1]);
  	return wpa_ctrl_command(ctrl, buf);
  }
@@ -16,19 +32,19 @@
  
  
  static int hostapd_cli_cmd_disassoc_imminent(struct wpa_ctrl *ctrl, int argc,
-@@ -1367,7 +1365,6 @@ static const struct hostapd_cli_cmd host
- 	{ "sa_query", hostapd_cli_cmd_sa_query, NULL,
- 	  "<addr> = send SA Query to a station" },
+@@ -1236,7 +1232,6 @@ static const struct hostapd_cli_cmd host
+ #ifdef CONFIG_IEEE80211W
+ 	{ "sa_query", hostapd_cli_cmd_sa_query },
  #endif /* CONFIG_IEEE80211W */
 -#ifdef CONFIG_WPS
- 	{ "wps_pin", hostapd_cli_cmd_wps_pin, NULL,
- 	  "<uuid> <pin> [timeout] [addr] = add WPS Enrollee PIN" },
- 	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin, NULL,
-@@ -1392,7 +1389,6 @@ static const struct hostapd_cli_cmd host
- 	  "<SSID> <auth> <encr> <key> = configure AP" },
- 	{ "wps_get_status", hostapd_cli_cmd_wps_get_status, NULL,
- 	  "= show current WPS status" },
+ 	{ "wps_pin", hostapd_cli_cmd_wps_pin },
+ 	{ "wps_check_pin", hostapd_cli_cmd_wps_check_pin },
+ 	{ "wps_pbc", hostapd_cli_cmd_wps_pbc },
+@@ -1250,7 +1245,6 @@ static const struct hostapd_cli_cmd host
+ 	{ "wps_ap_pin", hostapd_cli_cmd_wps_ap_pin },
+ 	{ "wps_config", hostapd_cli_cmd_wps_config },
+ 	{ "wps_get_status", hostapd_cli_cmd_wps_get_status },
 -#endif /* CONFIG_WPS */
- 	{ "disassoc_imminent", hostapd_cli_cmd_disassoc_imminent, NULL, NULL },
- 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc, NULL, NULL },
- 	{ "bss_tm_req", hostapd_cli_cmd_bss_tm_req, NULL, NULL },
+ 	{ "disassoc_imminent", hostapd_cli_cmd_disassoc_imminent },
+ 	{ "ess_disassoc", hostapd_cli_cmd_ess_disassoc },
+ 	{ "bss_tm_req", hostapd_cli_cmd_bss_tm_req },
diff --git a/package/network/services/hostapd/patches/431-wpa_cli_ifdef.patch b/package/network/services/hostapd/patches/431-wpa_cli_ifdef.patch
index 2c9fe28a1d617f804f821ac8696d7093bb1553c0..256f6b5977323b00215927a0051738eda376eef7 100644
--- a/package/network/services/hostapd/patches/431-wpa_cli_ifdef.patch
+++ b/package/network/services/hostapd/patches/431-wpa_cli_ifdef.patch
@@ -1,6 +1,6 @@
 --- a/wpa_supplicant/wpa_cli.c
 +++ b/wpa_supplicant/wpa_cli.c
-@@ -26,6 +26,9 @@
+@@ -25,6 +25,9 @@
  #include <cutils/properties.h>
  #endif /* ANDROID */
  
diff --git a/package/network/services/hostapd/patches/450-scan_wait.patch b/package/network/services/hostapd/patches/450-scan_wait.patch
index 463a36291114f760ad9f53f4ff8ab35be4beb774..78cf3064fa6fbf5abf89d5c7388e8a99e8ba988e 100644
--- a/package/network/services/hostapd/patches/450-scan_wait.patch
+++ b/package/network/services/hostapd/patches/450-scan_wait.patch
@@ -9,7 +9,7 @@
  
  
  #ifndef CONFIG_NO_HOSTAPD_LOGGER
-@@ -147,6 +149,14 @@ static void hostapd_logger_cb(void *ctx,
+@@ -143,6 +145,14 @@ static void hostapd_logger_cb(void *ctx,
  }
  #endif /* CONFIG_NO_HOSTAPD_LOGGER */
  
@@ -24,7 +24,7 @@
  
  /**
   * hostapd_driver_init - Preparate driver interface
-@@ -165,6 +175,8 @@ static int hostapd_driver_init(struct ho
+@@ -161,6 +171,8 @@ static int hostapd_driver_init(struct ho
  		return -1;
  	}
  
@@ -33,7 +33,7 @@
  	/* Initialize the driver interface */
  	if (!(b[0] | b[1] | b[2] | b[3] | b[4] | b[5]))
  		b = NULL;
-@@ -405,8 +417,6 @@ static void hostapd_global_deinit(const
+@@ -401,8 +413,6 @@ static void hostapd_global_deinit(const
  #endif /* CONFIG_NATIVE_WINDOWS */
  
  	eap_server_unregister_methods();
@@ -42,7 +42,7 @@
  }
  
  
-@@ -432,18 +442,6 @@ static int hostapd_global_run(struct hap
+@@ -428,18 +438,6 @@ static int hostapd_global_run(struct hap
  	}
  #endif /* EAP_SERVER_TNC */
  
@@ -61,7 +61,7 @@
  	eloop_run();
  
  	return 0;
-@@ -645,8 +643,7 @@ int main(int argc, char *argv[])
+@@ -638,8 +636,7 @@ int main(int argc, char *argv[])
  	struct hapd_interfaces interfaces;
  	int ret = 1;
  	size_t i, j;
diff --git a/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch b/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
index 1aeec5d05397e140eea7f8c9de1a27b2563c9dde..ec84b9a4b26c6a164dc43bae26e19e7528c7a7ec 100644
--- a/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
+++ b/package/network/services/hostapd/patches/460-wpa_supplicant-add-new-config-params-to-be-used-with.patch
@@ -18,15 +18,15 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  
  #define WPA_SUPPLICANT_DRIVER_VERSION 4
  
-+#include "ap/sta_info.h"
++#include "drivers/nl80211_copy.h"
  #include "common/defs.h"
  #include "common/ieee802_11_defs.h"
- #ifdef CONFIG_MACSEC
-@@ -605,6 +606,9 @@ struct wpa_driver_associate_params {
+ #include "utils/list.h"
+@@ -587,6 +588,9 @@ struct wpa_driver_associate_params {
  	 * responsible for selecting with which BSS to associate. */
  	const u8 *bssid;
  
-+	unsigned char rates[WLAN_SUPP_RATES_MAX];
++	unsigned char rates[NL80211_MAX_SUPP_RATES];
 +	int mcast_rate;
 +
  	/**
@@ -38,12 +38,12 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  #include "eap_peer/eap.h"
  #include "p2p/p2p.h"
  #include "fst/fst.h"
-+#include "ap/sta_info.h"
++#include "drivers/nl80211_copy.h"
  #include "config.h"
  
  
-@@ -1891,6 +1892,97 @@ static char * wpa_config_write_mka_ckn(c
- #endif /* CONFIG_MACSEC */
+@@ -1816,6 +1817,97 @@ static char * wpa_config_write_mesh_basi
+ #endif /* CONFIG_MESH */
  
  
 +static int wpa_config_parse_mcast_rate(const struct parse_data *data,
@@ -88,7 +88,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
 +	pos = (char *)value;
 +	r = strtok_r(pos, ",", &sptr);
 +	i = 0;
-+	while (pos && i < WLAN_SUPP_RATES_MAX) {
++	while (pos && i < NL80211_MAX_SUPP_RATES) {
 +		rate = 0.0;
 +		if (r)
 +			rate = strtod(r, &end);
@@ -113,11 +113,11 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
 +	if (ssid->rates[0] <= 0)
 +		return NULL;
 +
-+	value = os_malloc(6 * WLAN_SUPP_RATES_MAX + 1);
++	value = os_malloc(6 * NL80211_MAX_SUPP_RATES + 1);
 +	if (value == NULL)
 +		return NULL;
 +	pos = value;
-+	for (i = 0; i < WLAN_SUPP_RATES_MAX - 1; i++) {
++	for (i = 0; i < NL80211_MAX_SUPP_RATES - 1; i++) {
 +		res = os_snprintf(pos, 6, "%.1f,", (double)ssid->rates[i] / 2);
 +		if (res < 0) {
 +			os_free(value);
@@ -126,13 +126,13 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
 +		pos += res;
 +	}
 +	res = os_snprintf(pos, 6, "%.1f",
-+			  (double)ssid->rates[WLAN_SUPP_RATES_MAX - 1] / 2);
++			  (double)ssid->rates[NL80211_MAX_SUPP_RATES - 1] / 2);
 +	if (res < 0) {
 +		os_free(value);
 +		return NULL;
 +	}
 +
-+	value[6 * WLAN_SUPP_RATES_MAX] = '\0';
++	value[6 * NL80211_MAX_SUPP_RATES] = '\0';
 +	return value;
 +}
 +#endif /* NO_CONFIG_WRITE */
@@ -140,7 +140,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  /* Helper macros for network block parser */
  
  #ifdef OFFSET
-@@ -2123,6 +2215,9 @@ static const struct parse_data ssid_fiel
+@@ -2047,6 +2139,9 @@ static const struct parse_data ssid_fiel
  	{ INT(ap_max_inactivity) },
  	{ INT(dtim_period) },
  	{ INT(beacon_int) },
@@ -149,25 +149,22 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
 +	{ FUNC(mcast_rate) },
  #ifdef CONFIG_MACSEC
  	{ INT_RANGE(macsec_policy, 0, 1) },
- 	{ INT_RANGE(macsec_integ_only, 0, 1) },
+ #endif /* CONFIG_MACSEC */
 --- a/wpa_supplicant/config_ssid.h
 +++ b/wpa_supplicant/config_ssid.h
-@@ -10,8 +10,10 @@
- #define CONFIG_SSID_H
- 
+@@ -12,6 +12,7 @@
  #include "common/defs.h"
-+#include "ap/sta_info.h"
  #include "utils/list.h"
  #include "eap_peer/eap_config.h"
 +#include "drivers/nl80211_copy.h"
  
  
  #define DEFAULT_EAP_WORKAROUND ((unsigned int) -1)
-@@ -719,6 +721,9 @@ struct wpa_ssid {
+@@ -711,6 +712,9 @@ struct wpa_ssid {
  	 */
  	void *parent_cred;
  
-+	unsigned char rates[WLAN_SUPP_RATES_MAX];
++	unsigned char rates[NL80211_MAX_SUPP_RATES];
 +	double mcast_rate;
 +
  #ifdef CONFIG_MACSEC
@@ -175,13 +172,13 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  	 * macsec_policy - Determines the policy for MACsec secure session
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2561,6 +2561,13 @@ static void wpas_start_assoc_cb(struct w
+@@ -2510,6 +2510,13 @@ static void wpas_start_assoc_cb(struct w
  			params.beacon_int = ssid->beacon_int;
  		else
  			params.beacon_int = wpa_s->conf->beacon_int;
 +		params.fixed_freq = ssid->fixed_freq;
 +		i = 0;
-+		while (i < WLAN_SUPP_RATES_MAX) {
++		while (i < NL80211_MAX_SUPP_RATES) {
 +			params.rates[i] = ssid->rates[i];
 +			i++;
 +		}
diff --git a/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch b/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
index 6db61333e1cf0355ea4ef52024f585d89a573dde..459bdb944ae2d5f6820594b261ccfc77b52ab5d3 100644
--- a/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
+++ b/package/network/services/hostapd/patches/461-driver_nl80211-use-new-parameters-during-ibss-join.patch
@@ -10,7 +10,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
 
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -4962,7 +4962,7 @@ static int wpa_driver_nl80211_ibss(struc
+@@ -4644,7 +4644,7 @@ static int wpa_driver_nl80211_ibss(struc
  				   struct wpa_driver_associate_params *params)
  {
  	struct nl_msg *msg;
@@ -19,7 +19,7 @@ Signed-hostap: Antonio Quartulli <ordex@autistici.org>
  	int count = 0;
  
  	wpa_printf(MSG_DEBUG, "nl80211: Join IBSS (ifindex=%d)", drv->ifindex);
-@@ -4989,6 +4989,37 @@ retry:
+@@ -4671,6 +4671,37 @@ retry:
  	    nl80211_put_beacon_int(msg, params->beacon_int))
  		goto fail;
  
diff --git a/package/network/services/hostapd/patches/462-wpa_s-support-htmode-param.patch b/package/network/services/hostapd/patches/462-wpa_s-support-htmode-param.patch
index c4b48a938ea5281f7d84df89a0eceb1e00b82d19..e2bd37d7a56051a204db7dca19909346764462f6 100644
--- a/package/network/services/hostapd/patches/462-wpa_s-support-htmode-param.patch
+++ b/package/network/services/hostapd/patches/462-wpa_s-support-htmode-param.patch
@@ -16,9 +16,9 @@ Signed-off-by: Antonio Quartulli <ordex@autistici.org>
 
 --- a/src/drivers/driver.h
 +++ b/src/drivers/driver.h
-@@ -608,6 +608,8 @@ struct wpa_driver_associate_params {
+@@ -590,6 +590,8 @@ struct wpa_driver_associate_params {
  
- 	unsigned char rates[WLAN_SUPP_RATES_MAX];
+ 	unsigned char rates[NL80211_MAX_SUPP_RATES];
  	int mcast_rate;
 +	int ht_set;
 +	unsigned int htmode;
@@ -27,7 +27,7 @@ Signed-off-by: Antonio Quartulli <ordex@autistici.org>
  	 * bssid_hint - BSSID of a proposed AP
 --- a/src/drivers/driver_nl80211.c
 +++ b/src/drivers/driver_nl80211.c
-@@ -5020,6 +5020,22 @@ retry:
+@@ -4702,6 +4702,22 @@ retry:
  		nla_put_u32(msg, NL80211_ATTR_MCAST_RATE, params->mcast_rate);
  	}
  
@@ -52,7 +52,7 @@ Signed-off-by: Antonio Quartulli <ordex@autistici.org>
  		goto fail;
 --- a/wpa_supplicant/config.c
 +++ b/wpa_supplicant/config.c
-@@ -1923,6 +1923,71 @@ static char * wpa_config_write_mcast_rat
+@@ -1848,6 +1848,71 @@ static char * wpa_config_write_mcast_rat
  }
  #endif /* NO_CONFIG_WRITE */
  
@@ -124,19 +124,19 @@ Signed-off-by: Antonio Quartulli <ordex@autistici.org>
  static int wpa_config_parse_rates(const struct parse_data *data,
  				  struct wpa_ssid *ssid, int line,
  				  const char *value)
-@@ -2218,6 +2283,7 @@ static const struct parse_data ssid_fiel
+@@ -2142,6 +2207,7 @@ static const struct parse_data ssid_fiel
  	{ INT_RANGE(fixed_freq, 0, 1) },
  	{ FUNC(rates) },
  	{ FUNC(mcast_rate) },
 +	{ FUNC(htmode) },
  #ifdef CONFIG_MACSEC
  	{ INT_RANGE(macsec_policy, 0, 1) },
- 	{ INT_RANGE(macsec_integ_only, 0, 1) },
+ #endif /* CONFIG_MACSEC */
 --- a/wpa_supplicant/config_ssid.h
 +++ b/wpa_supplicant/config_ssid.h
-@@ -723,6 +723,8 @@ struct wpa_ssid {
+@@ -714,6 +714,8 @@ struct wpa_ssid {
  
- 	unsigned char rates[WLAN_SUPP_RATES_MAX];
+ 	unsigned char rates[NL80211_MAX_SUPP_RATES];
  	double mcast_rate;
 +	int ht_set;
 +	unsigned int htmode;
@@ -145,7 +145,7 @@ Signed-off-by: Antonio Quartulli <ordex@autistici.org>
  	/**
 --- a/wpa_supplicant/wpa_supplicant.c
 +++ b/wpa_supplicant/wpa_supplicant.c
-@@ -2568,6 +2568,8 @@ static void wpas_start_assoc_cb(struct w
+@@ -2517,6 +2517,8 @@ static void wpas_start_assoc_cb(struct w
  			i++;
  		}
  		params.mcast_rate = ssid->mcast_rate;
diff --git a/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch b/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
deleted file mode 100644
index da146ba55eefe7a9ce49b9312e350a47d1800a67..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/463-add-mcast_rate-to-11s.patch
+++ /dev/null
@@ -1,68 +0,0 @@
-From: Sven Eckelmann <sven.eckelmann@openmesh.com>
-Date: Thu, 11 May 2017 08:21:45 +0200
-Subject: [PATCH] set mcast_rate in mesh mode
-
-The wpa_supplicant code for IBSS allows to set the mcast rate. It is
-recommended to increase this value from 1 or 6 Mbit/s to something higher
-when using a mesh protocol on top which uses the multicast packet loss as
-indicator for the link quality.
-
-This setting was unfortunately not applied for mesh mode. But it would be
-beneficial when wpa_supplicant would behave similar to IBSS mode and set
-this argument during mesh join like authsae already does. At least it is
-helpful for companies/projects which are currently switching to 802.11s
-(without mesh_fwding and with mesh_ttl set to 1) as replacement for IBSS
-because newer drivers seem to support 802.11s but not IBSS anymore.
-
-Signed-off-by: Sven Eckelmann <sven.eckelmann@openmesh.com>
-Tested-by: Simon Wunderlich <simon.wunderlich@openmesh.com>
-
---- a/src/drivers/driver.h
-+++ b/src/drivers/driver.h
-@@ -1426,6 +1426,7 @@ struct wpa_driver_mesh_join_params {
- #define WPA_DRIVER_MESH_FLAG_SAE_AUTH	0x00000004
- #define WPA_DRIVER_MESH_FLAG_AMPE	0x00000008
- 	unsigned int flags;
-+	int mcast_rate;
- };
- 
- /**
---- a/src/drivers/driver_nl80211.c
-+++ b/src/drivers/driver_nl80211.c
-@@ -8997,6 +8997,18 @@ static int nl80211_put_mesh_id(struct nl
- }
- 
- 
-+static int nl80211_put_mcast_rate(struct nl_msg *msg, int mcast_rate)
-+{
-+	if (mcast_rate > 0) {
-+		wpa_printf(MSG_DEBUG, "  * mcast_rate=%.1f",
-+			   (double)mcast_rate / 10);
-+		return nla_put_u32(msg, NL80211_ATTR_MCAST_RATE, mcast_rate);
-+	}
-+
-+	return 0;
-+}
-+
-+
- static int nl80211_put_mesh_config(struct nl_msg *msg,
- 				   struct wpa_driver_mesh_bss_params *params)
- {
-@@ -9055,6 +9067,7 @@ static int nl80211_join_mesh(struct i802
- 	    nl80211_put_basic_rates(msg, params->basic_rates) ||
- 	    nl80211_put_mesh_id(msg, params->meshid, params->meshid_len) ||
- 	    nl80211_put_beacon_int(msg, params->beacon_int) ||
-+	    nl80211_put_mcast_rate(msg, params->mcast_rate) ||
- 	    nl80211_put_dtim_period(msg, params->dtim_period))
- 		goto fail;
- 
---- a/wpa_supplicant/mesh.c
-+++ b/wpa_supplicant/mesh.c
-@@ -379,6 +379,7 @@ int wpa_supplicant_join_mesh(struct wpa_
- 	os_memset(&params, 0, sizeof(params));
- 	params.meshid = ssid->ssid;
- 	params.meshid_len = ssid->ssid_len;
-+	params.mcast_rate = ssid->mcast_rate;
- 	ibss_mesh_setup_freq(wpa_s, ssid, &params.freq);
- 	wpa_s->mesh_ht_enabled = !!params.freq.ht_enabled;
- 	wpa_s->mesh_vht_enabled = !!params.freq.vht_enabled;
diff --git a/package/network/services/hostapd/patches/470-survey_data_fallback.patch b/package/network/services/hostapd/patches/470-survey_data_fallback.patch
deleted file mode 100644
index 4e40a87558949483954950f72d30ac30a17877e9..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/470-survey_data_fallback.patch
+++ /dev/null
@@ -1,45 +0,0 @@
---- a/src/ap/acs.c
-+++ b/src/ap/acs.c
-@@ -292,18 +292,12 @@ static void acs_fail(struct hostapd_ifac
- static long double
- acs_survey_interference_factor(struct freq_survey *survey, s8 min_nf)
- {
--	long double factor, busy, total;
-+	long double factor, busy = 0, total;
- 
- 	if (survey->filled & SURVEY_HAS_CHAN_TIME_BUSY)
- 		busy = survey->channel_time_busy;
- 	else if (survey->filled & SURVEY_HAS_CHAN_TIME_RX)
- 		busy = survey->channel_time_rx;
--	else {
--		/* This shouldn't really happen as survey data is checked in
--		 * acs_sanity_check() */
--		wpa_printf(MSG_ERROR, "ACS: Survey data missing");
--		return 0;
--	}
- 
- 	total = survey->channel_time;
- 
-@@ -395,20 +389,19 @@ static int acs_usable_vht80_chan(struct
- static int acs_survey_is_sufficient(struct freq_survey *survey)
- {
- 	if (!(survey->filled & SURVEY_HAS_NF)) {
-+		survey->nf = -95;
- 		wpa_printf(MSG_INFO, "ACS: Survey is missing noise floor");
--		return 0;
- 	}
- 
- 	if (!(survey->filled & SURVEY_HAS_CHAN_TIME)) {
-+		survey->channel_time = 0;
- 		wpa_printf(MSG_INFO, "ACS: Survey is missing channel time");
--		return 0;
- 	}
- 
- 	if (!(survey->filled & SURVEY_HAS_CHAN_TIME_BUSY) &&
- 	    !(survey->filled & SURVEY_HAS_CHAN_TIME_RX)) {
- 		wpa_printf(MSG_INFO,
- 			   "ACS: Survey is missing RX and busy time (at least one is required)");
--		return 0;
- 	}
- 
- 	return 1;
diff --git a/package/network/services/hostapd/patches/600-ubus_support.patch b/package/network/services/hostapd/patches/600-ubus_support.patch
index dd962b47a6db9714fca011144f2aedb17d982fab..55da4b678d6bd9942490e00727e169f572a97f02 100644
--- a/package/network/services/hostapd/patches/600-ubus_support.patch
+++ b/package/network/services/hostapd/patches/600-ubus_support.patch
@@ -1,6 +1,6 @@
 --- a/hostapd/Makefile
 +++ b/hostapd/Makefile
-@@ -165,6 +165,11 @@ OBJS += ../src/common/hw_features_common
+@@ -157,6 +157,11 @@ OBJS += ../src/common/hw_features_common
  
  OBJS += ../src/eapol_auth/eapol_auth_sm.o
  
@@ -22,7 +22,7 @@
  
  struct wpa_ctrl_dst;
  struct radius_server_data;
-@@ -119,6 +120,7 @@ struct hostapd_data {
+@@ -118,6 +119,7 @@ struct hostapd_data {
  	struct hostapd_iface *iface;
  	struct hostapd_config *iconf;
  	struct hostapd_bss_config *conf;
@@ -30,7 +30,7 @@
  	int interface_added; /* virtual interface added for this BSS */
  	unsigned int started:1;
  	unsigned int disabled:1;
-@@ -328,6 +330,8 @@ struct hostapd_iface {
+@@ -323,6 +325,8 @@ struct hostapd_iface {
  	struct hostapd_config *conf;
  	char phy[16]; /* Name of the PHY (radio) */
  
@@ -39,9 +39,629 @@
  	enum hostapd_iface_state {
  		HAPD_IFACE_UNINITIALIZED,
  		HAPD_IFACE_DISABLED,
+--- /dev/null
++++ b/src/ap/ubus.c
+@@ -0,0 +1,536 @@
++/*
++ * hostapd / ubus support
++ * Copyright (c) 2013, Felix Fietkau <nbd@openwrt.org>
++ *
++ * This software may be distributed under the terms of the BSD license.
++ * See README for more details.
++ */
++
++#include "utils/includes.h"
++#include "utils/common.h"
++#include "utils/eloop.h"
++#include "common/ieee802_11_defs.h"
++#include "hostapd.h"
++#include "wps_hostapd.h"
++#include "sta_info.h"
++#include "ubus.h"
++#include "ap_drv_ops.h"
++#include "beacon.h"
++
++static struct ubus_context *ctx;
++static struct blob_buf b;
++static int ctx_ref;
++
++static inline struct hostapd_data *get_hapd_from_object(struct ubus_object *obj)
++{
++	return container_of(obj, struct hostapd_data, ubus.obj);
++}
++
++
++struct ubus_banned_client {
++	struct avl_node avl;
++	u8 addr[ETH_ALEN];
++};
++
++static void ubus_receive(int sock, void *eloop_ctx, void *sock_ctx)
++{
++	struct ubus_context *ctx = eloop_ctx;
++	ubus_handle_event(ctx);
++}
++
++static void ubus_reconnect_timeout(void *eloop_data, void *user_ctx)
++{
++	if (ubus_reconnect(ctx, NULL)) {
++		eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
++		return;
++	}
++
++	eloop_register_read_sock(ctx->sock.fd, ubus_receive, ctx, NULL);
++}
++
++static void hostapd_ubus_connection_lost(struct ubus_context *ctx)
++{
++	eloop_unregister_read_sock(ctx->sock.fd);
++	eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
++}
++
++static bool hostapd_ubus_init(void)
++{
++	if (ctx)
++		return true;
++
++	ctx = ubus_connect(NULL);
++	if (!ctx)
++		return false;
++
++	ctx->connection_lost = hostapd_ubus_connection_lost;
++	eloop_register_read_sock(ctx->sock.fd, ubus_receive, ctx, NULL);
++	return true;
++}
++
++static void hostapd_ubus_ref_inc(void)
++{
++	ctx_ref++;
++}
++
++static void hostapd_ubus_ref_dec(void)
++{
++	ctx_ref--;
++	if (!ctx)
++		return;
++
++	if (ctx_ref)
++		return;
++
++	eloop_unregister_read_sock(ctx->sock.fd);
++	ubus_free(ctx);
++	ctx = NULL;
++}
++
++void hostapd_ubus_add_iface(struct hostapd_iface *iface)
++{
++	if (!hostapd_ubus_init())
++		return;
++}
++
++void hostapd_ubus_free_iface(struct hostapd_iface *iface)
++{
++	if (!ctx)
++		return;
++}
++
++static void
++hostapd_bss_del_ban(void *eloop_data, void *user_ctx)
++{
++	struct ubus_banned_client *ban = eloop_data;
++	struct hostapd_data *hapd = user_ctx;
++
++	avl_delete(&hapd->ubus.banned, &ban->avl);
++	free(ban);
++}
++
++static void
++hostapd_bss_ban_client(struct hostapd_data *hapd, u8 *addr, int time)
++{
++	struct ubus_banned_client *ban;
++
++	if (time < 0)
++		time = 0;
++
++	ban = avl_find_element(&hapd->ubus.banned, addr, ban, avl);
++	if (!ban) {
++		if (!time)
++			return;
++
++		ban = os_zalloc(sizeof(*ban));
++		memcpy(ban->addr, addr, sizeof(ban->addr));
++		ban->avl.key = ban->addr;
++		avl_insert(&hapd->ubus.banned, &ban->avl);
++	} else {
++		eloop_cancel_timeout(hostapd_bss_del_ban, ban, hapd);
++		if (!time) {
++			hostapd_bss_del_ban(ban, hapd);
++			return;
++		}
++	}
++
++	eloop_register_timeout(0, time * 1000, hostapd_bss_del_ban, ban, hapd);
++}
++
++static int
++hostapd_bss_get_clients(struct ubus_context *ctx, struct ubus_object *obj,
++			struct ubus_request_data *req, const char *method,
++			struct blob_attr *msg)
++{
++	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
++	struct sta_info *sta;
++	void *list, *c;
++	char mac_buf[20];
++	static const struct {
++		const char *name;
++		uint32_t flag;
++	} sta_flags[] = {
++		{ "auth", WLAN_STA_AUTH },
++		{ "assoc", WLAN_STA_ASSOC },
++		{ "authorized", WLAN_STA_AUTHORIZED },
++		{ "preauth", WLAN_STA_PREAUTH },
++		{ "wds", WLAN_STA_WDS },
++		{ "wmm", WLAN_STA_WMM },
++		{ "ht", WLAN_STA_HT },
++		{ "vht", WLAN_STA_VHT },
++		{ "wps", WLAN_STA_WPS },
++		{ "mfp", WLAN_STA_MFP },
++	};
++
++	blob_buf_init(&b, 0);
++	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
++	list = blobmsg_open_table(&b, "clients");
++	for (sta = hapd->sta_list; sta; sta = sta->next) {
++		int i;
++
++		sprintf(mac_buf, MACSTR, MAC2STR(sta->addr));
++		c = blobmsg_open_table(&b, mac_buf);
++		for (i = 0; i < ARRAY_SIZE(sta_flags); i++)
++			blobmsg_add_u8(&b, sta_flags[i].name,
++				       !!(sta->flags & sta_flags[i].flag));
++		blobmsg_add_u32(&b, "aid", sta->aid);
++		blobmsg_close_table(&b, c);
++	}
++	blobmsg_close_array(&b, list);
++	ubus_send_reply(ctx, req, b.head);
++
++	return 0;
++}
++
++enum {
++	DEL_CLIENT_ADDR,
++	DEL_CLIENT_REASON,
++	DEL_CLIENT_DEAUTH,
++	DEL_CLIENT_BAN_TIME,
++	__DEL_CLIENT_MAX
++};
++
++static const struct blobmsg_policy del_policy[__DEL_CLIENT_MAX] = {
++	[DEL_CLIENT_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
++	[DEL_CLIENT_REASON] = { "reason", BLOBMSG_TYPE_INT32 },
++	[DEL_CLIENT_DEAUTH] = { "deauth", BLOBMSG_TYPE_INT8 },
++	[DEL_CLIENT_BAN_TIME] = { "ban_time", BLOBMSG_TYPE_INT32 },
++};
++
++static int
++hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
++			struct ubus_request_data *req, const char *method,
++			struct blob_attr *msg)
++{
++	struct blob_attr *tb[__DEL_CLIENT_MAX];
++	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
++	struct sta_info *sta;
++	bool deauth = false;
++	int reason;
++	u8 addr[ETH_ALEN];
++
++	blobmsg_parse(del_policy, __DEL_CLIENT_MAX, tb, blob_data(msg), blob_len(msg));
++
++	if (!tb[DEL_CLIENT_ADDR])
++		return UBUS_STATUS_INVALID_ARGUMENT;
++
++	if (hwaddr_aton(blobmsg_data(tb[DEL_CLIENT_ADDR]), addr))
++		return UBUS_STATUS_INVALID_ARGUMENT;
++
++	if (tb[DEL_CLIENT_REASON])
++		reason = blobmsg_get_u32(tb[DEL_CLIENT_REASON]);
++
++	if (tb[DEL_CLIENT_DEAUTH])
++		deauth = blobmsg_get_bool(tb[DEL_CLIENT_DEAUTH]);
++
++	sta = ap_get_sta(hapd, addr);
++	if (sta) {
++		if (deauth) {
++			hostapd_drv_sta_deauth(hapd, addr, reason);
++			ap_sta_deauthenticate(hapd, sta, reason);
++		} else {
++			hostapd_drv_sta_disassoc(hapd, addr, reason);
++			ap_sta_disassociate(hapd, sta, reason);
++		}
++	}
++
++	if (tb[DEL_CLIENT_BAN_TIME])
++		hostapd_bss_ban_client(hapd, addr, blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]));
++
++	return 0;
++}
++
++static void
++blobmsg_add_macaddr(struct blob_buf *buf, const char *name, const u8 *addr)
++{
++	char *s;
++
++	s = blobmsg_alloc_string_buffer(buf, name, 20);
++	sprintf(s, MACSTR, MAC2STR(addr));
++	blobmsg_add_string_buffer(buf);
++}
++
++static int
++hostapd_bss_list_bans(struct ubus_context *ctx, struct ubus_object *obj,
++		      struct ubus_request_data *req, const char *method,
++		      struct blob_attr *msg)
++{
++	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
++	struct ubus_banned_client *ban;
++	void *c;
++
++	blob_buf_init(&b, 0);
++	c = blobmsg_open_array(&b, "clients");
++	avl_for_each_element(&hapd->ubus.banned, ban, avl)
++		blobmsg_add_macaddr(&b, NULL, ban->addr);
++	blobmsg_close_array(&b, c);
++	ubus_send_reply(ctx, req, b.head);
++
++	return 0;
++}
++
++static int
++hostapd_bss_wps_start(struct ubus_context *ctx, struct ubus_object *obj,
++			struct ubus_request_data *req, const char *method,
++			struct blob_attr *msg)
++{
++	int rc;
++	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
++
++	rc = hostapd_wps_button_pushed(hapd, NULL);
++
++	if (rc != 0)
++		return UBUS_STATUS_NOT_SUPPORTED;
++
++	return 0;
++}
++
++static int
++hostapd_bss_wps_cancel(struct ubus_context *ctx, struct ubus_object *obj,
++			struct ubus_request_data *req, const char *method,
++			struct blob_attr *msg)
++{
++	int rc;
++	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
++
++	rc = hostapd_wps_cancel(hapd);
++
++	if (rc != 0)
++		return UBUS_STATUS_NOT_SUPPORTED;
++
++	return 0;
++}
++
++static int
++hostapd_bss_update_beacon(struct ubus_context *ctx, struct ubus_object *obj,
++			struct ubus_request_data *req, const char *method,
++			struct blob_attr *msg)
++{
++	int rc;
++	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
++
++	rc = ieee802_11_set_beacon(hapd);
++
++	if (rc != 0)
++		return UBUS_STATUS_NOT_SUPPORTED;
++
++	return 0;
++}
++
++enum {
++	CSA_FREQ,
++	CSA_BCN_COUNT,
++	__CSA_MAX
++};
++
++static const struct blobmsg_policy csa_policy[__CSA_MAX] = {
++	/*
++	 * for now, frequency and beacon count are enough, add more
++	 * parameters on demand
++	 */
++	[CSA_FREQ] = { "freq", BLOBMSG_TYPE_INT32 },
++	[CSA_BCN_COUNT] = { "bcn_count", BLOBMSG_TYPE_INT32 },
++};
++
++#ifdef NEED_AP_MLME
++static int
++hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
++		    struct ubus_request_data *req, const char *method,
++		    struct blob_attr *msg)
++{
++	struct blob_attr *tb[__CSA_MAX];
++	struct hostapd_data *hapd = get_hapd_from_object(obj);
++	struct csa_settings css;
++
++	blobmsg_parse(csa_policy, __CSA_MAX, tb, blob_data(msg), blob_len(msg));
++
++	if (!tb[CSA_FREQ])
++		return UBUS_STATUS_INVALID_ARGUMENT;
++
++	memset(&css, 0, sizeof(css));
++	css.freq_params.freq = blobmsg_get_u32(tb[CSA_FREQ]);
++	if (tb[CSA_BCN_COUNT])
++		css.cs_count = blobmsg_get_u32(tb[CSA_BCN_COUNT]);
++
++	if (hostapd_switch_channel(hapd, &css) != 0)
++		return UBUS_STATUS_NOT_SUPPORTED;
++	return UBUS_STATUS_OK;
++}
++#endif
++
++enum {
++	VENDOR_ELEMENTS,
++	__VENDOR_ELEMENTS_MAX
++};
++
++static const struct blobmsg_policy ve_policy[__VENDOR_ELEMENTS_MAX] = {
++	/* vendor elements are provided as hex-string */
++	[VENDOR_ELEMENTS] = { "vendor_elements", BLOBMSG_TYPE_STRING },
++};
++
++static int
++hostapd_vendor_elements(struct ubus_context *ctx, struct ubus_object *obj,
++			struct ubus_request_data *req, const char *method,
++			struct blob_attr *msg)
++{
++	struct blob_attr *tb[__VENDOR_ELEMENTS_MAX];
++	struct hostapd_data *hapd = get_hapd_from_object(obj);
++	struct hostapd_bss_config *bss = hapd->conf;
++	struct wpabuf *elems;
++	const char *pos;
++	size_t len;
++
++	blobmsg_parse(ve_policy, __VENDOR_ELEMENTS_MAX, tb,
++		      blob_data(msg), blob_len(msg));
++
++	if (!tb[VENDOR_ELEMENTS])
++		return UBUS_STATUS_INVALID_ARGUMENT;
++
++	pos = blobmsg_data(tb[VENDOR_ELEMENTS]);
++	len = os_strlen(pos);
++	if (len & 0x01)
++			return UBUS_STATUS_INVALID_ARGUMENT;
++
++	len /= 2;
++	if (len == 0) {
++		wpabuf_free(bss->vendor_elements);
++		bss->vendor_elements = NULL;
++		return 0;
++	}
++
++	elems = wpabuf_alloc(len);
++	if (elems == NULL)
++		return 1;
++
++	if (hexstr2bin(pos, wpabuf_put(elems, len), len)) {
++		wpabuf_free(elems);
++		return UBUS_STATUS_INVALID_ARGUMENT;
++	}
++
++	wpabuf_free(bss->vendor_elements);
++	bss->vendor_elements = elems;
++
++	/* update beacons if vendor elements were set successfully */
++	if (ieee802_11_update_beacons(hapd->iface) != 0)
++		return UBUS_STATUS_NOT_SUPPORTED;
++	return UBUS_STATUS_OK;
++}
++
++static const struct ubus_method bss_methods[] = {
++	UBUS_METHOD_NOARG("get_clients", hostapd_bss_get_clients),
++	UBUS_METHOD("del_client", hostapd_bss_del_client, del_policy),
++	UBUS_METHOD_NOARG("list_bans", hostapd_bss_list_bans),
++	UBUS_METHOD_NOARG("wps_start", hostapd_bss_wps_start),
++	UBUS_METHOD_NOARG("wps_cancel", hostapd_bss_wps_cancel),
++	UBUS_METHOD_NOARG("update_beacon", hostapd_bss_update_beacon),
++#ifdef NEED_AP_MLME
++	UBUS_METHOD("switch_chan", hostapd_switch_chan, csa_policy),
++#endif
++	UBUS_METHOD("set_vendor_elements", hostapd_vendor_elements, ve_policy),
++};
++
++static struct ubus_object_type bss_object_type =
++	UBUS_OBJECT_TYPE("hostapd_bss", bss_methods);
++
++static int avl_compare_macaddr(const void *k1, const void *k2, void *ptr)
++{
++	return memcmp(k1, k2, ETH_ALEN);
++}
++
++void hostapd_ubus_add_bss(struct hostapd_data *hapd)
++{
++	struct ubus_object *obj = &hapd->ubus.obj;
++	char *name;
++	int ret;
++
++	if (!hostapd_ubus_init())
++		return;
++
++	if (asprintf(&name, "hostapd.%s", hapd->conf->iface) < 0)
++		return;
++
++	avl_init(&hapd->ubus.banned, avl_compare_macaddr, false, NULL);
++	obj->name = name;
++	obj->type = &bss_object_type;
++	obj->methods = bss_object_type.methods;
++	obj->n_methods = bss_object_type.n_methods;
++	ret = ubus_add_object(ctx, obj);
++	hostapd_ubus_ref_inc();
++}
++
++void hostapd_ubus_free_bss(struct hostapd_data *hapd)
++{
++	struct ubus_object *obj = &hapd->ubus.obj;
++	char *name = (char *) obj->name;
++
++	if (!ctx)
++		return;
++
++	if (obj->id) {
++		ubus_remove_object(ctx, obj);
++		hostapd_ubus_ref_dec();
++	}
++
++	free(name);
++}
++
++struct ubus_event_req {
++	struct ubus_notify_request nreq;
++	bool deny;
++};
++
++static void
++ubus_event_cb(struct ubus_notify_request *req, int idx, int ret)
++{
++	struct ubus_event_req *ureq = container_of(req, struct ubus_event_req, nreq);
++
++	if (ret)
++		ureq->deny = true;
++}
++
++int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
++{
++	struct ubus_banned_client *ban;
++	const char *types[HOSTAPD_UBUS_TYPE_MAX] = {
++		[HOSTAPD_UBUS_PROBE_REQ] = "probe",
++		[HOSTAPD_UBUS_AUTH_REQ] = "auth",
++		[HOSTAPD_UBUS_ASSOC_REQ] = "assoc",
++	};
++	const char *type = "mgmt";
++	struct ubus_event_req ureq = {};
++	const u8 *addr;
++
++	if (req->mgmt_frame)
++		addr = req->mgmt_frame->sa;
++	else
++		addr = req->addr;
++
++	ban = avl_find_element(&hapd->ubus.banned, addr, ban, avl);
++	if (ban)
++		return -2;
++
++	if (!hapd->ubus.obj.has_subscribers)
++		return 0;
++
++	if (req->type < ARRAY_SIZE(types))
++		type = types[req->type];
++
++	blob_buf_init(&b, 0);
++	blobmsg_add_macaddr(&b, "address", addr);
++	if (req->mgmt_frame)
++		blobmsg_add_macaddr(&b, "target", req->mgmt_frame->da);
++	if (req->frame_info)
++		blobmsg_add_u32(&b, "signal", req->frame_info->ssi_signal);
++	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
++
++	if (ubus_notify_async(ctx, &hapd->ubus.obj, type, b.head, &ureq.nreq))
++		return 0;
++
++	ureq.nreq.status_cb = ubus_event_cb;
++	ubus_complete_request(ctx, &ureq.nreq.req, 100);
++
++	if (ureq.deny)
++		return -1;
++
++	return 0;
++}
+--- /dev/null
++++ b/src/ap/ubus.h
+@@ -0,0 +1,78 @@
++/*
++ * hostapd / ubus support
++ * Copyright (c) 2013, Felix Fietkau <nbd@openwrt.org>
++ *
++ * This software may be distributed under the terms of the BSD license.
++ * See README for more details.
++ */
++#ifndef __HOSTAPD_UBUS_H
++#define __HOSTAPD_UBUS_H
++
++enum hostapd_ubus_event_type {
++	HOSTAPD_UBUS_PROBE_REQ,
++	HOSTAPD_UBUS_AUTH_REQ,
++	HOSTAPD_UBUS_ASSOC_REQ,
++	HOSTAPD_UBUS_TYPE_MAX
++};
++
++struct hostapd_ubus_request {
++	enum hostapd_ubus_event_type type;
++	const struct ieee80211_mgmt *mgmt_frame;
++	const struct hostapd_frame_info *frame_info;
++	const u8 *addr;
++};
++
++struct hostapd_iface;
++struct hostapd_data;
++
++#ifdef UBUS_SUPPORT
++
++#include <libubox/avl.h>
++#include <libubus.h>
++
++struct hostapd_ubus_iface {
++	struct ubus_object obj;
++};
++
++struct hostapd_ubus_bss {
++	struct ubus_object obj;
++	struct avl_tree banned;
++};
++
++void hostapd_ubus_add_iface(struct hostapd_iface *iface);
++void hostapd_ubus_free_iface(struct hostapd_iface *iface);
++void hostapd_ubus_add_bss(struct hostapd_data *hapd);
++void hostapd_ubus_free_bss(struct hostapd_data *hapd);
++
++int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req);
++
++#else
++
++struct hostapd_ubus_iface {};
++
++struct hostapd_ubus_bss {};
++
++static inline void hostapd_ubus_add_iface(struct hostapd_iface *iface)
++{
++}
++
++static inline void hostapd_ubus_free_iface(struct hostapd_iface *iface)
++{
++}
++
++static inline void hostapd_ubus_add_bss(struct hostapd_data *hapd)
++{
++}
++
++static inline void hostapd_ubus_free_bss(struct hostapd_data *hapd)
++{
++}
++
++static inline int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
++{
++	return 0;
++}
++
++#endif
++
++#endif
 --- a/src/ap/hostapd.c
 +++ b/src/ap/hostapd.c
-@@ -302,6 +302,7 @@ static void hostapd_free_hapd_data(struc
+@@ -284,6 +284,7 @@ static void hostapd_free_hapd_data(struc
  	hapd->started = 0;
  
  	wpa_printf(MSG_DEBUG, "%s(%s)", __func__, hapd->conf->iface);
@@ -49,7 +669,7 @@
  	iapp_deinit(hapd->iapp);
  	hapd->iapp = NULL;
  	accounting_deinit(hapd);
-@@ -1160,6 +1161,8 @@ static int hostapd_setup_bss(struct host
+@@ -1139,6 +1140,8 @@ static int hostapd_setup_bss(struct host
  	if (hapd->driver && hapd->driver->set_operstate)
  		hapd->driver->set_operstate(hapd->drv_priv, 1);
  
@@ -58,7 +678,7 @@
  	return 0;
  }
  
-@@ -1683,6 +1686,7 @@ static int hostapd_setup_interface_compl
+@@ -1664,6 +1667,7 @@ static int hostapd_setup_interface_compl
  	if (err)
  		goto fail;
  
@@ -66,7 +686,7 @@
  	wpa_printf(MSG_DEBUG, "Completing interface initialization");
  	if (iface->conf->channel) {
  #ifdef NEED_AP_MLME
-@@ -1862,6 +1866,7 @@ dfs_offload:
+@@ -1844,6 +1848,7 @@ dfs_offload:
  
  fail:
  	wpa_printf(MSG_ERROR, "Interface initialization failed");
@@ -74,7 +694,7 @@
  	hostapd_set_state(iface, HAPD_IFACE_DISABLED);
  	wpa_msg(hapd->msg_ctx, MSG_INFO, AP_EVENT_DISABLED);
  #ifdef CONFIG_FST
-@@ -2310,6 +2315,7 @@ void hostapd_interface_deinit_free(struc
+@@ -2277,6 +2282,7 @@ void hostapd_interface_deinit_free(struc
  		   (unsigned int) iface->conf->num_bss);
  	driver = iface->bss[0]->driver;
  	drv_priv = iface->bss[0]->drv_priv;
@@ -84,7 +704,7 @@
  		   __func__, driver, drv_priv);
 --- a/src/ap/ieee802_11.c
 +++ b/src/ap/ieee802_11.c
-@@ -1293,7 +1293,8 @@ void ieee802_11_finish_fils_auth(struct
+@@ -980,7 +980,8 @@ int auth_sae_init_committed(struct hosta
  
  
  static void handle_auth(struct hostapd_data *hapd,
@@ -94,7 +714,7 @@
  {
  	u16 auth_alg, auth_transaction, status_code;
  	u16 resp = WLAN_STATUS_SUCCESS;
-@@ -1309,6 +1310,11 @@ static void handle_auth(struct hostapd_d
+@@ -996,6 +997,11 @@ static void handle_auth(struct hostapd_d
  	char *identity = NULL;
  	char *radius_cui = NULL;
  	u16 seq_ctrl;
@@ -106,7 +726,7 @@
  
  	os_memset(&vlan_id, 0, sizeof(vlan_id));
  
-@@ -1466,6 +1472,14 @@ static void handle_auth(struct hostapd_d
+@@ -1149,6 +1155,14 @@ static void handle_auth(struct hostapd_d
  		resp = WLAN_STATUS_UNSPECIFIED_FAILURE;
  		goto fail;
  	}
@@ -121,7 +741,7 @@
  	if (res == HOSTAPD_ACL_PENDING) {
  		wpa_printf(MSG_DEBUG, "Authentication frame from " MACSTR
  			   " waiting for an external authentication",
-@@ -2401,7 +2415,7 @@ static u16 send_assoc_resp(struct hostap
+@@ -2033,13 +2047,18 @@ static u16 send_assoc_resp(struct hostap
  
  static void handle_assoc(struct hostapd_data *hapd,
  			 const struct ieee80211_mgmt *mgmt, size_t len,
@@ -130,10 +750,9 @@
  {
  	u16 capab_info, listen_interval, seq_ctrl, fc;
  	u16 resp = WLAN_STATUS_SUCCESS, reply_res;
-@@ -2409,6 +2423,11 @@ static void handle_assoc(struct hostapd_
+ 	const u8 *pos;
  	int left, i;
  	struct sta_info *sta;
- 	u8 *tmp = NULL;
 +	struct hostapd_ubus_request req = {
 +		.type = HOSTAPD_UBUS_ASSOC_REQ,
 +		.mgmt_frame = mgmt,
@@ -142,7 +761,7 @@
  
  	if (len < IEEE80211_HDRLEN + (reassoc ? sizeof(mgmt->u.reassoc_req) :
  				      sizeof(mgmt->u.assoc_req))) {
-@@ -2528,6 +2547,13 @@ static void handle_assoc(struct hostapd_
+@@ -2159,6 +2178,13 @@ static void handle_assoc(struct hostapd_
  	}
  #endif /* CONFIG_MBO */
  
@@ -156,7 +775,7 @@
  	/*
  	 * sta->capability is used in check_assoc_ies() for RRM enabled
  	 * capability element.
-@@ -3035,7 +3061,7 @@ int ieee802_11_mgmt(struct hostapd_data
+@@ -2639,7 +2665,7 @@ int ieee802_11_mgmt(struct hostapd_data
  
  
  	if (stype == WLAN_FC_STYPE_PROBE_REQ) {
@@ -165,7 +784,7 @@
  		return 1;
  	}
  
-@@ -3053,17 +3079,17 @@ int ieee802_11_mgmt(struct hostapd_data
+@@ -2657,17 +2683,17 @@ int ieee802_11_mgmt(struct hostapd_data
  	switch (stype) {
  	case WLAN_FC_STYPE_AUTH:
  		wpa_printf(MSG_DEBUG, "mgmt::auth");
@@ -188,7 +807,7 @@
  	case WLAN_FC_STYPE_DISASSOC:
 --- a/src/ap/beacon.c
 +++ b/src/ap/beacon.c
-@@ -702,7 +702,7 @@ void sta_track_claim_taxonomy_info(struc
+@@ -675,7 +675,7 @@ sta_track_seen_on(struct hostapd_iface *
  
  void handle_probe_req(struct hostapd_data *hapd,
  		      const struct ieee80211_mgmt *mgmt, size_t len,
@@ -197,7 +816,7 @@
  {
  	u8 *resp;
  	struct ieee802_11_elems elems;
-@@ -711,9 +711,15 @@ void handle_probe_req(struct hostapd_dat
+@@ -684,9 +684,15 @@ void handle_probe_req(struct hostapd_dat
  	size_t i, resp_len;
  	int noack;
  	enum ssid_match_result res;
@@ -213,7 +832,7 @@
  
  	if (len < IEEE80211_HDRLEN)
  		return;
-@@ -880,6 +886,12 @@ void handle_probe_req(struct hostapd_dat
+@@ -838,6 +844,12 @@ void handle_probe_req(struct hostapd_dat
  	}
  #endif /* CONFIG_P2P */
  
@@ -250,7 +869,7 @@
  
  	if (addr == NULL) {
  		/*
-@@ -131,6 +135,12 @@ int hostapd_notif_assoc(struct hostapd_d
+@@ -124,6 +128,12 @@ int hostapd_notif_assoc(struct hostapd_d
  		goto fail;
  	}
  
diff --git a/package/network/services/hostapd/patches/700-160mhz_interop_workaround.patch b/package/network/services/hostapd/patches/700-160mhz_interop_workaround.patch
new file mode 100644
index 0000000000000000000000000000000000000000..75ece9b6ccc2c3a5e13a282d84d301fda3a47a2c
--- /dev/null
+++ b/package/network/services/hostapd/patches/700-160mhz_interop_workaround.patch
@@ -0,0 +1,48 @@
+VHT: Add an interoperability workaround for 80+80 and 160 MHz channels
+
+Number of deployed 80 MHz capable VHT stations that do not support 80+80
+and 160 MHz bandwidths seem to misbehave when trying to connect to an AP
+that advertises 80+80 or 160 MHz channel bandwidth in the VHT Operation
+element. To avoid such issues with deployed devices, modify the design
+based on newly proposed IEEE 802.11 standard changes.
+
+This allows poorly implemented VHT 80 MHz stations to connect with the
+AP in 80 MHz mode. 80+80 and 160 MHz capable stations need to support
+the new workaround mechanism to allow full bandwidth to be used.
+However, there are more or less no impacted station with 80+80/160
+capability deployed.
+
+Signed-off-by: Jouni Malinen <jouni@qca.qualcomm.com>
+
+diff --git a/src/ap/ieee802_11_vht.c b/src/ap/ieee802_11_vht.c
+index 3236016..e923094 100644
+--- a/src/ap/ieee802_11_vht.c
++++ b/src/ap/ieee802_11_vht.c
+@@ -82,6 +82,27 @@ u8 * hostapd_eid_vht_operation(struct hostapd_data *hapd, u8 *eid)
+ 
+ 	oper->vht_op_info_chwidth = hapd->iconf->vht_oper_chwidth;
+ 
++	if (hapd->iconf->vht_oper_chwidth == 2) {
++		/*
++		 * Convert 160 MHz channel width to new style as interop
++		 * workaround.
++		 */
++		oper->vht_op_info_chwidth = 1;
++		oper->vht_op_info_chan_center_freq_seg1_idx =
++			oper->vht_op_info_chan_center_freq_seg0_idx;
++		if (hapd->iconf->channel <
++		    hapd->iconf->vht_oper_centr_freq_seg0_idx)
++				oper->vht_op_info_chan_center_freq_seg0_idx -= 8;
++			else
++				oper->vht_op_info_chan_center_freq_seg0_idx += 8;
++	} else if (hapd->iconf->vht_oper_chwidth == 3) {
++		/*
++		 * Convert 80+80 MHz channel width to new style as interop
++		 * workaround.
++		 */
++		oper->vht_op_info_chwidth = 1;
++	}
++
+ 	/* VHT Basic MCS set comes from hw */
+ 	/* Hard code 1 stream, MCS0-7 is a min Basic VHT MCS rates */
+ 	oper->vht_basic_mcs_set = host_to_le16(0xfffc);
diff --git a/package/network/services/hostapd/patches/900-no_channel_switch.patch b/package/network/services/hostapd/patches/900-no_channel_switch.patch
deleted file mode 100644
index c6145156928ffa5a5195ca145b0655bb88c92091..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/patches/900-no_channel_switch.patch
+++ /dev/null
@@ -1,68 +0,0 @@
---- a/src/common/hw_features_common.c
-+++ b/src/common/hw_features_common.c
-@@ -171,7 +171,6 @@ int check_40mhz_5g(struct hostapd_hw_mod
- 		   struct wpa_scan_results *scan_res, int pri_chan,
- 		   int sec_chan)
- {
--	int pri_freq, sec_freq, pri_bss, sec_bss;
- 	int bss_pri_chan, bss_sec_chan;
- 	size_t i;
- 	int match;
-@@ -180,57 +179,6 @@ int check_40mhz_5g(struct hostapd_hw_mod
- 	    pri_chan == sec_chan)
- 		return 0;
- 
--	pri_freq = hw_get_freq(mode, pri_chan);
--	sec_freq = hw_get_freq(mode, sec_chan);
--
--	/*
--	 * Switch PRI/SEC channels if Beacons were detected on selected SEC
--	 * channel, but not on selected PRI channel.
--	 */
--	pri_bss = sec_bss = 0;
--	for (i = 0; i < scan_res->num; i++) {
--		struct wpa_scan_res *bss = scan_res->res[i];
--		if (bss->freq == pri_freq)
--			pri_bss++;
--		else if (bss->freq == sec_freq)
--			sec_bss++;
--	}
--	if (sec_bss && !pri_bss) {
--		wpa_printf(MSG_INFO,
--			   "Switch own primary and secondary channel to get secondary channel with no Beacons from other BSSes");
--		return 2;
--	}
--
--	/*
--	 * Match PRI/SEC channel with any existing HT40 BSS on the same
--	 * channels that we are about to use (if already mixed order in
--	 * existing BSSes, use own preference).
--	 */
--	match = 0;
--	for (i = 0; i < scan_res->num; i++) {
--		struct wpa_scan_res *bss = scan_res->res[i];
--		get_pri_sec_chan(bss, &bss_pri_chan, &bss_sec_chan);
--		if (pri_chan == bss_pri_chan &&
--		    sec_chan == bss_sec_chan) {
--			match = 1;
--			break;
--		}
--	}
--	if (!match) {
--		for (i = 0; i < scan_res->num; i++) {
--			struct wpa_scan_res *bss = scan_res->res[i];
--			get_pri_sec_chan(bss, &bss_pri_chan, &bss_sec_chan);
--			if (pri_chan == bss_sec_chan &&
--			    sec_chan == bss_pri_chan) {
--				wpa_printf(MSG_INFO, "Switch own primary and "
--					   "secondary channel due to BSS "
--					   "overlap with " MACSTR,
--					   MAC2STR(bss->bssid));
--				return 2;
--			}
--		}
--	}
--
- 	return 1;
- }
- 
diff --git a/package/network/services/hostapd/src/src/ap/ubus.c b/package/network/services/hostapd/src/src/ap/ubus.c
deleted file mode 100644
index c24f63fd8bbab77520f5da7a5bcdc720c452e142..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/src/src/ap/ubus.c
+++ /dev/null
@@ -1,536 +0,0 @@
-/*
- * hostapd / ubus support
- * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-
-#include "utils/includes.h"
-#include "utils/common.h"
-#include "utils/eloop.h"
-#include "common/ieee802_11_defs.h"
-#include "hostapd.h"
-#include "wps_hostapd.h"
-#include "sta_info.h"
-#include "ubus.h"
-#include "ap_drv_ops.h"
-#include "beacon.h"
-
-static struct ubus_context *ctx;
-static struct blob_buf b;
-static int ctx_ref;
-
-static inline struct hostapd_data *get_hapd_from_object(struct ubus_object *obj)
-{
-	return container_of(obj, struct hostapd_data, ubus.obj);
-}
-
-
-struct ubus_banned_client {
-	struct avl_node avl;
-	u8 addr[ETH_ALEN];
-};
-
-static void ubus_receive(int sock, void *eloop_ctx, void *sock_ctx)
-{
-	struct ubus_context *ctx = eloop_ctx;
-	ubus_handle_event(ctx);
-}
-
-static void ubus_reconnect_timeout(void *eloop_data, void *user_ctx)
-{
-	if (ubus_reconnect(ctx, NULL)) {
-		eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
-		return;
-	}
-
-	eloop_register_read_sock(ctx->sock.fd, ubus_receive, ctx, NULL);
-}
-
-static void hostapd_ubus_connection_lost(struct ubus_context *ctx)
-{
-	eloop_unregister_read_sock(ctx->sock.fd);
-	eloop_register_timeout(1, 0, ubus_reconnect_timeout, ctx, NULL);
-}
-
-static bool hostapd_ubus_init(void)
-{
-	if (ctx)
-		return true;
-
-	ctx = ubus_connect(NULL);
-	if (!ctx)
-		return false;
-
-	ctx->connection_lost = hostapd_ubus_connection_lost;
-	eloop_register_read_sock(ctx->sock.fd, ubus_receive, ctx, NULL);
-	return true;
-}
-
-static void hostapd_ubus_ref_inc(void)
-{
-	ctx_ref++;
-}
-
-static void hostapd_ubus_ref_dec(void)
-{
-	ctx_ref--;
-	if (!ctx)
-		return;
-
-	if (ctx_ref)
-		return;
-
-	eloop_unregister_read_sock(ctx->sock.fd);
-	ubus_free(ctx);
-	ctx = NULL;
-}
-
-void hostapd_ubus_add_iface(struct hostapd_iface *iface)
-{
-	if (!hostapd_ubus_init())
-		return;
-}
-
-void hostapd_ubus_free_iface(struct hostapd_iface *iface)
-{
-	if (!ctx)
-		return;
-}
-
-static void
-hostapd_bss_del_ban(void *eloop_data, void *user_ctx)
-{
-	struct ubus_banned_client *ban = eloop_data;
-	struct hostapd_data *hapd = user_ctx;
-
-	avl_delete(&hapd->ubus.banned, &ban->avl);
-	free(ban);
-}
-
-static void
-hostapd_bss_ban_client(struct hostapd_data *hapd, u8 *addr, int time)
-{
-	struct ubus_banned_client *ban;
-
-	if (time < 0)
-		time = 0;
-
-	ban = avl_find_element(&hapd->ubus.banned, addr, ban, avl);
-	if (!ban) {
-		if (!time)
-			return;
-
-		ban = os_zalloc(sizeof(*ban));
-		memcpy(ban->addr, addr, sizeof(ban->addr));
-		ban->avl.key = ban->addr;
-		avl_insert(&hapd->ubus.banned, &ban->avl);
-	} else {
-		eloop_cancel_timeout(hostapd_bss_del_ban, ban, hapd);
-		if (!time) {
-			hostapd_bss_del_ban(ban, hapd);
-			return;
-		}
-	}
-
-	eloop_register_timeout(0, time * 1000, hostapd_bss_del_ban, ban, hapd);
-}
-
-static int
-hostapd_bss_get_clients(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	struct sta_info *sta;
-	void *list, *c;
-	char mac_buf[20];
-	static const struct {
-		const char *name;
-		uint32_t flag;
-	} sta_flags[] = {
-		{ "auth", WLAN_STA_AUTH },
-		{ "assoc", WLAN_STA_ASSOC },
-		{ "authorized", WLAN_STA_AUTHORIZED },
-		{ "preauth", WLAN_STA_PREAUTH },
-		{ "wds", WLAN_STA_WDS },
-		{ "wmm", WLAN_STA_WMM },
-		{ "ht", WLAN_STA_HT },
-		{ "vht", WLAN_STA_VHT },
-		{ "wps", WLAN_STA_WPS },
-		{ "mfp", WLAN_STA_MFP },
-	};
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
-	list = blobmsg_open_table(&b, "clients");
-	for (sta = hapd->sta_list; sta; sta = sta->next) {
-		int i;
-
-		sprintf(mac_buf, MACSTR, MAC2STR(sta->addr));
-		c = blobmsg_open_table(&b, mac_buf);
-		for (i = 0; i < ARRAY_SIZE(sta_flags); i++)
-			blobmsg_add_u8(&b, sta_flags[i].name,
-				       !!(sta->flags & sta_flags[i].flag));
-		blobmsg_add_u32(&b, "aid", sta->aid);
-		blobmsg_close_table(&b, c);
-	}
-	blobmsg_close_array(&b, list);
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-enum {
-	DEL_CLIENT_ADDR,
-	DEL_CLIENT_REASON,
-	DEL_CLIENT_DEAUTH,
-	DEL_CLIENT_BAN_TIME,
-	__DEL_CLIENT_MAX
-};
-
-static const struct blobmsg_policy del_policy[__DEL_CLIENT_MAX] = {
-	[DEL_CLIENT_ADDR] = { "addr", BLOBMSG_TYPE_STRING },
-	[DEL_CLIENT_REASON] = { "reason", BLOBMSG_TYPE_INT32 },
-	[DEL_CLIENT_DEAUTH] = { "deauth", BLOBMSG_TYPE_INT8 },
-	[DEL_CLIENT_BAN_TIME] = { "ban_time", BLOBMSG_TYPE_INT32 },
-};
-
-static int
-hostapd_bss_del_client(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	struct blob_attr *tb[__DEL_CLIENT_MAX];
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	struct sta_info *sta;
-	bool deauth = false;
-	int reason;
-	u8 addr[ETH_ALEN];
-
-	blobmsg_parse(del_policy, __DEL_CLIENT_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[DEL_CLIENT_ADDR])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (hwaddr_aton(blobmsg_data(tb[DEL_CLIENT_ADDR]), addr))
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	if (tb[DEL_CLIENT_REASON])
-		reason = blobmsg_get_u32(tb[DEL_CLIENT_REASON]);
-
-	if (tb[DEL_CLIENT_DEAUTH])
-		deauth = blobmsg_get_bool(tb[DEL_CLIENT_DEAUTH]);
-
-	sta = ap_get_sta(hapd, addr);
-	if (sta) {
-		if (deauth) {
-			hostapd_drv_sta_deauth(hapd, addr, reason);
-			ap_sta_deauthenticate(hapd, sta, reason);
-		} else {
-			hostapd_drv_sta_disassoc(hapd, addr, reason);
-			ap_sta_disassociate(hapd, sta, reason);
-		}
-	}
-
-	if (tb[DEL_CLIENT_BAN_TIME])
-		hostapd_bss_ban_client(hapd, addr, blobmsg_get_u32(tb[DEL_CLIENT_BAN_TIME]));
-
-	return 0;
-}
-
-static void
-blobmsg_add_macaddr(struct blob_buf *buf, const char *name, const u8 *addr)
-{
-	char *s;
-
-	s = blobmsg_alloc_string_buffer(buf, name, 20);
-	sprintf(s, MACSTR, MAC2STR(addr));
-	blobmsg_add_string_buffer(buf);
-}
-
-static int
-hostapd_bss_list_bans(struct ubus_context *ctx, struct ubus_object *obj,
-		      struct ubus_request_data *req, const char *method,
-		      struct blob_attr *msg)
-{
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-	struct ubus_banned_client *ban;
-	void *c;
-
-	blob_buf_init(&b, 0);
-	c = blobmsg_open_array(&b, "clients");
-	avl_for_each_element(&hapd->ubus.banned, ban, avl)
-		blobmsg_add_macaddr(&b, NULL, ban->addr);
-	blobmsg_close_array(&b, c);
-	ubus_send_reply(ctx, req, b.head);
-
-	return 0;
-}
-
-static int
-hostapd_bss_wps_start(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	int rc;
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-
-	rc = hostapd_wps_button_pushed(hapd, NULL);
-
-	if (rc != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-
-	return 0;
-}
-
-static int
-hostapd_bss_wps_cancel(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	int rc;
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-
-	rc = hostapd_wps_cancel(hapd);
-
-	if (rc != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-
-	return 0;
-}
-
-static int
-hostapd_bss_update_beacon(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	int rc;
-	struct hostapd_data *hapd = container_of(obj, struct hostapd_data, ubus.obj);
-
-	rc = ieee802_11_set_beacon(hapd);
-
-	if (rc != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-
-	return 0;
-}
-
-enum {
-	CSA_FREQ,
-	CSA_BCN_COUNT,
-	__CSA_MAX
-};
-
-static const struct blobmsg_policy csa_policy[__CSA_MAX] = {
-	/*
-	 * for now, frequency and beacon count are enough, add more
-	 * parameters on demand
-	 */
-	[CSA_FREQ] = { "freq", BLOBMSG_TYPE_INT32 },
-	[CSA_BCN_COUNT] = { "bcn_count", BLOBMSG_TYPE_INT32 },
-};
-
-#ifdef NEED_AP_MLME
-static int
-hostapd_switch_chan(struct ubus_context *ctx, struct ubus_object *obj,
-		    struct ubus_request_data *req, const char *method,
-		    struct blob_attr *msg)
-{
-	struct blob_attr *tb[__CSA_MAX];
-	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct csa_settings css;
-
-	blobmsg_parse(csa_policy, __CSA_MAX, tb, blob_data(msg), blob_len(msg));
-
-	if (!tb[CSA_FREQ])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	memset(&css, 0, sizeof(css));
-	css.freq_params.freq = blobmsg_get_u32(tb[CSA_FREQ]);
-	if (tb[CSA_BCN_COUNT])
-		css.cs_count = blobmsg_get_u32(tb[CSA_BCN_COUNT]);
-
-	if (hostapd_switch_channel(hapd, &css) != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-	return UBUS_STATUS_OK;
-}
-#endif
-
-enum {
-	VENDOR_ELEMENTS,
-	__VENDOR_ELEMENTS_MAX
-};
-
-static const struct blobmsg_policy ve_policy[__VENDOR_ELEMENTS_MAX] = {
-	/* vendor elements are provided as hex-string */
-	[VENDOR_ELEMENTS] = { "vendor_elements", BLOBMSG_TYPE_STRING },
-};
-
-static int
-hostapd_vendor_elements(struct ubus_context *ctx, struct ubus_object *obj,
-			struct ubus_request_data *req, const char *method,
-			struct blob_attr *msg)
-{
-	struct blob_attr *tb[__VENDOR_ELEMENTS_MAX];
-	struct hostapd_data *hapd = get_hapd_from_object(obj);
-	struct hostapd_bss_config *bss = hapd->conf;
-	struct wpabuf *elems;
-	const char *pos;
-	size_t len;
-
-	blobmsg_parse(ve_policy, __VENDOR_ELEMENTS_MAX, tb,
-		      blob_data(msg), blob_len(msg));
-
-	if (!tb[VENDOR_ELEMENTS])
-		return UBUS_STATUS_INVALID_ARGUMENT;
-
-	pos = blobmsg_data(tb[VENDOR_ELEMENTS]);
-	len = os_strlen(pos);
-	if (len & 0x01)
-			return UBUS_STATUS_INVALID_ARGUMENT;
-
-	len /= 2;
-	if (len == 0) {
-		wpabuf_free(bss->vendor_elements);
-		bss->vendor_elements = NULL;
-		return 0;
-	}
-
-	elems = wpabuf_alloc(len);
-	if (elems == NULL)
-		return 1;
-
-	if (hexstr2bin(pos, wpabuf_put(elems, len), len)) {
-		wpabuf_free(elems);
-		return UBUS_STATUS_INVALID_ARGUMENT;
-	}
-
-	wpabuf_free(bss->vendor_elements);
-	bss->vendor_elements = elems;
-
-	/* update beacons if vendor elements were set successfully */
-	if (ieee802_11_update_beacons(hapd->iface) != 0)
-		return UBUS_STATUS_NOT_SUPPORTED;
-	return UBUS_STATUS_OK;
-}
-
-static const struct ubus_method bss_methods[] = {
-	UBUS_METHOD_NOARG("get_clients", hostapd_bss_get_clients),
-	UBUS_METHOD("del_client", hostapd_bss_del_client, del_policy),
-	UBUS_METHOD_NOARG("list_bans", hostapd_bss_list_bans),
-	UBUS_METHOD_NOARG("wps_start", hostapd_bss_wps_start),
-	UBUS_METHOD_NOARG("wps_cancel", hostapd_bss_wps_cancel),
-	UBUS_METHOD_NOARG("update_beacon", hostapd_bss_update_beacon),
-#ifdef NEED_AP_MLME
-	UBUS_METHOD("switch_chan", hostapd_switch_chan, csa_policy),
-#endif
-	UBUS_METHOD("set_vendor_elements", hostapd_vendor_elements, ve_policy),
-};
-
-static struct ubus_object_type bss_object_type =
-	UBUS_OBJECT_TYPE("hostapd_bss", bss_methods);
-
-static int avl_compare_macaddr(const void *k1, const void *k2, void *ptr)
-{
-	return memcmp(k1, k2, ETH_ALEN);
-}
-
-void hostapd_ubus_add_bss(struct hostapd_data *hapd)
-{
-	struct ubus_object *obj = &hapd->ubus.obj;
-	char *name;
-	int ret;
-
-	if (!hostapd_ubus_init())
-		return;
-
-	if (asprintf(&name, "hostapd.%s", hapd->conf->iface) < 0)
-		return;
-
-	avl_init(&hapd->ubus.banned, avl_compare_macaddr, false, NULL);
-	obj->name = name;
-	obj->type = &bss_object_type;
-	obj->methods = bss_object_type.methods;
-	obj->n_methods = bss_object_type.n_methods;
-	ret = ubus_add_object(ctx, obj);
-	hostapd_ubus_ref_inc();
-}
-
-void hostapd_ubus_free_bss(struct hostapd_data *hapd)
-{
-	struct ubus_object *obj = &hapd->ubus.obj;
-	char *name = (char *) obj->name;
-
-	if (!ctx)
-		return;
-
-	if (obj->id) {
-		ubus_remove_object(ctx, obj);
-		hostapd_ubus_ref_dec();
-	}
-
-	free(name);
-}
-
-struct ubus_event_req {
-	struct ubus_notify_request nreq;
-	bool deny;
-};
-
-static void
-ubus_event_cb(struct ubus_notify_request *req, int idx, int ret)
-{
-	struct ubus_event_req *ureq = container_of(req, struct ubus_event_req, nreq);
-
-	if (ret)
-		ureq->deny = true;
-}
-
-int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
-{
-	struct ubus_banned_client *ban;
-	const char *types[HOSTAPD_UBUS_TYPE_MAX] = {
-		[HOSTAPD_UBUS_PROBE_REQ] = "probe",
-		[HOSTAPD_UBUS_AUTH_REQ] = "auth",
-		[HOSTAPD_UBUS_ASSOC_REQ] = "assoc",
-	};
-	const char *type = "mgmt";
-	struct ubus_event_req ureq = {};
-	const u8 *addr;
-
-	if (req->mgmt_frame)
-		addr = req->mgmt_frame->sa;
-	else
-		addr = req->addr;
-
-	ban = avl_find_element(&hapd->ubus.banned, addr, ban, avl);
-	if (ban)
-		return -2;
-
-	if (!hapd->ubus.obj.has_subscribers)
-		return 0;
-
-	if (req->type < ARRAY_SIZE(types))
-		type = types[req->type];
-
-	blob_buf_init(&b, 0);
-	blobmsg_add_macaddr(&b, "address", addr);
-	if (req->mgmt_frame)
-		blobmsg_add_macaddr(&b, "target", req->mgmt_frame->da);
-	if (req->frame_info)
-		blobmsg_add_u32(&b, "signal", req->frame_info->ssi_signal);
-	blobmsg_add_u32(&b, "freq", hapd->iface->freq);
-
-	if (ubus_notify_async(ctx, &hapd->ubus.obj, type, b.head, &ureq.nreq))
-		return 0;
-
-	ureq.nreq.status_cb = ubus_event_cb;
-	ubus_complete_request(ctx, &ureq.nreq.req, 100);
-
-	if (ureq.deny)
-		return -1;
-
-	return 0;
-}
diff --git a/package/network/services/hostapd/src/src/ap/ubus.h b/package/network/services/hostapd/src/src/ap/ubus.h
deleted file mode 100644
index 479ddfca7ac4bb56fbdf4f0d472f3481d3961b18..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/src/src/ap/ubus.h
+++ /dev/null
@@ -1,78 +0,0 @@
-/*
- * hostapd / ubus support
- * Copyright (c) 2013, Felix Fietkau <nbd@nbd.name>
- *
- * This software may be distributed under the terms of the BSD license.
- * See README for more details.
- */
-#ifndef __HOSTAPD_UBUS_H
-#define __HOSTAPD_UBUS_H
-
-enum hostapd_ubus_event_type {
-	HOSTAPD_UBUS_PROBE_REQ,
-	HOSTAPD_UBUS_AUTH_REQ,
-	HOSTAPD_UBUS_ASSOC_REQ,
-	HOSTAPD_UBUS_TYPE_MAX
-};
-
-struct hostapd_ubus_request {
-	enum hostapd_ubus_event_type type;
-	const struct ieee80211_mgmt *mgmt_frame;
-	const struct hostapd_frame_info *frame_info;
-	const u8 *addr;
-};
-
-struct hostapd_iface;
-struct hostapd_data;
-
-#ifdef UBUS_SUPPORT
-
-#include <libubox/avl.h>
-#include <libubus.h>
-
-struct hostapd_ubus_iface {
-	struct ubus_object obj;
-};
-
-struct hostapd_ubus_bss {
-	struct ubus_object obj;
-	struct avl_tree banned;
-};
-
-void hostapd_ubus_add_iface(struct hostapd_iface *iface);
-void hostapd_ubus_free_iface(struct hostapd_iface *iface);
-void hostapd_ubus_add_bss(struct hostapd_data *hapd);
-void hostapd_ubus_free_bss(struct hostapd_data *hapd);
-
-int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req);
-
-#else
-
-struct hostapd_ubus_iface {};
-
-struct hostapd_ubus_bss {};
-
-static inline void hostapd_ubus_add_iface(struct hostapd_iface *iface)
-{
-}
-
-static inline void hostapd_ubus_free_iface(struct hostapd_iface *iface)
-{
-}
-
-static inline void hostapd_ubus_add_bss(struct hostapd_data *hapd)
-{
-}
-
-static inline void hostapd_ubus_free_bss(struct hostapd_data *hapd)
-{
-}
-
-static inline int hostapd_ubus_handle_event(struct hostapd_data *hapd, struct hostapd_ubus_request *req)
-{
-	return 0;
-}
-
-#endif
-
-#endif
diff --git a/package/network/services/hostapd/src/src/utils/build_features.h b/package/network/services/hostapd/src/src/utils/build_features.h
deleted file mode 100644
index 315804361ce13aa9a8508e6d7cdae3c87a44a970..0000000000000000000000000000000000000000
--- a/package/network/services/hostapd/src/src/utils/build_features.h
+++ /dev/null
@@ -1,29 +0,0 @@
-#ifndef BUILD_FEATURES_H
-#define BUILD_FEATURES_H
-
-static inline int has_feature(const char *feat)
-{
-#if defined(IEEE8021X_EAPOL) || (defined(HOSTAPD) && !defined(CONFIG_NO_RADIUS))
-	if (!strcmp(feat, "eap"))
-		return 1;
-#endif
-#ifdef CONFIG_IEEE80211N
-	if (!strcmp(feat, "11n"))
-		return 1;
-#endif
-#ifdef CONFIG_IEEE80211AC
-	if (!strcmp(feat, "11ac"))
-		return 1;
-#endif
-#ifdef CONFIG_IEEE80211R
-	if (!strcmp(feat, "11r"))
-		return 1;
-#endif
-#ifdef CONFIG_IEEE80211W
-	if (!strcmp(feat, "11w"))
-		return 1;
-#endif
-	return 0;
-}
-
-#endif /* BUILD_FEATURES_H */
